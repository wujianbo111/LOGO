C51 COMPILER V9.01   DDC                                                                   03/09/2023 15:39:12 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE DDC
OBJECT MODULE PLACED IN .\obj\DDC.obj
COMPILER INVOKED BY: D:\Keil4\C51\BIN\C51.EXE ..\..\KERNEL\SCALER\DDC.c OPTIMIZE(SIZE) BROWSE INCDIR(..\..\DRIVER\INC;..
                    -\..\KERNEL\SCALER\INC;..\..\KERNEL\SYSTEM\INC;..\..\LIB\INC;..\..\PANEL\INC;..\..\BOARD;..\..\DRIVER\INC;..\..\KERNEL\SY
                    -STEM\INC\AOC2011;..\..\DRIVER\extDEVICE\INC;..\..\MODEL;..\..\CONFIG;..\..\PANEL;..\..\UI\F_LOGO\INC;..\..\UI\HkcOsd\INC
                    -) DEFINE(ModelName=JRY_TESTBOARD_C_BOARD) DEBUG OBJECTEXTEND PRINT(.\list\DDC.lst) OBJECT(.\obj\DDC.obj)

line level    source

   1          #include "types.h"
   2          #include "ms_reg.h"
   3          #include "ms_rwreg.h"
   4          #include "Global.h"
   5          #include "MsID_V1.h"
   6          #include "UserPref.h"
   7          #include "nvram.h"      //120420 Modify
   8          #include "msflash.h"
   9          
  10          #include "EDID.H"
  11          
  12          #include "I2C.H"
  13          
  14          extern void SetPWMFreq(WORD freq);
  15          #define CheckDDCAddr1   0x10
  16          #define CheckDDCAddr2   0x20
  17          
  18          #if (CHIP_ID==CHIP_TSUMF)
              #define _BIT(a)                         (BIT0 << a)
              #define MASKBIT(a)                      (_BIT((1?a) +1) -_BIT((0?a)))
              #endif
  22          //extern void i2c_WriteTBL(BYTE deviceID, WORD addr, BYTE *buffer, BYTE count);
  23          //extern void i2c_ReadTBL(BYTE deviceID,WORD addr,BYTE * buffer,BYTE count);
  24          
  25          
  26          #define NVRAM_ADDR_EDID          0x00
  27          #if ((!VGA_Write_EEPROM&&ENABLE_VGA)||(!DVI_Write_EEPROM&&ENABLE_DVI))
  28          void mStar_ClrDDC_WP(void)   
  29          {
  30   1              #if (ENABLE_DVI&&(!DVI_Write_EEPROM))
                              msWriteByte(REG_3E45, BIT7);
                      #else
  33   1                      msWriteByte(REG_3E45, BIT0);
  34   1              #endif
  35   1              msWriteByte(REG_3E49, BIT7); //ADC DDC disable write protect
  36   1              msWriteByte(REG_3E4B,msReadByte(REG_3E4B)&~BIT7);
  37   1      }
  38          
  39          void mStar_SetDDC_WP(void)    //
  40          {
  41   1              #if (ENABLE_DVI&&(!DVI_Write_EEPROM))
                              msWriteByte(REG_3E45, BIT7|BIT5);
                      #else
  44   1                      msWriteByte(REG_3E45, BIT0);
  45   1              #endif
  46   1         #if CHIP_ID==CHIP_TSUMF
                  msWriteByteMask(REG_3EFA, 0, 0x0F);   // REG_DDC_BANK_7D[4:0]: Select A0 EDID sram base address
                  msWriteByte(REG_3E49, BIT7|BIT5); //ADC DDC Enable write protect
                 #else
  50   1              msWriteByte(REG_3E49, BIT7|BIT5); //ADC DDC Enable write protect
  51   1           #endif     
  52   1              msWriteByte(REG_3E4B,msReadByte(REG_3E4B)|BIT7);
C51 COMPILER V9.01   DDC                                                                   03/09/2023 15:39:12 PAGE 2   

  53   1      }
  54          #endif
  55          #if User_DDCTO_FlashSave
  56          Bool CheckFlashEDIDData(void)
  57          {
  58   1              if(DDC1[0]==0x00&&DDC1[1]==0xFF&&DDC1[2]==0xFF&&DDC1[3]==0xFF&&DDC1[4]==0xFF&&DDC1[5]==0xFF&&DDC1[6]==0xF
             -F&&DDC1[7]==0x00)
  59   1              {
  60   2                      return TRUE;
  61   2              }
  62   1              else
  63   1                      return FALSE;   
  64   1      }
  65          #endif
  66          
  67          #if ((!VGA_Write_EEPROM)&&ENABLE_VGA)
  68          void mStar_VGADDC_Base_Address(void)
  69          {
  70   1      
  71   1             #if CHIP_ID==CHIP_TSUMF
                      msWriteByteMask(REG_0260, 0, BIT2|BIT3);
                      #endif
  74   1      
  75   1              #if (CHIP_ID == CHIP_TSUMC||CHIP_ID == CHIP_TSUMD)
  76   1               msWriteByte( REG_3EEC, 0x11);                                           // EDID Set Base address
  77   1               msWriteByte( REG_3EED, 0x03);
  78   1              #elif (CHIP_ID==CHIP_TSUMF)
                     msWriteByte( REG_3EEC, 0x11);    
                      #endif
  81   1      
  82   1           #if (CHIP_ID == CHIP_TSUMC||CHIP_ID == CHIP_TSUMD) 
  83   1           msWriteByteMask( REG_3EEB, 0x00, 0xF0);
  84   1           #elif (CHIP_ID==CHIP_TSUMF)        
                   msWriteByteMask(REG_3EEB, 0, 0x0F);   // REG_DDC_BANK_75[12:8]: Select EDID sram base address for cpu
             - read/write 
                   #endif
  87   1      }
  88          #endif
  89          #if ((!DVI_Write_EEPROM)&&ENABLE_DVI)
              void mStar_DVIDDC_Base_Address(void)
              {
                      #if CHIP_ID==CHIP_TSUMF
                      msWriteByteMask(REG_0260, 0, BIT2|BIT3);
                      #endif
              
                      #if (CHIP_ID == CHIP_TSUMC||CHIP_ID == CHIP_TSUMD)
                              msWriteByte( REG_3EEC, 0x11);                                           // EDID Set Base address
                              msWriteByte( REG_3EED, 0x03);
                      #elif (CHIP_ID==CHIP_TSUMF)     
                               msWriteByte( REG_3EEC, 0x11);    
                                msWriteByteMask(REG_3EEB, 1, MASKBIT(4:0));
                              msWriteByteMask(REG_3E43, 0, BIT1);
                      #endif
              
                   #if (CHIP_ID == CHIP_TSUMC||CHIP_ID == CHIP_TSUMD)  
                              msWriteByteMask( REG_3EEB, 0x10, 0xF0);
                   #elif (CHIP_ID==CHIP_TSUMF)        
                   msWriteByteMask(REG_3EEB, 0x01, 0x1F);   // REG_DDC_BANK_75[12:8]: Select EDID sram base address for 
             -cpu read/write         
                   #endif
              }
              #endif
C51 COMPILER V9.01   DDC                                                                   03/09/2023 15:39:12 PAGE 3   

 112          
 113          #if User_DDCTO_FlashSave
 114          void CleanDDCBuff (void)
 115          {
 116   1              BYTE i=0;
 117   1      
 118   1              for(i=0;i<20;i++)
 119   1                      DDC1[i]=0xFF;
 120   1      }
 121          #endif
 122          
 123          //2返回值 :   烧录成功/失败
 124          #define         TryToModDdcFunction     0
 125          
 126          
 127          #if             TryToModDdcFunction
              Bool            Init_AllPort_Ddc_ToE2PROM_Func(const BYTE DdcPort,const BYTE DdcDate[],const WORD DdcCount)
              {
              
                              BYTE dd=0;
                              WORD i=0;
                              Bool Result = FALSE;
                              BYTE  ReadCheckSum=0;
              
                              EnableReadDDCType=DdcPort;      
                              Init_NVRAM_I2C_SCL_Pin();
                              Init_NVRAM_I2C_SDA_Pin();
              
                              hw_ClrDDC_WP();
                              for(i=0; i<DdcCount; i++)
                               {
                                  NVRam_WriteByte(NVRAM_ADDR_EDID+i, DdcDate[i]);
                               }      
                              hw_SetDDC_WP();
                              Delay1ms(2);
                              
                              ReadCheckSum = 0;
              
                               for(i=0; i<DdcCount; i++)
                               {
                                      NVRam_ReadByte(NVRAM_ADDR_EDID+i, &dd);
                                      DDC1[i]=dd;
                                      ReadCheckSum+=DDC1[i];
                               }
              
              
                              if((DDC1[0]==0x00)&&(DDC1[1]==0xFF)&&(DDC1[2]==0xFF)&&(DDC1[3]==0xFF)&&(DDC1[4]==0xFF)
                              &&(DDC1[5]==0xFF)&&(DDC1[6]==0xFF)&&(DDC1[7]==0x00)&&(DDC1[0x7F]==DdcDate[0x7F]))
                              {
                                      if ((ReadCheckSum)==0)
                                      {
                                              Result=TRUE;
                                      }
                              }
              
              
                              EnableReadDDCType=I2C_EEPROM;   
                              Init_NVRAM_I2C_SCL_Pin();
                              Init_NVRAM_I2C_SDA_Pin();
              
                              return Result;
                              
C51 COMPILER V9.01   DDC                                                                   03/09/2023 15:39:12 PAGE 4   

              }
              
              
              #if ENABLE_VGA
              void mStar_VGA_InitDDC(void)
              {
              #if VGA_Write_EEPROM
              
              if (Load_VGAEDID_Flag)
              {
              
                              BYTE ChecKVGADoubleFlag=0;
                              #if User_DDCTO_FlashSave
                                      BYTE EDID_CheckSum=0 ;
                              #endif
                              
                              #if USEFLASH
                              #if User_DDCTO_FlashSave
                                      CleanDDCBuff ();
                                      Flash_Read_Factory_KeySet(FLASH_KEY_DDCA, TRUE, 0, DDCAKEY_SIZE, &DDC1, DDCAKEY_SIZE);
                                      EDID_CheckSum=DDC1[0x7F];
                              #else
                                      #message "VGA DDC Data User Default EDID"
                              #endif
                              #endif
              
                      #if User_DDCTO_FlashSave
                    if (CheckFlashEDIDData())
                      {       
                              ChecKVGADoubleFlag = Init_AllPort_Ddc_ToE2PROM_Func(VGA_EDID,DDC1,128);
                      }
                      else
                      #endif
                      {       
                              ChecKVGADoubleFlag = Init_AllPort_Ddc_ToE2PROM_Func(VGA_EDID,EDID_vga,128);
                      }
              
                              if (ChecKVGADoubleFlag)
                              {
                                      Clr_Load_VGAEDID_Flag();
                              #if USEFLASH
                                      UserPref_EnableFlashSaveBit( bFlashSaveMonitorBit );
                              #else   
                                      NVRam_WriteWord(nvrMonitorAddr(MonitorFlag), MonitorFlags);
                              #endif
                              }
              }
              
              #else
              
                      BYTE i;
              
                      mStar_ClrDDC_WP();
              
                      mStar_VGADDC_Base_Address();
                      
                      #if USEFLASH
                      #if User_DDCTO_FlashSave
                              Flash_Read_Factory_KeySet(FLASH_KEY_DDCA, TRUE, 0, DDCAKEY_SIZE, &DDC1, DDCAKEY_SIZE);
                      #else
                              #message "VGA DDC Data User Default EDID"
                      #endif
C51 COMPILER V9.01   DDC                                                                   03/09/2023 15:39:12 PAGE 5   

                      #else
                      //NVRam_ReadTbl(DDC_ADC_ADDR, DDC1, 128);
                      #endif
                      
                      #if User_DDCTO_FlashSave
                      if(CheckFlashEDIDData())
                      {       
                              for(i = 0; i < 128; i++)
                              {
                                      msWriteByte(REG_3E4B, i);
                                      msWriteByte(REG_3E4C, DDC1[i]);
                                      msWriteByteMask(REG_3E43, BIT5,BIT5);
              
                                      while(msReadByte(REG_3E7B) & BIT5);  
                              }
                      }
                      else
                      #endif
                      {
                              for(i = 0; i < 128; i++)
                              {
                                      msWriteByte(REG_3E4B, i);
                                      msWriteByte(REG_3E4C, EDID_vga[i]);
                                      msWriteByteMask(REG_3E43, BIT5,BIT5);
              
                                      while(msReadByte(REG_3E7B) & BIT5);  
                              }
                      }
                      
                      mStar_SetDDC_WP();
                      
              #endif
              
              }
              #endif
              #if ENABLE_DVI
              void mStar_DVI_InitDDC(void)
              {
              #if DVI_Write_EEPROM
              #if DEBUG_PRINTDATA
              printData("Load_DVIIEDID_FlagAA=%d",Load_DVIIEDID_Flag);    
              #endif          
              
              if (Load_DVIIEDID_Flag)
              {
              
                              BYTE ChecKDVIDoubleFlag=0;
                              #if User_DDCTO_FlashSave
                                      BYTE EDID_CheckSum=0 ;
                              #endif
                              
                              #if USEFLASH
                              #if User_DDCTO_FlashSave
                                      CleanDDCBuff ();
                                      Flash_Read_Factory_KeySet(FLASH_KEY_DDCD, TRUE, 0, DDCDKEY_SIZE, &DDC1, DDCDKEY_SIZE);
                                      EDID_CheckSum=DDC1[0x7F];
                              #else
                                      #message "DVI DDC Data User Default EDID"
                              #endif
                              #endif
              
                      #if User_DDCTO_FlashSave
C51 COMPILER V9.01   DDC                                                                   03/09/2023 15:39:12 PAGE 6   

                    if (CheckFlashEDIDData())
                      {       
                              ChecKDVIDoubleFlag = Init_AllPort_Ddc_ToE2PROM_Func(DVI_EDID,DDC1,128);
                      }
                      else
                      #endif
                      {       
                              ChecKDVIDoubleFlag = Init_AllPort_Ddc_ToE2PROM_Func(DVI_EDID,EDID_dvi,128);
                      }
              
                              if (ChecKDVIDoubleFlag)
                              {
                                      Clr_Load_DVIEDID_Flag();
                              #if USEFLASH
                                      UserPref_EnableFlashSaveBit( bFlashSaveMonitorBit );
                              #else   
                                      NVRam_WriteWord(nvrMonitorAddr(MonitorFlag), MonitorFlags);
                              #endif
                              }
              }
              #else
              
                      BYTE i;
              
                      mStar_ClrDDC_WP();
              
                      mStar_DVIDDC_Base_Address();
                      
                      #if USEFLASH
                      #if User_DDCTO_FlashSave
                              Flash_Read_Factory_KeySet(FLASH_KEY_DDCD, TRUE, 0, DDCDKEY_SIZE, &DDC1, DDCDKEY_SIZE);
                      #else
                              #message "DVI DDC Data User Default EDID"
                      #endif
                      #else
                      //NVRam_ReadTbl(DDC_ADC_ADDR, DDC1, 128);
                      #endif
                      
                      #if User_DDCTO_FlashSave
                      if(CheckFlashEDIDData())
                      {       
                              for(i = 0; i < 128; i++)
                              {
                                      msWriteByte(REG_3E4B, i);
                                      msWriteByte(REG_3E4C, DDC1[i]);
                                      msWriteByteMask(REG_3E43, BIT5,BIT5);
                              }
                      }
                      else
                      #endif
                      {
                              for(i = 0; i < 128; i++)
                              {
                                      msWriteByte(REG_3E4B, i);
                                      msWriteByte(REG_3E4C, EDID_dvi[i]);
                                      msWriteByteMask(REG_3E43, BIT5,BIT5);
                              }
                      }
                      
                      Delay1ms(100);
                      mStar_SetDDC_WP(void)();
                      
C51 COMPILER V9.01   DDC                                                                   03/09/2023 15:39:12 PAGE 7   

              #endif
              }
              #endif
              #if ENABLE_HDMI
              void mStar_HDMI_InitDDC(void)
              {
              #if HDMI_Write_EEPROM
                      if (Load_HDMIEDID_Flag)
                      {
              
                              BYTE ChecKHDMIDoubleFlag=0;
                              #if User_DDCTO_FlashSave
                                      BYTE EDID_CheckSum=0 ;
                              #endif
                              
                              #if USEFLASH
                              #if User_DDCTO_FlashSave
                                      CleanDDCBuff ();
                                      Flash_Read_Factory_KeySet(FLASH_KEY_DDCH, TRUE, 0, DDCHKEY_SIZE, &DDC1, DDCHKEY_SIZE);
                                      EDID_CheckSum=DDC1[0x7F];
                              #else
                                      #message "HDMI DDC Data User Default EDID"
                              #endif
                              #endif
              
                      #if User_DDCTO_FlashSave
                    if (CheckFlashEDIDData())
                      {       
                              ChecKHDMIDoubleFlag = Init_AllPort_Ddc_ToE2PROM_Func(HDMI_EDID,DDC1,256);
                      }
                      else
                      #endif
                      {       
                              ChecKHDMIDoubleFlag = Init_AllPort_Ddc_ToE2PROM_Func(HDMI_EDID,EDID_hdmi,256);
                      }
              
                              if (ChecKHDMIDoubleFlag)
                              {
                                      Clr_Load_HDMIEDID_Flag();
                              #if USEFLASH
                                      UserPref_EnableFlashSaveBit( bFlashSaveMonitorBit );
                              #else   
                                      NVRam_WriteWord(nvrMonitorAddr(MonitorFlag), MonitorFlags);
                              #endif
                              }
              }
              #endif          
              #if CHIP_ID==CHIP_TSUMF
              DDC_Port_Sel();
              #endif
              
              }
              #endif
              #if ENABLE_HDMI2
              void mStar_HDMI2_InitDDC(void)
              {
              #if HDMI2_Write_EEPROM
                      if (Load_HDMI2EDID_Flag)
                      {
              
                              BYTE ChecKHDMIDoubleFlag=0;
                              #if User_DDCTO_FlashSave
C51 COMPILER V9.01   DDC                                                                   03/09/2023 15:39:12 PAGE 8   

                                      BYTE EDID_CheckSum=0 ;
                              #endif
                              
                              #if USEFLASH
                              #if User_DDCTO_FlashSave
                                      CleanDDCBuff ();
                                      Flash_Read_Factory_KeySet(FLASH_KEY_DDCH, TRUE, 0, DDCHKEY_SIZE, &DDC1, DDCHKEY_SIZE);
                                      EDID_CheckSum=DDC1[0x7F];
                              #else
                                      #message "HDMI2 DDC Data User Default EDID"
                              #endif
                              #endif
              
                      #if User_DDCTO_FlashSave
                    if (CheckFlashEDIDData())
                      {       
                              ChecKHDMIDoubleFlag = Init_AllPort_Ddc_ToE2PROM_Func(HDMI2_EDID,DDC1,256);
                      }
                      else
                      #endif
                      {       
                              ChecKHDMIDoubleFlag = Init_AllPort_Ddc_ToE2PROM_Func(HDMI2_EDID,EDID_hdmi2,256);
                      }
              
                              if (ChecKHDMIDoubleFlag)
                              {
                                      Clr_Load_HDMI2EDID_Flag();
                              #if USEFLASH
                                      UserPref_EnableFlashSaveBit( bFlashSaveMonitorBit );
                              #else   
                                      NVRam_WriteWord(nvrMonitorAddr(MonitorFlag), MonitorFlags);
                              #endif
                              }
              }
              #endif          
              }
              #endif
              
              
              #else
 462          
 463          
 464          
 465          #if ENABLE_VGA
 466          void mStar_VGA_InitDDC(void)
 467          {
 468   1      #if VGA_Write_EEPROM
              
              if (Load_VGAEDID_Flag)
              {
                      BYTE i;
                      BYTE  ReadCheckSum=0;
                      BYTE  dd=0;
                      BYTE CheckVGADoubleFlag=0;
                      #if User_DDCTO_FlashSave
                      BYTE EDID_CheckSum=0 ;
                      #endif
                      
                      #if USEFLASH
                      #if User_DDCTO_FlashSave
                              CleanDDCBuff ();
                              Flash_Read_Factory_KeySet(FLASH_KEY_DDCA, TRUE, 0, DDCAKEY_SIZE, &DDC1, DDCAKEY_SIZE);
C51 COMPILER V9.01   DDC                                                                   03/09/2023 15:39:12 PAGE 9   

                              EDID_CheckSum=DDC1[0x7F];
                      #else
                              #message "VGA DDC Data User Default EDID"
                      #endif
                      #else
                              //NVRam_ReadTbl(DDC_ADC_ADDR, DDC1, 128);
                      #endif
              
              #if 1
              #if User_DDCTO_FlashSave
                   if (CheckFlashEDIDData())
                      {
                              hw_ClrDDC_WP();
                                      
                              Delay1ms(2);
                              
                              EnableReadDDCType=VGA_EDID;
                              Init_NVRAM_I2C_SCL_Pin();
                              Init_NVRAM_I2C_SDA_Pin();
              
                              for(i=0; i<128; i++)
                               {
                                  NVRam_WriteByte(NVRAM_ADDR_EDID+i, DDC1[i]);
                               }      
              
                              hw_SetDDC_WP();
                              
                              Delay1ms(2);
              
                              for (i=0; i<128; i++)
                              {
                                      DDC1[i]=0xFF;
                              }
              
                              for(i=0; i<128; i++)
                               {
                                      NVRam_ReadByte(NVRAM_ADDR_EDID+i, &dd);
                                      DDC1[i]=dd;       
                                      ReadCheckSum+=DDC1[i];
                               }      
              
                              if((DDC1[0]==0x00)&&(DDC1[1]==0xFF)&&(DDC1[2]==0xFF)&&(DDC1[3]==0xFF)&&(DDC1[4]==0xFF)
                              &&(DDC1[5]==0xFF)&&(DDC1[6]==0xFF)&&(DDC1[7]==0x00)&&(DDC1[0x7F]==EDID_CheckSum))
                              {
                                      if ((ReadCheckSum)==0&&((DDC1[0x14]&0x80)!=0x80))
                                      {
                                              CheckVGADoubleFlag=1;
                                      }
                              }
              
                              if (CheckVGADoubleFlag)
                              {
                                      Clr_Load_VGAEDID_Flag();
                              #if USEFLASH
                                      UserPref_EnableFlashSaveBit( bFlashSaveMonitorBit );
                              #else   
                                      NVRam_WriteWord(nvrMonitorAddr(MonitorFlag), MonitorFlags);
                              #endif
                              }
                              
                      }
                      else
C51 COMPILER V9.01   DDC                                                                   03/09/2023 15:39:12 PAGE 10  

                      #endif
                      {
                              hw_ClrDDC_WP();
                                      
                              Delay1ms(5);
                              
                              EnableReadDDCType=VGA_EDID;
                              Init_NVRAM_I2C_SCL_Pin();
                              Init_NVRAM_I2C_SDA_Pin();
              
                              for(i=0; i<128; i++)
                               {
                                  NVRam_WriteByte(NVRAM_ADDR_EDID+i, EDID_vga[i]);
                               }      
              
                              hw_SetDDC_WP();
                              
                              Delay1ms(5);
              
                              for(i=0; i<128; i++)
                               {
                                      NVRam_ReadByte(NVRAM_ADDR_EDID+i, &dd);
                                      DDC1[i]=dd;       
                                      ReadCheckSum+=DDC1[i];
                                    // printMsg("11111111111111");
                                      //  printData("DDC1[i]====%x",DDC1[i]);   
                                      
                               }      
                            // printData("ReadCheckSum", ReadCheckSum);
                                         
                              if((DDC1[0]==0x00)&&(DDC1[1]==0xFF)&&(DDC1[2]==0xFF)&&(DDC1[3]==0xFF)&&(DDC1[4]==0xFF)
                              &&(DDC1[5]==0xFF)&&(DDC1[6]==0xFF)&&(DDC1[7]==0x00)&&(DDC1[0x7F]==EDID_vga[0x7F]))
                              {
                                      if ((ReadCheckSum)==0&&((DDC1[0x14]&0x80)!=0x80))
                                      {
                                              CheckVGADoubleFlag=1;
                                      }
                              }
                      //printData("CheckVGADoubleFlag====%d",CheckVGADoubleFlag);
                              if (CheckVGADoubleFlag)
                              {
                                      Clr_Load_VGAEDID_Flag();
                              #if USEFLASH
                                      UserPref_EnableFlashSaveBit( bFlashSaveMonitorBit );
                              #else   
                                      NVRam_WriteWord(nvrMonitorAddr(MonitorFlag), MonitorFlags);
                              #endif
                              }
                              EnableReadDDCType=I2C_EEPROM;   
                              Init_NVRAM_I2C_SCL_Pin();
                              Init_NVRAM_I2C_SDA_Pin();
                      }
              #endif  
              }
              
              #else
 602   1      
 603   1              BYTE i;
 604   1      
 605   1              mStar_ClrDDC_WP();
 606   1      
 607   1              mStar_VGADDC_Base_Address();
C51 COMPILER V9.01   DDC                                                                   03/09/2023 15:39:12 PAGE 11  

 608   1              
 609   1              #if USEFLASH
 610   1              #if User_DDCTO_FlashSave
 611   1                      Flash_Read_Factory_KeySet(FLASH_KEY_DDCA, TRUE, 0, DDCAKEY_SIZE, &DDC1, DDCAKEY_SIZE);
 612   1                      #message "VGA DDC Data User Default EDID and Flash EDID"
*** MESSAGE C320 IN LINE 612 OF ..\..\KERNEL\SCALER\DDC.c: "VGA DDC Data User Default EDID and Flash EDID"
 613   1              #else
                              #message "VGA DDC Data User Default EDID"
                      #endif
 616   1              #else
                      //NVRam_ReadTbl(DDC_ADC_ADDR, DDC1, 128);
                      #endif
 619   1              
 620   1              #if User_DDCTO_FlashSave
 621   1              if(CheckFlashEDIDData())
 622   1              {       
 623   2                      for(i = 0; i < 128; i++)
 624   2                      {
 625   3                              msWriteByte(REG_3E4B, i);
 626   3                              msWriteByte(REG_3E4C, DDC1[i]);
 627   3                              msWriteByteMask(REG_3E43, BIT5,BIT5);
 628   3      
 629   3                              while(msReadByte(REG_3E7B) & BIT5);  
 630   3                      }
 631   2              }
 632   1              else
 633   1              #endif
 634   1              {
 635   2                      for(i = 0; i < 128; i++)
 636   2                      {
 637   3                              msWriteByte(REG_3E4B, i);
 638   3                              msWriteByte(REG_3E4C, EDID_vga[i]);
 639   3                              msWriteByteMask(REG_3E43, BIT5,BIT5);
 640   3      
 641   3                              while(msReadByte(REG_3E7B) & BIT5);  
 642   3                      }
 643   2              }
 644   1              
 645   1              mStar_SetDDC_WP();
 646   1              
 647   1      #endif
 648   1      
 649   1      }
 650          #endif
 651          #if ENABLE_DVI
              void mStar_DVI_InitDDC(void)
              {
              #if DVI_Write_EEPROM
              #if DEBUG_PRINTDATA
              printData("Load_DVIIEDID_FlagAA=%d",Load_DVIIEDID_Flag);    
              #endif          
              
              if (Load_DVIIEDID_Flag)
              {
              
                      BYTE i;
                      BYTE  ReadCheckSum=0;
                      BYTE  dd=0;
                      BYTE CheckDVIDoubleFlag=0;
                      #if User_DDCTO_FlashSave
                      BYTE EDID_CheckSum=0 ;
                      #endif
C51 COMPILER V9.01   DDC                                                                   03/09/2023 15:39:12 PAGE 12  

                      #if USEFLASH
                      #if User_DDCTO_FlashSave
                              CleanDDCBuff ();
                              Flash_Read_Factory_KeySet(FLASH_KEY_DDCD, TRUE, 0, DDCDKEY_SIZE, &DDC1, DDCDKEY_SIZE);
                              EDID_CheckSum=DDC1[0x7F];
                      #else
                              #message "DVI DDC Data User Default EDID"
                      #endif
                      #else
                              //NVRam_ReadTbl(DDC_ADC_ADDR, DDC1, 128);
                      #endif
                      
              #if User_DDCTO_FlashSave
                   if (CheckFlashEDIDData())
                      {
                              #if ENABLE_DEBUG
                              printMsg("DVI0000000");
                              #endif
                              
                              hw_ClrDDC_WP();
                                      
                              Delay1ms(10);
                              
                              EnableReadDDCType=DVI_EDID;
                              Init_NVRAM_I2C_SCL_Pin();
                              Init_NVRAM_I2C_SDA_Pin();
              
                              for(i=0; i<128; i++)
                               {
                                  NVRam_WriteByte(NVRAM_ADDR_EDID+i, DDC1[i]);
                               }      
              
                              Delay1ms(100);
              
                              hw_SetDDC_WP();
                              
                              Delay1ms(2);
              
                              for (i=0; i<128; i++)
                              {
                                      DDC1[i]=0xFF;
                              }
              
                              for(i=0; i<128; i++)
                               {
                                      NVRam_ReadByte(NVRAM_ADDR_EDID+i, &dd);
                                      DDC1[i]=dd;       
                                      ReadCheckSum+=DDC1[i];
                               }      
              
                              
                              Delay1ms(100);
                              if((DDC1[0]==0x00)&&(DDC1[1]==0xFF)&&(DDC1[2]==0xFF)&&(DDC1[3]==0xFF)&&(DDC1[4]==0xFF)
                              &&(DDC1[5]==0xFF)&&(DDC1[6]==0xFF)&&(DDC1[7]==0x00)&&(DDC1[0x7F]==EDID_CheckSum))
                              {
                                                      #if ENABLE_DEBUG
                              printMsg("DVI1111111");
                              #endif
              
                                      if ((ReadCheckSum)==0&&((DDC1[0x14]&0x80)==0x80))
                                      {
                                              CheckDVIDoubleFlag=1;
C51 COMPILER V9.01   DDC                                                                   03/09/2023 15:39:12 PAGE 13  

                                      }
                              }
              
                              if (CheckDVIDoubleFlag)
                              {
                                      Clr_Load_DVIEDID_Flag();
                              #if USEFLASH
                                      UserPref_EnableFlashSaveBit( bFlashSaveMonitorBit );
                              #else   
                                      NVRam_WriteWord(nvrMonitorAddr(MonitorFlag), MonitorFlags);
                              #endif
                              }
                              EnableReadDDCType=I2C_EEPROM;
              
                                      Init_NVRAM_I2C_SCL_Pin();
                                      Init_NVRAM_I2C_SDA_Pin();
                              
                      }
                      else
                      #endif
                      {
                              #if ENABLE_DEBUG
                              printMsg("DVI  EDID  INIT");
                              #endif
                              hw_ClrDDC_WP();
                                      
                              Delay1ms(5);
                              
                              EnableReadDDCType=DVI_EDID;
                              Init_NVRAM_I2C_SCL_Pin();
                              Init_NVRAM_I2C_SDA_Pin();
              
                              for(i=0; i<128; i++)
                               {
                                  NVRam_WriteByte(NVRAM_ADDR_EDID+i, EDID_dvi[i]);
                               }      
                              Delay1ms(100);
              
                              hw_SetDDC_WP();
                              
                              Delay1ms(5);
              
                              for(i=0; i<128; i++)
                               {
                                      NVRam_ReadByte(NVRAM_ADDR_EDID+i, &dd);
                                      DDC1[i]=dd;       
                                      ReadCheckSum+=DDC1[i];
                               }      
              
                              if((DDC1[0]==0x00)&&(DDC1[1]==0xFF)&&(DDC1[2]==0xFF)&&(DDC1[3]==0xFF)&&(DDC1[4]==0xFF)
                              &&(DDC1[5]==0xFF)&&(DDC1[6]==0xFF)&&(DDC1[7]==0x00)&&(DDC1[0x7F]==EDID_dvi[0x7F]))
                              {
                                      if ((ReadCheckSum)==0&&((DDC1[0x14]&0x80)==0x80))
                                      {
                                              CheckDVIDoubleFlag=1;
                                      }
                              }
              
                              if (CheckDVIDoubleFlag)
                              {
                                      Clr_Load_DVIEDID_Flag();
                              #if USEFLASH
C51 COMPILER V9.01   DDC                                                                   03/09/2023 15:39:12 PAGE 14  

                                      UserPref_EnableFlashSaveBit( bFlashSaveMonitorBit );
                              #else   
                                      NVRam_WriteWord(nvrMonitorAddr(MonitorFlag), MonitorFlags);
                              #endif
                              #if ENABLE_DEBUG
                              printMsg("DVI  EDID  PASS");
                              #endif
                              }
                              EnableReadDDCType=I2C_EEPROM;   
              
                                      Init_NVRAM_I2C_SCL_Pin();
                                      Init_NVRAM_I2C_SDA_Pin();
                      }
              }
              #else
              
                      BYTE i;
              
                      mStar_ClrDDC_WP();
              
                      mStar_DVIDDC_Base_Address();
                      
                      #if USEFLASH
                      #if User_DDCTO_FlashSave
                              Flash_Read_Factory_KeySet(FLASH_KEY_DDCD, TRUE, 0, DDCDKEY_SIZE, &DDC1, DDCDKEY_SIZE);
                      #else
                              #message "DVI DDC Data User Default EDID"
                      #endif
                      #else
                      //NVRam_ReadTbl(DDC_ADC_ADDR, DDC1, 128);
                      #endif
                      
                      #if User_DDCTO_FlashSave
                      if(CheckFlashEDIDData())
                      {       
                              for(i = 0; i < 128; i++)
                              {
                                      msWriteByte(REG_3E4B, i);
                                      msWriteByte(REG_3E4C, DDC1[i]);
                                      msWriteByteMask(REG_3E43, BIT5,BIT5);
                              }
                      }
                      else
                      #endif
                      {
                              for(i = 0; i < 128; i++)
                              {
                                      msWriteByte(REG_3E4B, i);
                                      msWriteByte(REG_3E4C, EDID_dvi[i]);
                                      msWriteByteMask(REG_3E43, BIT5,BIT5);
                              }
                      }
                      
                  Delay1ms(100);
                      mStar_SetDDC_WP();
                      
              #endif
              }
              #endif
 852          #if ENABLE_HDMI
 853          void mStar_HDMI_InitDDC(void)
 854          {
C51 COMPILER V9.01   DDC                                                                   03/09/2023 15:39:12 PAGE 15  

 855   1      #if HDMI_Write_EEPROM
 856   1              if (Load_HDMIEDID_Flag)
 857   1              {
 858   2                      WORD i;
 859   2                      BYTE  ReadCheckSum=0;
 860   2                      BYTE  dd=0;
 861   2                      BYTE ChecKHDMIDoubleFlag=0;
 862   2                      #if User_DDCTO_FlashSave
 863   2                              BYTE EDID_CheckSum=0 ;
 864   2                      #endif
 865   2                      
 866   2                      #if USEFLASH
 867   2                      #if User_DDCTO_FlashSave
 868   2                              CleanDDCBuff ();
 869   2                              #if 0//ENABLE_HDMI2
                                      Flash_Read_Factory_KeySet(FLASH_KEY_DDCD, TRUE, 0, DDCHKEY_SIZE, &DDC1, DDCHKEY_SIZE);
                                      #else
 872   2                              Flash_Read_Factory_KeySet(FLASH_KEY_DDCH, TRUE, 0, DDCHKEY_SIZE, &DDC1, DDCHKEY_SIZE);
 873   2                              #endif
 874   2                              EDID_CheckSum=DDC1[0x7F];
 875   2                              #message "HDMI DDC Data User Default EDID and Flash EDID"
*** MESSAGE C320 IN LINE 875 OF ..\..\KERNEL\SCALER\DDC.c: "HDMI DDC Data User Default EDID and Flash EDID"
 876   2                      #else
                                      #message "HDMI DDC Data User Default EDID"
                              #endif
 879   2                      #else
                                      //NVRam_ReadTbl(DDC_ADC_ADDR, DDC1, 128);
                              #endif
 882   2      
 883   2      #if User_DDCTO_FlashSave
 884   2           if (CheckFlashEDIDData())
 885   2              {
 886   3                      hw_ClrDDC_WP();
 887   3                              
 888   3                      Delay1ms(2);
 889   3                      
 890   3                      EnableReadDDCType=HDMI_EDID;
 891   3                      Init_NVRAM_I2C_SCL_Pin();
 892   3                      Init_NVRAM_I2C_SDA_Pin();
 893   3      
 894   3                      for(i=0; i<256; i++)
 895   3                       {
 896   4                          NVRam_WriteByte(NVRAM_ADDR_EDID+i, DDC1[i]);
 897   4                       }      
 898   3                      Delay1ms(100);
 899   3      
 900   3                      hw_SetDDC_WP();
 901   3                      
 902   3                      Delay1ms(2);
 903   3      
 904   3                      for (i=0; i<256; i++)
 905   3                      {
 906   4                              DDC1[i]=0xFF;
 907   4                      }
 908   3      
 909   3                      for(i=0; i<256; i++)
 910   3                       {
 911   4                              NVRam_ReadByte(NVRAM_ADDR_EDID+i, &dd);
 912   4                              DDC1[i]=dd;       
 913   4                              ReadCheckSum+=DDC1[i];
 914   4                       }      
 915   3      
C51 COMPILER V9.01   DDC                                                                   03/09/2023 15:39:12 PAGE 16  

 916   3                      if((DDC1[0]==0x00)&&(DDC1[1]==0xFF)&&(DDC1[2]==0xFF)&&(DDC1[3]==0xFF)&&(DDC1[4]==0xFF)
 917   3                      &&(DDC1[5]==0xFF)&&(DDC1[6]==0xFF)&&(DDC1[7]==0x00)&&(DDC1[0x7F]==EDID_CheckSum))
 918   3                      {
 919   4                              if ((ReadCheckSum)==0&&((DDC1[0x14]&0x80)==0x80))
 920   4                              {
 921   5                                      ChecKHDMIDoubleFlag=1;
 922   5                              }
 923   4                      }
 924   3      
 925   3                      if (ChecKHDMIDoubleFlag)
 926   3                      {
 927   4                              Clr_Load_HDMIEDID_Flag();
 928   4                      #if USEFLASH
 929   4                              UserPref_EnableFlashSaveBit( bFlashSaveMonitorBit );
 930   4                      #else   
                                      NVRam_WriteWord(nvrMonitorAddr(MonitorFlag), MonitorFlags);
                              #endif
 933   4                      }
 934   3      
 935   3                      
 936   3                      EnableReadDDCType=I2C_EEPROM;
 937   3      
 938   3                              Init_NVRAM_I2C_SCL_Pin();
 939   3                              Init_NVRAM_I2C_SDA_Pin();
 940   3                      
 941   3              }
 942   2              else
 943   2              #endif
 944   2              {
 945   3                      hw_ClrDDC_WP();
 946   3                              
 947   3                      Delay1ms(2);
 948   3                      
 949   3                      EnableReadDDCType=HDMI_EDID;
 950   3                      Init_NVRAM_I2C_SCL_Pin();
 951   3                      Init_NVRAM_I2C_SDA_Pin();
 952   3      
 953   3                      for(i=0; i<256; i++)
 954   3                       {
 955   4                          NVRam_WriteByte(NVRAM_ADDR_EDID+i, EDID_hdmi[i]);
 956   4                       }      
 957   3                      Delay1ms(100);
 958   3      
 959   3                      hw_SetDDC_WP();
 960   3                      
 961   3                      Delay1ms(2);
 962   3      
 963   3                      for(i=0; i<256; i++)
 964   3                       {
 965   4                              NVRam_ReadByte(NVRAM_ADDR_EDID+i, &dd);
 966   4                              DDC1[i]=dd;       
 967   4                              ReadCheckSum+=DDC1[i];
 968   4                       }      
 969   3      
 970   3                      if((DDC1[0]==0x00)&&(DDC1[1]==0xFF)&&(DDC1[2]==0xFF)&&(DDC1[3]==0xFF)&&(DDC1[4]==0xFF)
 971   3                      &&(DDC1[5]==0xFF)&&(DDC1[6]==0xFF)&&(DDC1[7]==0x00)&&(DDC1[0x7F]==EDID_hdmi[0x7F]))
 972   3                      {
 973   4                              if ((ReadCheckSum)==0&&((DDC1[0x14]&0x80)==0x80))
 974   4                              {
 975   5                                      ChecKHDMIDoubleFlag=1;
 976   5                              }
 977   4                      }
C51 COMPILER V9.01   DDC                                                                   03/09/2023 15:39:12 PAGE 17  

 978   3      
 979   3                      if (ChecKHDMIDoubleFlag)
 980   3                      {
 981   4                              Clr_Load_HDMIEDID_Flag();
 982   4                      #if USEFLASH
 983   4                              UserPref_EnableFlashSaveBit( bFlashSaveMonitorBit );
 984   4                      #else   
                                      NVRam_WriteWord(nvrMonitorAddr(MonitorFlag), MonitorFlags);
                              #endif
 987   4                      }
 988   3                      EnableReadDDCType=I2C_EEPROM;   
 989   3                      Init_NVRAM_I2C_SCL_Pin();
 990   3                      Init_NVRAM_I2C_SDA_Pin();
 991   3              }
 992   2      }
 993   1      #endif          
 994   1      #if CHIP_ID==CHIP_TSUMF
              DDC_Port_Sel();
              #endif
 997   1      
 998   1      }
 999          #endif
1000          
1001          #if ENABLE_HDMI2
              void mStar_HDMI2_InitDDC(void)
              {
              #if HDMI2_Write_EEPROM
              
                      if (Load_HDMI2EDID_Flag)
                      {
                              WORD i;
                              BYTE  ReadCheckSum=0;
                              BYTE  dd=0;
                              bit ChecKHDMIDoubleFlag=0;
                              #if User_DDCTO_FlashSave
                                      BYTE EDID_CheckSum=0 ;
                              #endif
                              
                              #if USEFLASH
                              #if User_DDCTO_FlashSave
                                      CleanDDCBuff ();
                                      Flash_Read_Factory_KeySet(FLASH_KEY_DDCH, TRUE, 0, DDCHKEY_SIZE, &DDC1, DDCHKEY_SIZE);
                                      EDID_CheckSum=DDC1[0x7F];
                              #else
                                      #message "HDMI2 DDC Data User Default EDID"
                              #endif
                              #else
                                      //NVRam_ReadTbl(DDC_ADC_ADDR, DDC1, 128);
                              #endif
              
              #if User_DDCTO_FlashSave
                   if (CheckFlashEDIDData())
                      {
                              hw_ClrDDC_WP();
                                      
                              Delay1ms(2);
                              
                              EnableReadDDCType=HDMI2_EDID;
              
                              for(i=0; i<256; i++)
                               {
                                  NVRam_WriteByte(NVRAM_ADDR_EDID+i, DDC1[i]);
C51 COMPILER V9.01   DDC                                                                   03/09/2023 15:39:12 PAGE 18  

                               }      
              
                              hw_SetDDC_WP();
                              
                              Delay1ms(2);
              
                              for (i=0; i<256; i++)
                              {
                                      DDC1[i]=0xFF;
                              }
              
                              for(i=0; i<256; i++)
                               {
                                      NVRam_ReadByte(NVRAM_ADDR_EDID+i, &dd);
                                      DDC1[i]=dd;       
                                      ReadCheckSum+=DDC1[i];
                               }      
              
                              if((DDC1[0]==0x00)&&(DDC1[1]==0xFF)&&(DDC1[2]==0xFF)&&(DDC1[3]==0xFF)&&(DDC1[4]==0xFF)
                              &&(DDC1[5]==0xFF)&&(DDC1[6]==0xFF)&&(DDC1[7]==0x00)&&(DDC1[0x7F]==EDID_CheckSum))
                              {
                                      if ((ReadCheckSum)==0&&((DDC1[0x14]&0x80)==0x80))
                                      {
                                              ChecKHDMIDoubleFlag=1;
                                      }
                              }
              
                              if (ChecKHDMIDoubleFlag)
                              {
                                      Clr_Load_HDMI2EDID_Flag();
                              #if USEFLASH
                                      UserPref_EnableFlashSaveBit( bFlashSaveMonitorBit );
                              #else   
                                      NVRam_WriteWord(nvrMonitorAddr(MonitorFlag), MonitorFlags);
                              #endif
                              }
              
                              
                              EnableReadDDCType=I2C_EEPROM;
              
                                      Init_NVRAM_I2C_SCL_Pin();
                                      Init_NVRAM_I2C_SDA_Pin();
                              
                      }
                      else
                      #endif
                      {
                              hw_ClrDDC_WP();
                                      
                              Delay1ms(2);
                              
                              EnableReadDDCType=HDMI2_EDID;
              
                              for(i=0; i<256; i++)
                               {
                                  NVRam_WriteByte(NVRAM_ADDR_EDID+i, EDID_hdmi2[i]);
                               }      
              
                              hw_SetDDC_WP();
                              
                              Delay1ms(2);
              
C51 COMPILER V9.01   DDC                                                                   03/09/2023 15:39:12 PAGE 19  

                              for(i=0; i<256; i++)
                               {
                                      NVRam_ReadByte(NVRAM_ADDR_EDID+i, &dd);
                                      DDC1[i]=dd;       
                                      ReadCheckSum+=DDC1[i];
                               }      
              
                              if((DDC1[0]==0x00)&&(DDC1[1]==0xFF)&&(DDC1[2]==0xFF)&&(DDC1[3]==0xFF)&&(DDC1[4]==0xFF)
                              &&(DDC1[5]==0xFF)&&(DDC1[6]==0xFF)&&(DDC1[7]==0x00)&&(DDC1[0x7F]==EDID_hdmi[0x7F]))
                              {
                                      if ((ReadCheckSum)==0&&((DDC1[0x14]&0x80)==0x80))
                                      {
                                              ChecKHDMIDoubleFlag=1;
                                      }
                              }
              
                              if (ChecKHDMIDoubleFlag)
                              {
                                      Clr_Load_HDMI2EDID_Flag();
                              #if USEFLASH
                                      UserPref_EnableFlashSaveBit( bFlashSaveMonitorBit );
                              #else   
                                      NVRam_WriteWord(nvrMonitorAddr(MonitorFlag), MonitorFlags);
                              #endif
                              }
                              EnableReadDDCType=I2C_EEPROM;   
              
                                      Init_NVRAM_I2C_SCL_Pin();
                                      Init_NVRAM_I2C_SDA_Pin();
                      }
              }
              #endif          
              }
              #endif
1136          
1137          #endif
1138          
1139          void mStar_InitDDC(void)
1140          {
1141   1      #if ENABLE_VGA
1142   1              mStar_VGA_InitDDC();
1143   1      #endif
1144   1      
1145   1      #if ENABLE_DVI
                      mStar_DVI_InitDDC();
              #endif
1148   1      
1149   1      #if ENABLE_HDMI
1150   1              mStar_HDMI_InitDDC();
1151   1      #endif
1152   1      
1153   1      #if ENABLE_HDMI2
                      mStar_HDMI2_InitDDC();
              #endif
1156   1      }
1157          
1158          /*********************************************************************************************************
             -/
1159          #if WriteSN_Functiom_New
              extern code BYTE EDID[];
              void ReLoadEDIDtoAddSN(void)
              {
C51 COMPILER V9.01   DDC                                                                   03/09/2023 15:39:12 PAGE 20  

              BYTE Week=0x00,Year=0x1C;
              BYTE SNdata[18];
              WORD i;
              BYTE  ReadCheckSum=0;
              BYTE  dd=0;
              
              //2    1  读取EDID    只接受一路
                #if ENABLE_VGA
                           Flash_Read_Factory_KeySet(FLASH_KEY_DDCA, TRUE, 0, DDCAKEY_SIZE, 
              DDC1, DDCAKEY_SIZE);
                #elif ENABLE_DVI
                              Flash_Read_Factory_KeySet(FLASH_KEY_DDCD, TRUE, 0,   DDCDKEY_SIZE, DDC1, 
              DDCDKEY_SIZE);  
                #elif ENABLE_HDMI
                              Flash_Read_Factory_KeySet(FLASH_KEY_DDCH, TRUE, 0,   DDCHKEY_SIZE, 
              DDC1, DDCHKEY_SIZE);    
                #endif
              
              //2  2 截取 SN   (必须在6C -7D 间)
              
              
              //for(i = 0;i<18;i++) SNdata[i] = DDC1[0X5A+i];
              Week = DDC1[0x10];
              Year = DDC1[0x11];  
              for(i = 0;i<14;i++) SNdata[i] = DDC1[0x70+i];
              
              //2  3 拼合SN
              
              #if ENABLE_VGA
              #if VGA_Write_EEPROM
              Set_Load_VGAEDID_Flag();
              #endif
              #endif
              
              #if ENABLE_DVI
              #if !ENABLE_VGA
              Set_Load_DVIEDID_Flag();
              #else
              #if DVI_Write_EEPROM
                    ReadCheckSum = 0;
                      hw_ClrDDC_WP();         
                      Delay1ms(2);
                      EnableReadDDCType=DVI_EDID;
                      NVRam_WriteByte(0x10, Week);
                      NVRam_WriteByte(0x11, Year);
                      for(i=0; i<14; i++)
                       {
                          NVRam_WriteByte(0x70+i, SNdata[i]);
                       }      
                      for(i=0; i<127; i++)
                       {
                              NVRam_ReadByte(i, &dd);
                              ReadCheckSum+=dd;
                       }      
                      NVRam_WriteByte(0x7F, 0x100-ReadCheckSum);
                      hw_SetDDC_WP();
              #else
                      for(i=0; i<128; i++) DDC1[i] = DVI_EDID[i];
                      DDC1[0x10] = Week;
                      DDC1[0x11] = Year ;
                      for(i = 0;i<14;i++)  DDC1[0x70+i] = SNdata[i] ;
                      for(i=0; i<127; i++) ReadCheckSum+=DDC1[i];
C51 COMPILER V9.01   DDC                                                                   03/09/2023 15:39:12 PAGE 21  

                      DDC1[0x7F] = 0x100-ReadCheckSum;
                      Flash_Write_Factory_KeySet(FLASH_KEY_DDCD, FALSE,  DDCHKEY_SIZE, DDC1, 
              DDCDKEY_SIZE);
              #endif
              #endif
              #endif
              
              
              //3   HDMI 一般存放于24C02
              //3(3)  直接操作24C02
              #if ENABLE_HDMI
              #if !ENABLE_VGA&&!ENABLE_DVI
                   Set_Load_HDMIEDID_Flag();
              #else
                     ReadCheckSum = 0;
                      hw_ClrDDC_WP();         
                      Delay1ms(2);
                      EnableReadDDCType=HDMI_EDID;
                      NVRam_WriteByte(0x10, Week);
                      NVRam_WriteByte(0x11, Year);
                      for(i=0; i<14; i++)
                       {
                          NVRam_WriteByte(0x70+i, SNdata[i]);
                       }      
                      for(i=0; i<127; i++)
                       {
                              NVRam_ReadByte(i, &dd);
                              ReadCheckSum+=dd;
                       }      
                      NVRam_WriteByte(0x7F, 0x100-ReadCheckSum);
                      hw_SetDDC_WP();
                      
                      EnableReadDDCType=I2C_EEPROM;   
              #endif  
              #endif
              
              #if ENABLE_HDMI2
                      ReadCheckSum = 0;
                      hw_ClrDDC_WP();         
                      Delay1ms(2);
                      EnableReadDDCType=HDMI2_EDID;
                      NVRam_WriteByte(0x10, Week);
                      NVRam_WriteByte(0x11, Year);
                      for(i=0; i<14; i++)
                       {
                          NVRam_WriteByte(0x70+i, SNdata[i]);
                       }      
                      for(i=0; i<127; i++)
                       {
                              NVRam_ReadByte(i, &dd);
                              ReadCheckSum+=dd;
                       }      
                      NVRam_WriteByte(0x7F, 0x100-ReadCheckSum);
                      hw_SetDDC_WP();
              
                      EnableReadDDCType=I2C_EEPROM;           
                      
              #endif
              
              
              //3 (4)  DP 要回存Flash
              #if ENABLE_DP_INPUT     &&   DP_WRITE_SN
C51 COMPILER V9.01   DDC                                                                   03/09/2023 15:39:12 PAGE 22  

                     ReadCheckSum = 0;
                      for(i=0; i<256; i++) DDC1[i] = EDID[i];
                      DDC1[0x10] = Week;
                      DDC1[0x11] = Year ;
                      for(i = 0;i<14;i++)  DDC1[0x70+i] = SNdata[i] ;
                      for(i=0; i<127; i++) ReadCheckSum+=DDC1[i];
                      DDC1[0x7F] = 0x100-ReadCheckSum;
                      Flash_Write_Factory_KeySet(FLASH_KEY_HDCP, FALSE,  DDCHKEY_SIZE, DDC1, 
              DDCHKEY_SIZE);
              #endif
              
              
              }
              #endif
1301          /*********************************************************************************************************
             -/
1302          
1303          #if FreeSyncSwitchEDID
              //*************************************************
              //Check EDID Support FreeSync or Not
              //If No Support return 0  (HDMI1FreeSyncED&&HDMI2FreeSyncED==0)
              //If Support return 1 HDMI1FreeSyncED&&HDMI2FreeSyncED is the 0xED Addrs  (HDMI1FreeSyncED&&HDMI2FreeSyncE
             -D>=128)
              //*************************************************
              Bool CheckEDIDSupportFreeSync(BYTE Input)
              {
                      BYTE temp;
                      if(Input==HDMI_EDID)
                      {
                      for(temp=0;temp<125;temp++)
                      {
                                      if((EDID_hdmi[128+temp]==0x68)&&(EDID_hdmi[128+temp+1]==0x1A)&&(EDID_hdmi[128+temp+2]==0x00)&&(EDID_hdm
             -i[128+temp+3]==0x00)&&(EDID_hdmi[128+temp+4]==0x01)&&(EDID_hdmi[128+temp+5]==0x01))
                                      {
                                              HDMI1FreeSyncED=temp+8+128;
                                              return 1;
                                      }
                              }
                              if(temp>=124)
                              {
                                      HDMI1FreeSyncED=0;
                                      return 0;
                              }
                      }
              
              #if ENABLE_HDMI2
                      if(Input==HDMI2_EDID)
                      {
              
                      for(temp=0;temp<125;temp++)
                      {
                                      if((EDID_hdmi2[128+temp]==0x68)&&(EDID_hdmi2[128+temp+1]==0x1A)&&(EDID_hdmi2[128+temp+2]==0x00)&&(EDID_
             -hdmi2[128+temp+3]==0x00)&&(EDID_hdmi2[128+temp+4]==0x01)&&(EDID_hdmi2[128+temp+5]==0x01))
                                      {
                                              HDMI2FreeSyncED=temp+8+128;
                                              return 1;
                                      }
                              }
                              if(temp>=124)
                              {
                                      HDMI2FreeSyncED=0;
                                      return 0;
C51 COMPILER V9.01   DDC                                                                   03/09/2023 15:39:12 PAGE 23  

                              }               
              
                      }
                      #endif
                      return 0;
              
              
              }
              //*************************************************
              //通过默认EDID直接返回一个开或关对应的CheckSum
              //如果默认EDID不支持FreeSync 返回 NULL
              //*************************************************
              BYTE GetEDIDCheckSum(BYTE Input, BYTE OnOff)
              {
                      if(Input==HDMI_EDID)
                      {
                              if(CheckEDIDSupportFreeSync(Input))
                              {
                                      if(EDID_hdmi[HDMI1FreeSyncED]==0xED)
                                      {
                                              if(OnOff)
                                              {
                                                      return (EDID_hdmi[0xFF]+0xED);
                                              }
                                              else
                                              {
                                                      return (EDID_hdmi[0xFF]);
                                              }
                                      }
                                      else
                                      {
                                              if(OnOff)
                                              {
                                                      return (EDID_hdmi[0xFF]);
                                              }
                                              else
                                              {
                                                      return (EDID_hdmi[0xFF]-0xED);
                                              }
                                      }
                              }
                              else
                              {
                                      return 0;
                              }
                      }
                      #if ENABLE_HDMI2
                      if(Input==HDMI2_EDID)
                      {
                              if(CheckEDIDSupportFreeSync(Input))
                              {
                                      if(EDID_hdmi2[HDMI2FreeSyncED]==0xED)
                                      {
                                              if(OnOff)
                                              {
                                                      return (EDID_hdmi2[0xFF]+0xED);
                                              }
                                              else
                                              {
                                                      return (EDID_hdmi2[0xFF]);
                                              }
                                      }
C51 COMPILER V9.01   DDC                                                                   03/09/2023 15:39:12 PAGE 24  

                                      else
                                      {
                                              if(OnOff)
                                              {
                                                      return (EDID_hdmi2[0xFF]);
                                              }
                                              else
                                              {
                                                      return (EDID_hdmi2[0xFF]-0xED);
                                              }
                                      }
                              }
                              else
                              {
                                      return 0;
                              }
                      }
                      #endif
              return 0;
              }
              //*************************************************
              //Write Success Return 1
              //Write Fail Or Default EDID NoSupport FreeSync Return 0
              //*************************************************
              Bool  FreeSyncEDIDSwitch(BYTE Input, BYTE OnOff)
              {
                      //BYTE CheckCount;
                      BYTE xdata EDIDCheckSum=GetEDIDCheckSum(Input,OnOff);
              
              
                      #if ENABLE_DEBUG
                      printData("EDIDCheckSum   %d", EDIDCheckSum);
                      #endif
                      
                      if(EDIDCheckSum)
                      {
                              if(Input==HDMI_EDID)
                              {
                                      #if ENABLE_DEBUG
                                      printData("HDMI1FreeSyncED   %d", HDMI1FreeSyncED);
                                      #endif
                                      
                                      EnableReadDDCType = HDMI_EDID;
                                      hw_ClrDDC_WP();
                                      Delay1ms(2);
                                      if(OnOff)
                                      {
              
                                              //i2c_WriteTBL(0xA0, HDMI1FreeSyncED, ,1);      
                                              //i2c_WriteTBL(0xA0, HDMI1FreeSyncED, &ED_0x00, 1);
                                              NVRam_WriteByte(HDMI1FreeSyncED,0x00);
                                              //i2c_WriteTBL(0xA0, 0xFF, &EDIDCheckSum, 1);
                                              NVRam_WriteByte(0xFF,EDIDCheckSum);
                                      }
                                      else
                                      {
                                      #if ENABLE_DEBUG
                                      printMsg("close freesync");
                                      #endif
                                              //i2c_WriteTBL(0xA0, HDMI1FreeSyncED, &ED_0xED, 1);
                                              NVRam_WriteByte(HDMI1FreeSyncED,0xED);
                                              //i2c_WriteTBL(0xA0, 0xFF, &EDIDCheckSum, 1);
C51 COMPILER V9.01   DDC                                                                   03/09/2023 15:39:12 PAGE 25  

                                              NVRam_WriteByte(0xFF,EDIDCheckSum);
                                      }
                                      ForceDelay1ms(30);
                                      hw_SetDDC_WP();
                                      EnableReadDDCType = 0xFF;
                              }
                              #if ENABLE_HDMI2
                              if(Input==HDMI2_EDID)
                              {
                                      EnableReadDDCType = Input;
                                      hw_ClrDDC_WP();
                                      if(OnOff)
                                      {//i2c_WriteTBL;
                                              //i2c_WriteTBL(0xA0, HDMI2FreeSyncED, &ED_0x00, 1);
                                              NVRam_WriteByte(HDMI1FreeSyncED,0x00);
                                              //i2c_WriteTBL(0xA0, 0xFF, &EDIDCheckSum, 1);
                                              NVRam_WriteByte(0xFF,EDIDCheckSum);
                                      }
                                      else
                                      {
                                              //i2c_WriteTBL(0xA0, HDMI2FreeSyncED, &ED_0xED, 1);
                                              NVRam_WriteByte(HDMI1FreeSyncED,0xED);
                                              //i2c_WriteTBL(0xA0, 0xFF, &EDIDCheckSum, 1);
                                              NVRam_WriteByte(0xFF,EDIDCheckSum);
                                      }
                                      ForceDelay1ms(30);
                                      hw_SetDDC_WP();
                                      EnableReadDDCType = 0xFF;
                              }
                              #endif
                                      Init_NVRAM_I2C_SCL_Pin();
                                      Init_NVRAM_I2C_SDA_Pin();
                      }
                      else
                      {
                              return 0;
                      }
              
              //Check Write OK?
                      if(Input==HDMI_EDID)
                      {
                              BYTE xdata FreeSyncED=0;
                              BYTE xdata EDIDCheckSumTemp=0;
                      
                              EnableReadDDCType = Input;
                              NVRam_ReadByte(HDMI1FreeSyncED,&FreeSyncED);
                              NVRam_ReadByte(0xFF,&EDIDCheckSumTemp);
                              ForceDelay1ms(30);      
                                      Init_NVRAM_I2C_SCL_Pin();
                                      Init_NVRAM_I2C_SDA_Pin();
                              EnableReadDDCType = 0xFF;
              
                                                      #if ENABLE_DEBUG
                                      printData("EDIDCheckSumTemp   %d", EDIDCheckSumTemp);
                                      printData("EDIDCheckSum   %d", EDIDCheckSum);
                                      
                                      printData("FreeSyncED   %d", FreeSyncED);
                                      printData("HDMI1FreeSyncED   %d", HDMI1FreeSyncED);
                                      printMsg("====================================");
                                      #endif
                              
                              if(OnOff)
C51 COMPILER V9.01   DDC                                                                   03/09/2023 15:39:12 PAGE 26  

                              {
              
              
                                      if((EDIDCheckSumTemp==EDIDCheckSum)&&(FreeSyncED==0x00))
                                              return 1;
                                      else
                                              return 0;
                              }
                              else
                              {
                                      if((EDIDCheckSumTemp==EDIDCheckSum)&&(FreeSyncED==0xED))
                                              return 1;
                                      else
                                              return 0;
                              }
                      }
                      if(Input==HDMI2_EDID)
                      {
                              BYTE xdata FreeSyncED=0;
                              BYTE xdata EDIDCheckSumTemp=0;
                      
                                      EnableReadDDCType = Input;
                              
                              NVRam_ReadByte(HDMI2FreeSyncED,&FreeSyncED);
                              NVRam_ReadByte(0xFF,&EDIDCheckSumTemp);
                                      
                              ForceDelay1ms(30);      
                                      Init_NVRAM_I2C_SCL_Pin();
                                      Init_NVRAM_I2C_SDA_Pin();
                                      
                              EnableReadDDCType = 0xFF;
                              
                              if(OnOff)
                              {
                                      if((EDIDCheckSumTemp==EDIDCheckSum)&&(FreeSyncED==0x00))
                                              return 1;
                                      else
                                              return 0;
                              }
                              else
                              {
                                      if((EDIDCheckSumTemp==EDIDCheckSum)&&(FreeSyncED==0xED))
                                              return 1;
                                      else
                                              return 0;
                              }
                      }
                      return 0;
              }
              
              #endif
1582          
1583          #if LoadAllPortSeriealnumberByOneVGAPort
1584          
1585          #define SNStrat         0x71//0x4D
1586          
1587          #define HDMISNStrat             0x71//0x4D
1588          
1589          void ReLoadEDIDtoAddSN(void)
1590          {
1591   1      BYTE Week=0x00,Year=0x1C;
1592   1      BYTE SNdata[18] = {0};
C51 COMPILER V9.01   DDC                                                                   03/09/2023 15:39:12 PAGE 27  

1593   1      WORD i;
1594   1      BYTE  ReadCheckSum=0;
1595   1      BYTE  dd=0;
1596   1      
1597   1      //2    1  读取EDID    只接受一路
1598   1        #if ENABLE_VGA
1599   1                   Flash_Read_Factory_KeySet(FLASH_KEY_DDCA, TRUE, 0, DDCAKEY_SIZE, DDC1, DDCAKEY_SIZE);
1600   1        #elif ENABLE_DVI
                              Flash_Read_Factory_KeySet(FLASH_KEY_DDCD, TRUE, 0,   DDCDKEY_SIZE, DDC1, DDCDKEY_SIZE); 
                #elif ENABLE_HDMI
                              Flash_Read_Factory_KeySet(FLASH_KEY_DDCH, TRUE, 0,   DDCHKEY_SIZE, DDC1, DDCHKEY_SIZE); 
                #endif
1605   1      
1606   1      //2  2 截取 SN   (必须在6C -7D 间)
1607   1      
1608   1      
1609   1      //for(i = 0;i<18;i++) SNdata[i] = DDC1[0X5A+i];
1610   1      Week = DDC1[0x10];
1611   1      Year = DDC1[0x11];  
1612   1      for(i = 0;i<13;i++) SNdata[i] = DDC1[SNStrat+i];
1613   1      
1614   1      //2  3 拼合SN
1615   1      
1616   1      #if ENABLE_VGA
1617   1      #if VGA_Write_EEPROM
              //Set_LoadVGAEDIDFlag_A();
              #endif
1620   1      #endif
1621   1      
1622   1      
1623   1      //3   HDMI 一般存放于24C02
1624   1      //3(3)  直接操作24C02
1625   1      #if ENABLE_HDMI
1626   1      #if 0
                   Set_Load_HDMIEDID_Flag();
              #else
1629   1             ReadCheckSum = 0;
1630   1              hw_ClrDDC_WP();         
1631   1              Delay1ms(2);
1632   1              EnableReadDDCType=HDMI_EDID;
1633   1              NVRam_WriteByte(0x10, Week);
1634   1              NVRam_WriteByte(0x11, Year);
1635   1              for(i=0; i<13; i++)
1636   1               {
1637   2                  NVRam_WriteByte(HDMISNStrat+i, SNdata[i]);
1638   2               }      
1639   1              for(i=0; i<127; i++)
1640   1               {
1641   2                      NVRam_ReadByte(i, &dd);
1642   2                      ReadCheckSum+=dd;
1643   2               }      
1644   1              NVRam_WriteByte(0x7F, 0x100-ReadCheckSum);
1645   1              hw_SetDDC_WP();
1646   1              
1647   1              EnableReadDDCType=I2C_EEPROM;
1648   1      #endif  
1649   1      #endif
1650   1      
1651   1      }
1652          #endif
1653          
1654          
C51 COMPILER V9.01   DDC                                                                   03/09/2023 15:39:12 PAGE 28  

1655          #ifdef  UseVGACableReadWriteAllPortsEDID
              extern void NVRAM_i2c_WriteTBL(BYTE deviceID, WORD addr, BYTE *buffer, BYTE count);
              extern void NVRAM_i2c_ReadTBL(BYTE deviceID, WORD addr, BYTE *buffer, BYTE count);
              
              
              #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1349    ----
   CONSTANT SIZE    =    530    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      31
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

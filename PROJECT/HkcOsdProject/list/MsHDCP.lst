C51 COMPILER V9.01   MSHDCP                                                                03/09/2023 15:39:03 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE MSHDCP
OBJECT MODULE PLACED IN .\obj\MsHDCP.obj
COMPILER INVOKED BY: D:\Keil4\C51\BIN\C51.EXE ..\..\KERNEL\SCALER\MsHDCP.c OPTIMIZE(SIZE) BROWSE INCDIR(..\..\DRIVER\INC
                    -;..\..\KERNEL\SCALER\INC;..\..\KERNEL\SYSTEM\INC;..\..\LIB\INC;..\..\PANEL\INC;..\..\BOARD;..\..\DRIVER\INC;..\..\KERNEL
                    -\SYSTEM\INC\AOC2011;..\..\DRIVER\extDEVICE\INC;..\..\MODEL;..\..\CONFIG;..\..\PANEL;..\..\UI\F_LOGO\INC;..\..\UI\HkcOsd\
                    -INC) DEFINE(ModelName=JRY_TESTBOARD_C_BOARD) DEBUG OBJECTEXTEND PRINT(.\list\MsHDCP.lst) OBJECT(.\obj\MsHDCP.obj)

line level    source

   1          #define _MSHDCP_C_
   2           #include "board.h"
   3          #if ENABLE_HDCP
   4              #include "types.h"
   5              #include "ms_reg.h"
   6                  #include "ms_rwreg.h"
   7          #include "Common.h"
   8          #include "misc.h"
   9              #include "global.h"
  10              #include "userpref.h"
  11              #include "debug.h"
  12              #include "msflash.h"
  13          #include "NvRam.h"
  14          // Internal
  15              #include "msHDCP.h"
  16          #if ENABLE_MHL
              //extern xdata MHLInfo_S gMHLInfo;
              #include "DRVMHL.h"
              #endif
  20          #if CHIP_ID >= CHIP_TSUMC
  21          #include "msEread.h"
  22          #endif
  23          #include "GPIO_DEF.h"
  24          #define HDCP_DEBUG 0
  25          #if ENABLE_DEBUG && HDCP_DEBUG
              #define HDCP_printData(str, value)   printData(str, value)
              #define HDCP_printMsg(str)           printMsg(str)
              #else
  29          #define HDCP_printData(str, value)
  30          #define HDCP_printMsg(str)
  31          #endif
  32          
  33          
  34              #if (!Init_HDCPKey)
  35          #message "Please remember to disable the default HDCP key!"
*** MESSAGE C320 IN LINE 35 OF ..\..\KERNEL\SCALER\MsHDCP.c: "Please remember to disable the default HDCP key!"
  36          #else
              #message "Please remember to Õ‚…’KEY!"
              #endif
  39              #if (!Init_HDCPKey)
  40                  BYTE code BKSV[5] = 
  41                  {
  42                      0x89, 0x38, 0xae, 0x0d, 0xed
  43                  };
  44                  //////////////////////////////////////////////////////////////
  45                  // HDCP production key
  46                  //////////////////////////////////////////////////////////////
  47          BYTE code HDCPkey[] =
  48          {
  49              0x00,0xE6,0xD2,0xD0,0xA4,0x0A,0xF9,0xAB,0x2F,0x9A,0x2D,0x3A,
  50              0xB5,0xFF,0x9D,0x37,0xB3,0x63,0x23,0x6E,0xA3,0x4E,0x58,0xEF,
  51              0xD2,0x78,0x6D,0x3B,0xDE,0xFD,0x7E,0x4D,0xAA,0xB6,0x0C,0x59,
C51 COMPILER V9.01   MSHDCP                                                                03/09/2023 15:39:03 PAGE 2   

  52              0x4F,0x74,0x3C,0xF8,0xDA,0x65,0x6E,0x2F,0xB4,0xAB,0xAD,0x7F,
  53              0x89,0xA1,0x92,0x25,0x1A,0xCD,0x50,0x93,0x50,0x00,0x63,0x88,
  54              0x7B,0xD0,0xD8,0x4D,0x46,0x95,0xA8,0xFC,0x9B,0x0D,0xD1,0x08,
  55              0x06,0xB2,0x67,0xBE,0xA2,0x90,0xA7,0x84,0x2A,0x4B,0x28,0xC8,
  56              0xDD,0x8F,0xC9,0x48,0xA3,0x0A,0x7D,0xCA,0xDA,0xBC,0xCE,0xFA,
  57              0x9B,0x9F,0x61,0x90,0x9E,0x46,0x24,0x2B,0xA6,0x7B,0xB1,0x6F,
  58              0xC4,0x4C,0x63,0xAF,0x44,0xE1,0x3A,0xDD,0x0D,0xED,0xF4,0x45,
  59              0x36,0x47,0x0B,0x48,0x0A,0xB1,0xE6,0xE9,0xB6,0xED,0x78,0x37,
  60              0xDC,0xB0,0x07,0x72,0x83,0xDC,0x73,0x26,0x31,0x49,0x03,0x52,
  61              0x7C,0xE6,0xC6,0xE8,0x3C,0xD1,0x62,0xFE,0xF0,0x01,0x73,0x23,
  62              0x90,0x70,0xA9,0x52,0x8C,0x75,0x1C,0xE5,0x63,0x7C,0xA9,0x98,
  63              0x5F,0xD9,0x7C,0x62,0x25,0x6C,0x61,0x6C,0xB5,0xF9,0xDB,0xD8,
  64              0x91,0x2F,0x25,0xF6,0x3E,0x37,0xBE,0xE2,0x92,0x08,0x07,0x3C,
  65              0xE6,0xC9,0xE3,0xB0,0x4D,0xF6,0xAD,0x54,0x3C,0xED,0x92,0x5A,
  66              0x97,0x93,0xC0,0x48,0xEA,0x23,0x6C,0xDD,0x9A,0x00,0xBA,0xF1,
  67              0xB4,0xE7,0x7E,0x84,0x9A,0xB5,0xD5,0xF4,0xB0,0x42,0x49,0x5E,
  68              0x15,0x5A,0x43,0x2D,0xA9,0xB0,0x0A,0x1C,0x75,0xDE,0x2E,0x08,
  69              0xF7,0xDF,0x38,0x03,0xEB,0x6A,0x75,0xEB,0xDA,0x1C,0xA0,0xC9,
  70              0x2F,0x2A,0x69,0x3F,0x13,0xFB,0xA4,0x23,0x0A,0xE5,0x0A,0xA5,
  71              0xEF, 0xCC, 0x8D, 0xB6, 0x5E, 0x6C, 0xB6, 0xE8, 0x84, 0xEF, 0x03, 0xDC,
  72              0xC5, 0x8A, 0xA3, 0x4B, 0xEF, 0x44, 0x12, 0x7F
  73          };
  74          #endif
  75          // 2005/6/3 0:11AM by Emily 
  76          //*********************************************************
  77          // HDCP BKSV key
  78          //*********************************************************
  79          void msInitHDCPProductionKey(void)
  80          {
  81   1              BYTE ucValue;
  82   1              WORD wCount;
  83   1      
  84   1              // prevent complier warning
  85   1      #if (CHIP_ID==CHIP_TSUMC)||(CHIP_ID==CHIP_TSUMD)||(CHIP_ID==CHIP_TSUMF)
  86   1              Bool bHDCPKeyInEfuse = FALSE;
  87   1              WORD wChecksum = 0, wEfuseChecksum = 0;
  88   1          
  89   1              msEread_SetComboInitialValue();
  90   1              bHDCPKeyInEfuse = msEread_IsHDCPKeyInEfuse();
  91   1          if(bHDCPKeyInEfuse)
  92   1              HDCP_printMsg("HDCP key in Efuse\n");
  93   1      #endif
  94   1      
  95   1      #if (CHIP_ID == CHIP_TSUM9 ) // cannot load key from efuse
                  Bool bHDCPKeyInEfuse = FALSE; 
                  WORD wChecksum = 0, wEfuseChecksum = 0;
              #endif
  99   1      
 100   1      #if (CHIP_ID==CHIP_TSUMC)||(CHIP_ID==CHIP_TSUMD)||(CHIP_ID==CHIP_TSUM9)||(CHIP_ID==CHIP_TSUMF)
 101   1              DVI_RELATED_CLOCK_CTRL_0(0xFFFF, 0xFFFF);
 102   1              DVI_RELATED_CLOCK_CTRL_1(0x3FFF, 0x3FFF);
 103   1      #else
                      DVI_RELATED_CLOCK_CTRL(0, 0x601); //msWrite2ByteMask( REG_290C, 0, 0x601 ); // HDCP related power 
             -power down
              #endif
 106   1          
 107   1      #if (CHIP_ID==CHIP_TSUMC)||(CHIP_ID==CHIP_TSUMD) ||(CHIP_ID==CHIP_TSUM9)||(CHIP_ID==CHIP_TSUMF) //&& ENABL
             -E_XIU_WRITE_KEY
 108   1      
 109   1          //Bksv need to write in 74REG for HDMI/DVI
 110   1          HDCP_CPU_WRITE_BKSV_START();
 111   1      
C51 COMPILER V9.01   MSHDCP                                                                03/09/2023 15:39:03 PAGE 3   

 112   1          for( wCount = 0; wCount < 5; wCount++ )
 113   1          {
 114   2      #if !Init_HDCPKey
 115   2              ucValue = BKSV[wCount];
 116   2              if(bHDCPKeyInEfuse)
 117   2              {
 118   3                  ucValue = msEread_GetHDCPKeyFromEfuse(wCount);
 119   3                  wChecksum += ucValue;
 120   3                  //printData("Efuse = 0x%x\n", ucValue);
 121   3              }
 122   2      #else
              #if HDCPKEY_IN_Flash
                      //Flash_Read_Factory_KeySet( FLASH_KEY_HDCP, TRUE, wCount, 1, &ucValue, 1 );
                                      #if ENABLE_USE_ISPTOOL_Write_HDCP
                                      ucValue = FlashReadHDCPByte( IspWriteHDCPkey_Addre+ BKSVDataAddr + wCount );    //120105 Modify
                                      //printData("TmpValue=[0-5]===%x", TmpValue);
                                      #else
                                      ucValue = FlashReadByte( HDCPKEYSET_START+ BKSVDataAddr+wCount);
                                      #endif
              
              #else
                      Set_HdcpNVRamFlag();
                      NVRam_ReadByte( RM_HDCP_KEY_BASEADDR1 + wCount, &ucValue );
                      Clr_HdcpNVRamFlag();
              #endif
              #endif
 138   2      
 139   2              HDCP_CPU_WRITE_BKSV(wCount, ucValue); // write data and trigger latch data
 140   2              while(HDCP_CPU_WR_BUSY()); // wait ready
 141   2          }
 142   1      
 143   1          // First 5 bytes is BKSV only use for DP port.
 144   1          HDCP_CPU_WRITE_ENABLE(0xC0, 0xC0); //[7]Enable CPU write, [6]Access SRAM
 145   1          HDCP_XIU_WRITE_KEY_ENABLE(); //Access Key SRAM through XIU.
 146   1          for( wCount = 0; wCount < 5; wCount++ )
 147   1          {
 148   2          #if !Init_HDCPKey
 149   2              ucValue = BKSV[wCount];
 150   2              if(bHDCPKeyInEfuse)
 151   2              {
 152   3                  ucValue = msEread_GetHDCPKeyFromEfuse(wCount);
 153   3              }
 154   2          #else
                      #if HDCPKEY_IN_Flash
                      //Flash_Read_Factory_KeySet( FLASH_KEY_HDCP, TRUE, wCount, 1, &ucValue, 1 );
                                      #if ENABLE_USE_ISPTOOL_Write_HDCP
                                      ucValue = FlashReadHDCPByte( IspWriteHDCPkey_Addre+ BKSVDataAddr + wCount );    //120105 Modify
                                      //printData("TmpValue=[0-5]===%x", TmpValue);
                                      #else
                                      ucValue = FlashReadByte( HDCPKEYSET_START+ BKSVDataAddr+wCount);
                                      #endif
                      #else
                      Set_HdcpNVRamFlag();
                      NVRam_ReadByte( RM_HDCP_KEY_BASEADDR1 + wCount, &ucValue );
                      Clr_HdcpNVRamFlag();
                      #endif
                  #endif
 169   2      
 170   2              HDCP_XIU_WRITE_KEY(ucValue);
 171   2      #if ((CHIP_ID==CHIP_TSUMC)||(CHIP_ID==CHIP_TSUMD) ||(CHIP_ID==CHIP_TSUM9)||(CHIP_ID==CHIP_TSUMF)) //130912
             - nick add follow trunk//&& ENABLE_XIU_WRITE_KEY       
 172   2              msWriteByte( REG_06A0 + wCount, ucValue );           //Off-Line Key
C51 COMPILER V9.01   MSHDCP                                                                03/09/2023 15:39:03 PAGE 4   

 173   2              msWriteByte( REG_07A0 + wCount, ucValue );           //Off-LineKey 
 174   2      #endif          
 175   2          }
 176   1      
 177   1          for( wCount = 0; wCount < 284; wCount++ )
 178   1          {
 179   2          #if !Init_HDCPKey
 180   2              ucValue = HDCPkey[wCount] ;
 181   2              if(bHDCPKeyInEfuse)
 182   2              {
 183   3                  ucValue = msEread_GetHDCPKeyFromEfuse(wCount+5);
 184   3                  wChecksum += ucValue;
 185   3                  //printData("Efuse = 0x%x\n", ucValue);
 186   3              }
 187   2          #else
                      #if HDCPKEY_IN_Flash
                                #if ENABLE_USE_ISPTOOL_Write_HDCP
                              ucValue = FlashReadHDCPByte( IspWriteHDCPkey_Addre+HDCPKetAddr + wCount );      //120105 Modify
                                      //printData("TmpValue=[284]===%x", TmpValue);
                              #else
                              ucValue=FlashReadByte( HDCPKEYSET_START+HDCPKetAddr+wCount);
                      #endif
                      //Flash_Read_Factory_KeySet( FLASH_KEY_HDCP, TRUE, wCount + HDCPKetAddr, 1, &ucValue, 1 );
                      #else
                      Set_HdcpNVRamFlag();
                      NVRam_ReadByte( RM_HDCP_KEY_BASEADDR2 + wCount, &ucValue );
                      Clr_HdcpNVRamFlag();
                      #endif
                  #endif
 202   2      
 203   2              HDCP_XIU_WRITE_KEY(ucValue); // write data and trigger latch data
 204   2          }
 205   1          HDCP_XIU_WRITE_KEY_DISABLE();
 206   1      
 207   1          if(bHDCPKeyInEfuse)
 208   1          {
 209   2              if(msEread_CompareHDCPChecksumInEfuse(wChecksum))
 210   2                  HDCP_printMsg("Efuse Checksum match ^^ \n");
 211   2              else
 212   2              {
 213   3                  HDCP_printMsg("Efuse Checksum wrong @@ \n");
 214   3                  HDCP_printData("Calculate checksum = 0x%x\n", wChecksum);
 215   3                  HDCP_printData("Efuse checksum = 0x%x\n", wEfuseChecksum);
 216   3              }
 217   2          }
 218   1      
 219   1      
 220   1      #else   //2 u
                  HDCP_CPU_WRITE_BKSV_START();  
                      for( wCount = 0; wCount < 5; wCount++ )
                      {
              #if !Init_HDCPKey
                      ucValue = BKSV[wCount];
              #else
                      #if HDCPKEY_IN_Flash
                                      #if ENABLE_USE_ISPTOOL_Write_HDCP
                                      ucValue = FlashReadHDCPByte( IspWriteHDCPkey_Addre+ BKSVDataAddr + wCount );    //120105 Modify
                                      //printData("TmpValue=[0-5]===%x", TmpValue);
                                      #else
                                      ucValue = FlashReadByte( HDCPKEYSET_START+ BKSVDataAddr+wCount);
                                      #endif
                      #else
C51 COMPILER V9.01   MSHDCP                                                                03/09/2023 15:39:03 PAGE 5   

                      Set_HdcpNVRamFlag();
                      NVRam_ReadByte( RM_HDCP_KEY_BASEADDR1 + wCount, &ucValue );
                      Clr_HdcpNVRamFlag();
                      #endif
                  #endif
              
                      HDCP_CPU_WRITE_BKSV(wCount, ucValue); // write data and trigger latch data
                      while(HDCP_CPU_WR_BUSY()); // wait ready
                  }
              
                  HDCP_CPU_WRITE_ENABLE(0xC0, 0xC0); //[15]: CPU write enable, [14]: 0: 74 RAM, 1 :HDCP RAM
                  HDCP_CPU_RW_ADDRESS(0); //address
                  HDCP_LOAD_ADDR_GEN_PULSE(); // trigger latch address
                  
                      for( wCount = 0; wCount < 284; wCount++ )
                      {
              #if !Init_HDCPKey
                      ucValue = HDCPkey[wCount] ;
              #else
                      #if HDCPKEY_IN_Flash
                                #if ENABLE_USE_ISPTOOL_Write_HDCP
                              ucValue = FlashReadHDCPByte( IspWriteHDCPkey_Addre+HDCPKetAddr + wCount );      //120105 Modify
                                      //printData("TmpValue=[284]===%x", TmpValue);
                              #else
                              ucValue=FlashReadByte( HDCPKEYSET_START+HDCPKetAddr+wCount);
                                #endif
                      #else
                      Set_HdcpNVRamFlag();
                      NVRam_ReadByte( RM_HDCP_KEY_BASEADDR2 + wCount, &ucValue );
                      Clr_HdcpNVRamFlag();
              #endif
                  #endif
                      
                      HDCP_CPU_WRITE_DATA(ucValue); // write data and trigger latch data
                      while(HDCP_CPU_WR_BUSY()); // wait ready
                  }
              
              #endif //CHIP_ID==CHIP_TSUMC && ENABLE_XIU_WRITE_KEY
 273   1      
 274   1      //========================//
 275   1          //Bcaps=0x00 or 0x80
 276   1      #if ENABLE_HDMI
 277   1          HDCP_CPU_WRITE_BCAPS(0x80); // HDCP data
 278   1      #else
                  HDCP_CPU_WRITE_BCAPS(0); // HDCP data
              #endif
 281   1      
 282   1          HDCP_CPU_WRITE_ENABLE(0, 0xC0); //msWriteByteMask( REG_28F3, 0x00, 0xC0 ); //[15]: CPU write disable, 
             -[14]: 0: 74 RAM, 1 :HDCP RAM
 283   1          HDCP_MISC_SETTING(0x721); //msWrite2Byte( REG_28C0, 0x0721 ); // [10:8]: 3'b111 determine Encrp_En dur
             -ing Vblank in DVI mode; [5]:HDCP enable; [0]: EESS mode deglitch Vsync mode
 284   1          HDCP_ENABLE_DDC(); // [10]: HDCP enable DDC
 285   1      
 286   1      #if CHIP_ID==CHIP_TSUMU && (ENABLE_DUAL_LINK||(HDMI_PORT&(TMDS_PORT_B|TMDS_PORT_C)))
                      //Bksv
                      for(wCount=0; wCount<5; wCount++)
                      {
              #if !Init_HDCPKey
                      ucValue = BKSV[wCount];
                      #else
                      #if HDCPKEY_IN_Flash
                                      #if ENABLE_USE_ISPTOOL_Write_HDCP
C51 COMPILER V9.01   MSHDCP                                                                03/09/2023 15:39:03 PAGE 6   

                                      ucValue = FlashReadHDCPByte( IspWriteHDCPkey_Addre+ BKSVDataAddr + wCount );    //120105 Modify
                                      //printData("TmpValue=[0-5]===%x", TmpValue);
                                      #else
                                      ucValue = FlashReadByte( HDCPKEYSET_START+ BKSVDataAddr+wCount);
                                      #endif
                      //Flash_Read_Factory_KeySet( FLASH_KEY_HDCP, TRUE, wCount, 1, &ucValue, 1 );
                      #else
                      Set_HdcpNVRamFlag();
                      NVRam_ReadByte( RM_HDCP_KEY_BASEADDR1 + wCount, &ucValue );
                      Clr_HdcpNVRamFlag();
                      #endif
                      #endif
                      
                      //msWriteByte(REG_3BFA+wCount, ucValue);
                      //while( msReadByte( REG_3BF2 ) & 0x80 );     // wait ready
                      HDCP1_CPU_WRITE_BKSV(wCount, ucValue);
                      while(HDCP1_CPU_WR_BUSY()); // wait ready
                  }
              
                  //Bcaps=0x00 or 0x80
                #if ENABLE_HDMI
                  HDCP1_CPU_WRITE_BCAPS(0x80); //msWriteByte( REG_3BFF, 0x80 );  //HDCP data
                #else
                  HDCP1_CPU_WRITE_BCAPS(0); //msWriteByte( REG_3BFF, 0x00 );  //HDCP data
                #endif // #if ENABLE_HDMI
              
                  HDCP1_MISC_SETTING(0x721); //msWrite2Byte( REG_3BC0, 0x0721 ); // [10:8]: 3'b111 determine Encrp_En du
             -ring Vblank in DVI mode; [5]:HDCP enable; [0]: EESS mode deglitch Vsync mode
                  HDCP1_ENABLE_DDC(); //msWriteByteMask( REG_3BEF, 0x04, 0x04 ); // [10]: HDCP enable DDC
                  
              #endif //
 325   1      
 326   1      HDCP_FORCE_ACK();
 327   1          
 328   1      }
 329          ///////////////////////////////////////////////////////////////////////////////
 330          // <Function>: msPullLowHPD1
 331          //
 332          // <Description>: Pull low DVI Hot-Plug-Detection pin
 333          //
 334          // <Parameter>: None
 335          //
 336          //
 337          ///////////////////////////////////////////////////////////////////////////////
 338          #if 0
              void msPullLowHPD1( void )
              {
                  if(CURRENT_INPUT_IS_HDMI())//( SrcInputType == Input_HDMI ) //130529 Modify
                  {
                      if(CURRENT_INPUT_IS_HDMI0())
                      {
                          if(!IS_MHL_PORT0_CABLE_CONNECT())
                              hw_Clr_HdcpHpd();
                      }
              
                      if(CURRENT_INPUT_IS_HDMI1())
                      {
                          if(!IS_MHL_PORT1_CABLE_CONNECT())
                              hw_Clr_HdcpHpd2();
                      }
              
                      if(CURRENT_INPUT_IS_HDMI2())
C51 COMPILER V9.01   MSHDCP                                                                03/09/2023 15:39:03 PAGE 7   

                      {
                          if(!IS_MHL_PORT2_CABLE_CONNECT())
                              hw_Clr_HdcpHpd3();
                      }
                  }
              }
              #endif
 363          void msPullLowHPD1( void )  // 2017/02/22
 364          {
 365   1          if(CURRENT_INPUT_IS_TMDS())
 366   1          {
 367   2              if(CURRENT_INPUT_IS_HDMI0())//||CURRENT_INPUT_IS_DVI0())
 368   2              {
 369   3                  if(!IS_MHL_PORT0_CABLE_CONNECT())
 370   3                      {
 371   4                      hw_Clr_HdcpHpd();
 372   4                      #if ENABLE_DEBUG
                                      printMsg("aaaaaaaaaaaaaaaaaaaaaaa");
                              #endif
 375   4                      }
 376   3              }
 377   2      
 378   2              if(CURRENT_INPUT_IS_HDMI1())//||CURRENT_INPUT_IS_DVI1())
 379   2              {
 380   3                  if(!IS_MHL_PORT1_CABLE_CONNECT())
 381   3                      {
 382   4                      hw_Clr_HdcpHpd2();
 383   4                              #if ENABLE_DEBUG
                                      printMsg("bbbbbbbbbbbbbbbbb");
                              #endif
 386   4                      }
 387   3              }
 388   2      
 389   2              if(CURRENT_INPUT_IS_HDMI2())//||CURRENT_INPUT_IS_DVI2())
 390   2              {
 391   3                  if(!IS_MHL_PORT2_CABLE_CONNECT())
 392   3                      hw_Clr_HdcpHpd3();
 393   3                      #if ENABLE_DEBUG
                                      printMsg("cccccccccccccccccc");
                              #endif  
 396   3              }
 397   2          }
 398   1      }
 399          ///////////////////////////////////////////////////////////////////////////////
 400          // <Function>: msPullLowHPD1
 401          //
 402          // <Description>: Pull high DVI Hot-Plug-Detection pin
 403          //
 404          // <Parameter>: None
 405          //
 406          //
 407          ///////////////////////////////////////////////////////////////////////////////
 408          #if 0
              void msPullHighHPD1( void )
              {
                  if(CURRENT_INPUT_IS_HDMI())//( SrcInputType == Input_HDMI ) //130529 Modify
                  {
                      if(CURRENT_INPUT_IS_HDMI0())
                      {
                          if(!IS_MHL_PORT0_CABLE_CONNECT())
                              hw_Set_HdcpHpd();
                      }
C51 COMPILER V9.01   MSHDCP                                                                03/09/2023 15:39:03 PAGE 8   

              
                      if(CURRENT_INPUT_IS_HDMI1())
                      {
                          if(!IS_MHL_PORT1_CABLE_CONNECT())
                              hw_Set_HdcpHpd2();
                      }
              
                      if(CURRENT_INPUT_IS_HDMI2())
                      {
                          if(!IS_MHL_PORT2_CABLE_CONNECT())
                              hw_Set_HdcpHpd3();
                      }
                  }
              }
              #endif
 433          void msPullHighHPD1( void )
 434          {
 435   1          if(CURRENT_INPUT_IS_TMDS())
 436   1          {
 437   2              if(CURRENT_INPUT_IS_HDMI0())//||CURRENT_INPUT_IS_DVI0())
 438   2              {
 439   3                  //if(!IS_MHL_PORT0_CABLE_CONNECT())
 440   3                      hw_Set_HdcpHpd();
 441   3              }
 442   2      
 443   2              if(CURRENT_INPUT_IS_HDMI1())//||CURRENT_INPUT_IS_DVI1())
 444   2              {
 445   3                  //if(!IS_MHL_PORT1_CABLE_CONNECT())
 446   3                      hw_Set_HdcpHpd2();
 447   3              }
 448   2      
 449   2              if(CURRENT_INPUT_IS_HDMI2())//||CURRENT_INPUT_IS_DVI2())
 450   2              {
 451   3                  //if(!IS_MHL_PORT2_CABLE_CONNECT())
 452   3                      hw_Set_HdcpHpd3();
 453   3              }
 454   2          }
 455   1      }
 456          #if 0
              void msTMDSClkOn( Bool u8On)
              {
              #if (MainBoardType == MainBoard_5115_M0E || MainBoardType == MainBoard_7115_M0A)
                  if(CURRENT_INPUT_IS_DVI0())
                  {
                      msWriteByteMask( REG_PM_B2, u8On ? 0 : BIT0, BIT0 ); //seurat DVI RCK port A power down
                      #if ENABLE_DUAL_LINK
                      msWriteByteMask( REG_03B3, u8On ? 0 : BIT0, BIT0 ); //seurat DVI RCK port C power down
                      #endif
                  }
                  else if(CURRENT_INPUT_IS_HDMI0())
                  {
                    #if ENABLE_MHL&&(CHIP_ID == CHIP_TSUM2)
                       mhal_mhl_RxRtermControl((u8On)?(RX_HDMI_RTERM):(RX_RTERM_OFF));
                    #else
                       msWriteByteMask( REG_PM_B2, u8On ? 0 : BIT1, BIT1 ); //seurat DVI RCK port B power down
                    #endif 
                  }
              #else
              
                      if(CURRENT_INPUT_IS_HDMI0() || CURRENT_INPUT_IS_DVI0())
                              DVI_A_RCK_CTRL(u8On);
                      else if(CURRENT_INPUT_IS_HDMI1() || CURRENT_INPUT_IS_DVI1())
C51 COMPILER V9.01   MSHDCP                                                                03/09/2023 15:39:03 PAGE 9   

                              DVI_B_RCK_CTRL(u8On);
                      else if(CURRENT_INPUT_IS_HDMI2() || CURRENT_INPUT_IS_DVI2())
                              DVI_C_RCK_CTRL(u8On);
              
              #endif
              }
              #endif
 487          
 488          void msDVIClkOn( Bool u8On )
 489          {
 490   1      #if DVI_PORT==TMDS_PORT_A
                  #if ENABLE_MHL&&(CHIP_ID == CHIP_TSUM2)
                  //mapi_mhl_SetClk(u8On);
                  mhal_mhl_RxRtermControl((u8On)?(RX_HDMI_RTERM):(RX_RTERM_OFF));
                  #else
                  DVI_A_RCK_CTRL(u8On); //msWriteByteMask( REG_PM_B2, (u8On ? 0 : BIT0), BIT0 ); // DVI RCK port A power
             - down
                  #endif
              #elif DVI_PORT==TMDS_PORT_B
                  DVI_B_RCK_CTRL(u8On); //msWriteByteMask( REG_PM_B2, (u8On ? 0 : BIT1), BIT1 ); // DVI RCK port B power
             - down
              #else
 500   1          DVI_C_RCK_CTRL(u8On); //msWriteByteMask( REG_PM_B3, (u8On ? 0 : BIT0), BIT0 ); // DVI RCK port C power
             - down
 501   1      #endif
 502   1      }
 503          
 504          #if ENABLE_HDMI
 505          void msHDMIClkOn( Bool u8On)
 506          {
 507   1      #if 0//(MainBoardType==MainBoard_JRY_WQ570_EV1)
                  if(CURRENT_INPUT_IS_DVI0())
                      {
                       DVI_A_RCK_CTRL(u8On);
                      #if ENABLE_DUAL_LINK     
                      DVI_C_RCK_CTRL(u8On);
                      #endif
                      }
                  else if(CURRENT_INPUT_IS_HDMI0())
                      {
                      DVI_B_RCK_CTRL(u8On);
                      }
              #else
 520   1        if(Input_TMDS_Nums>=2)
 521   1       {
 522   2           if(CURRENT_INPUT_IS_HDMI0() || CURRENT_INPUT_IS_DVI0())
 523   2               DVI_A_RCK_CTRL(u8On);
 524   2           else if(CURRENT_INPUT_IS_HDMI1() || CURRENT_INPUT_IS_DVI1())
 525   2               DVI_B_RCK_CTRL(u8On);
 526   2           else if(CURRENT_INPUT_IS_HDMI2() || CURRENT_INPUT_IS_DVI2())
 527   2               DVI_C_RCK_CTRL(u8On); 
 528   2       }
 529   1       else
 530   1       {
 531   2      #if HDMI_PORT==TMDS_PORT_C//TMDS_PORT_C
                   DVI_C_RCK_CTRL(u8On);
              #elif HDMI_PORT==TMDS_PORT_B //TMDS_PORT_B
                   DVI_B_RCK_CTRL(u8On);
              #else //TMDS_PORT_A
 536   2           DVI_A_RCK_CTRL(u8On);
 537   2      #endif
 538   2       }
C51 COMPILER V9.01   MSHDCP                                                                03/09/2023 15:39:03 PAGE 10  

 539   1      
 540   1              
 541   1      #endif
 542   1      }
 543          #endif
 544          
 545          ///////////////////////////////////////////////////////////////////////////////
 546          // <Function>: msPullLowHPD2
 547          //
 548          // <Description>: Cut off DVI receiver clock current
 549          //
 550          // <Parameter>: None
 551          //
 552          ///////////////////////////////////////////////////////////////////////////////
 553          void msPullLowHPD2( void )
 554          {
 555   1      
 556   1          HDCP_PORT_DISABLE(); //disable HDCP port
 557   1          HDCP_CLEAR_STATUS(); //Clear HDCP status
 558   1          
 559   1          if(CURRENT_INPUT_IS_DVI())
 560   1              msDVIClkOn(FALSE);
 561   1      #if ENABLE_HDMI
 562   1          else
 563   1              #if HDMI_PRETEST
                      msHDMIClkOn(TRUE);
                      #else
 566   1              msHDMIClkOn(FALSE);
 567   1              #endif
 568   1      #endif
 569   1              
 570   1      }
 571          ///////////////////////////////////////////////////////////////////////////////
 572          // <Function>: msPullHighHPD2
 573          //
 574          // <Description>: Connect DVI receiver clock current
 575          //
 576          // <Parameter>: None
 577          //
 578          ///////////////////////////////////////////////////////////////////////////////
 579          void msPullHighHPD2( void )
 580          {
 581   1      #if 0
                  msTMDSClkOn(TRUE);
              #endif
 584   1          if(CURRENT_INPUT_IS_DVI())
 585   1              msDVIClkOn(TRUE);
 586   1      #if ENABLE_HDMI
 587   1          else
 588   1              msHDMIClkOn(TRUE);
 589   1      #endif
 590   1          HDCP_PORT_ENABLE(); //msWriteByteMask(SC0_BD,0,BIT7); //enable HDCP port
 591   1      }
 592          void mstar_HDCPReset(void)
 593          {
 594   1              DVI_RESET(TRUE);
 595   1              HDCP_RESET(TRUE);
 596   1              ForceDelay1ms(2);
 597   1              HDCP_RESET(FALSE);
 598   1              DVI_RESET(FALSE);
 599   1      }
 600          
C51 COMPILER V9.01   MSHDCP                                                                03/09/2023 15:39:03 PAGE 11  

 601          void msDisableHDCP( void )
 602          {
 603   1          msPullLowHPD1();
 604   1          ForceDelay1ms( 100 );//2 jemery 180930 follow demo  
 605   1          msPullLowHPD2();
 606   1          mstar_HDCPReset();
 607   1      }
 608          void msEnableHDCP( void )
 609          {
 610   1          if( !PowerSavingFlag )
 611   1          {
 612   2              msDisableHDCP();
 613   2              ForceDelay1ms(300);
 614   2          }
 615   1          msPullHighHPD2();
 616   1          ForceDelay1ms( 100 );//2 jemery 180930 follow demo  
 617   1          msPullHighHPD1();
 618   1      }
 619          
 620          
 621          #if ENABLE_DUAL_LINK
              WORD Mode_GetStandardModePxlRate()
              {
                  return (WORD)((DWORD)StandardModeHTotal * HFreq( SrcHPeriod ) / 10000);
              }
              
              Bool IsSrcUseDualLinkDviPort(void)
              {
                      if(SrcInputType == Input_Digital) // DVI Dual-link - PortC+A
                      return 1;
                      return 0;
              }
              
              // DVI dual-link configuration
              void msDVIDualLinkMode(Bool bEnable)
              {
                      msWriteBit(REG_1E3E, bEnable, _BIT7);
                      if(bEnable) // dual-link, portC+A
                      {
                              msWriteByteMask( REG_2800, 0, BIT7|BIT6 ); // [7]: ABSWAP, [6]: ignore_dual_en
                              msWriteByteMask( REG_2801, 0, BIT6|BIT5 ); // [6]: DVI_linkb_en, [5]: DVI_dual_manual_en
                              msWriteByteMask( REG_2860, BIT5|BIT4, BIT6|BIT5|BIT4 ); // [6]: DVI_dual_b_ov_en, [5]: DVI_dual_c_ov_en,
             - [4]: DVI_dual_ov_en
                              //msWriteByteMask(REG_2E02, 0x10, 0xF0); // Set scaler IPMUX to dual-link
                              //msWriteBit(SC23_06, TRUE, _BIT2); // dual-in enable
                              //msWriteBit(SC23_07, TRUE, _BIT2); // odd/even pixel swap
              
                              msWriteByteMask(SC0_A6, _BIT1, _BIT1);
                      }
                      else // single-link, port C
                      {
                              msWriteByteMask( REG_2800, BIT6, BIT7|BIT6 ); // [7]: ABSWAP, [6]: ignore_dual_en
                              msWriteByteMask( REG_2801, BIT6|BIT5, BIT6|BIT5 ); // [6]: DVI_linkb_en, [5]: DVI_dual_manual_en
                              //msWriteByteMask( REG_2860, BIT5|BIT4, BIT6|BIT5|BIT4 ); // [6]: DVI_dual_b_ov_en, [5]: DVI_dual_c_ov_e
             -n, [4]: DVI_dual_ov_en
                              //msWriteByteMask(REG_2E02, 0xA0, 0xF0); // Set scaler IPMUX to single-link
                              //msWriteBit(SC23_06, FALSE, _BIT2); // dual-in disable
                              //msWriteBit(SC23_07, FALSE, _BIT2);
              
                              msWriteByteMask(SC0_A6, 0, _BIT1);
                      }
              }
C51 COMPILER V9.01   MSHDCP                                                                03/09/2023 15:39:03 PAGE 12  

              
              Bool msGetDVIDualLinkStatus(void)
              {
                      #if DL_PXL_RAT_DET
                      WORD rate;
              
                      rate = Mode_GetStandardModePxlRate();
              
                      //printData("DVI Pixel Rate : %d", rate);
              
                      if( rate > 165 )
                      return TRUE;
                      else
                      return FALSE;
                      #else
                      BYTE ucDualLinkStatus = 0, ucStableCnt,ucIntCount = 0;
                      WORD wHDE, wVDE;
              
                      for(ucStableCnt = 0; ucStableCnt < 5; ucStableCnt++)
                      {
                              msWriteByte(REG_29E3, 0x44); // clear DE changed IRQ status
                              msWriteByte(REG_29E3, 0);
              
                              ForceDelay1ms(10);
                              ucDualLinkStatus |= msReadByte(REG_29E0); // Check DE changed IRQ status
              
                              if((ucDualLinkStatus&_BIT6)) // Check primary-link DE changed status
                              ucIntCount++;
                      }
              
                      if(ucIntCount != 0) // If primary-link DE changed, that means signal is coupled from another port.
                      {
                              //printMsg("\r\n DVI_SINGLE_LINK()");
                              return FALSE;
                      }
                      else // primary-link DE is unchanged, check whether DE is stable or unstable
                      {
                              for(ucStableCnt = 0; ucStableCnt < 20; ucStableCnt++)
                              {
                                      ForceDelay1ms(20);
                                      ucDualLinkStatus = msReadByte(REG_3B62); // DVI1 DE is stable
                                      if((ucDualLinkStatus&_BIT6) != 0)
                                      break;
                              }
                              if((ucDualLinkStatus&_BIT6) != 0)
                              {
                                      wHDE = msRead2Byte(SC0_84) - msRead2Byte(SC0_80);
                                      wVDE = msRead2Byte(SC0_82) - msRead2Byte(SC0_7E);
                                      // software patch for MSPG4233 dual-link port
                                      //printMsg("\r\n HDE-VDE = %d", (signed)wHDE - wVDE);
                                      if(wHDE <= wVDE)
                                      {
                                              //printMsg("\r\n DVI_DUAL_LINK");
                                              return TRUE;
                                      }
                                      else
                                      {
                                              //printMsg("\r\n II -DVI_SINGLE_LINK()");
                                              return FALSE; // single-link
                                      }
                              }
                              else
C51 COMPILER V9.01   MSHDCP                                                                03/09/2023 15:39:03 PAGE 13  

                              {
                                      //printMsg("\r\n II -DVI_SINGLE_LINK()");
                                      return FALSE;
                              }
                      }
                      #endif
              }
              #endif // #if ENABLE_DUAL_LINK
 731          
 732          
 733          
 734          
 735          
 736          
 737          
 738          #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    850    ----
   CONSTANT SIZE    =    289    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       9
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

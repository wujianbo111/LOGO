C51 COMPILER V9.01   DRVADC                                                                03/09/2023 15:39:15 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE DRVADC
OBJECT MODULE PLACED IN .\obj\drvADC.obj
COMPILER INVOKED BY: D:\Keil4\C51\BIN\C51.EXE ..\..\KERNEL\SCALER\drvADC.c OPTIMIZE(SIZE) BROWSE INCDIR(..\..\DRIVER\INC
                    -;..\..\KERNEL\SCALER\INC;..\..\KERNEL\SYSTEM\INC;..\..\LIB\INC;..\..\PANEL\INC;..\..\BOARD;..\..\DRIVER\INC;..\..\KERNEL
                    -\SYSTEM\INC\AOC2011;..\..\DRIVER\extDEVICE\INC;..\..\MODEL;..\..\CONFIG;..\..\PANEL;..\..\UI\F_LOGO\INC;..\..\UI\HkcOsd\
                    -INC) DEFINE(ModelName=JRY_TESTBOARD_C_BOARD) DEBUG OBJECTEXTEND PRINT(.\list\drvADC.lst) OBJECT(.\obj\drvADC.obj)

line level    source

   1          ///////////////////////////////////////////////////////////////////////////////////////////////////
   2          ///
   3          /// file    drvADC.c
   4          /// @author MStar Semiconductor Inc.
   5          /// @brief  ADC Function
   6          ///////////////////////////////////////////////////////////////////////////////////////////////////
   7          #ifndef _DRVADC_C_
   8          #define _DRVADC_C_
   9          
  10          //-------------------------------------------------------------------------------------------------
  11          //  Include Files
  12          //-------------------------------------------------------------------------------------------------
  13          #include <math.h>
  14          #include <string.h>
  15          #include "board.h"
  16          #include "types.h"
  17          #include "ms_reg.h"
  18          #include "ms_rwreg.h"
  19          //#include "DebugMsg.h"
  20          #include "global.h"
  21          #include "drvADC.h"
  22          #include "Misc.h"
  23          #include "power.h"
  24          #if ENABLE_DEBUG
              #include "gpio_def.h"
              #endif
  27          
  28          #if CHIP_ID >= CHIP_TSUMC
  29          #include "msEread.h"
  30          #endif
  31          
  32          #if 1//ENABLE_VGA_INPUT
  33          
  34          //-------------------------------------------------------------------------------------------------
  35          //  Local Defines
  36          //-------------------------------------------------------------------------------------------------
  37          
  38          //#define ADC_DEBUG
  39          
  40          #ifdef ADC_DEBUG
                  #define ADC_DPUTSTR(str)    printMsg(str)
                  #define ADC_DPRINTF(str, x) printData(str, x)
              #else
  44              #define ADC_DPUTSTR(str)
  45              #define ADC_DPRINTF(str, x)
  46          #endif
  47          
  48          #define   AUTO_GAIN_RGB_TARGET_CODE         182           //0.5/0.7*255=182.1
  49          #define   AUTO_GAIN_TOLERANCE_CODE          0
  50          #define   AUTO_GAIN_RGB_MAXVAL              (AUTO_GAIN_RGB_TARGET_CODE+AUTO_GAIN_TOLERANCE_CODE )
  51          #define   AUTO_GAIN_RGB_MINVAL              (AUTO_GAIN_RGB_TARGET_CODE-AUTO_GAIN_TOLERANCE_CODE )
  52          #define   DADCMISMATCHLOOP                  5  // ADC mismatch calibration loop
C51 COMPILER V9.01   DRVADC                                                                03/09/2023 15:39:15 PAGE 2   

  53          
  54          #define drvADC_Write2BytesMask  msWrite2ByteMask
  55          #define drvADC_ReadByte         msReadByte
  56          
  57          //void drvADC_Test_Funct(BYTE tb1, BYTE tb2);
  58          //-------------------------------------------------------------------------------------------------
  59          //  Local Structures
  60          //-------------------------------------------------------------------------------------------------
  61          
  62          typedef struct
  63          {
  64              BYTE *pTable;
  65              BYTE u8TabCols;
  66              BYTE u8TabRows;
  67              BYTE u8TabIdx;
  68          } TAB_Info;
  69          
  70          typedef struct
  71          {
  72              BYTE PLL_Ictrl; // ADC_ATOP_09_H [1:0]: PLL Ictrl
  73              BYTE PLL_Mult_Mod_216m; // ADC_ATOP_0A_L [5]: 216m_en, [4:3]: PLL mod, [2:0]: PLL mult
  74              BYTE LPF_Rch; // low pass filter setting in Rch
  75              BYTE LPF_Gch; // low pass filter setting in Gch
  76              BYTE LPF_Bch; // low pass filter setting in Bch
  77              WORD Blacklevel_Rch; // Rch black level
  78              WORD Blacklevel_Gch; // Gch black level
  79              WORD Blacklevel_Bch; // Bch black level
  80              WORD Offset_Rch; // Rch offset level
  81              WORD Offset_Gch; // Gch offset level
  82              WORD Offset_Bch; // Bch offset level
  83          #if ENABLE_XTAL_LESS
                  BYTE BWCoef; // ADC PLL Bandwidth Coefficient, ADC_DTOP_02_L[7:0]
                  BYTE DampCoef; // ADC PLL damping coefficient, ADC_DTOP_03_L[7:0]
              #endif // #if ENABLE_XTAL_LESS
  87          } msADCBackupSetting;
  88          
  89          typedef struct
  90          {
  91              BYTE DBuffer; // scaler double buffer setting
  92              BYTE ISEL; // Scaler input select
  93              WORD SPRHST; // Image horizontal sample start point
  94              WORD SPRHDC; // Image horizontal resolution
  95              WORD SPRVST; // Image vertical sample start point
  96              WORD SPRVDC; // Image vertical resolution
  97          } msScalerBackupSetting;
  98          
  99          typedef enum
 100          {
 101              E_Vcal_0_55V = 0,
 102              E_Vcal_1_05V = 1,
 103          } msADC_InternalVcal;
 104          
 105          typedef enum
 106          {
 107              E_PG_Htotal_256 = 0,
 108              E_PG_Htotal_512 = 1,
 109              E_PG_Htotal_1024 = 2,
 110              E_PG_Htotal_2048 = 3,
 111          } msADCScalerPG_HtotalSel;
 112          
 113          typedef struct
 114          {
C51 COMPILER V9.01   DRVADC                                                                03/09/2023 15:39:15 PAGE 3   

 115              BYTE AVG_Rch;
 116              BYTE AVG_Gch;
 117              BYTE AVG_Bch;
 118          } msADCAvgVal;
 119          
 120          typedef struct
 121          {
 122              WORD wOffsetVal_Rch0;
 123              WORD wOffsetVal_Rch1;
 124              WORD wPivot_Rch;
 125              WORD wOffsetVal_Gch0;
 126              WORD wOffsetVal_Gch1;
 127              WORD wPivot_Gch;
 128              WORD wOffsetVal_Bch0;
 129              WORD wOffsetVal_Bch1;
 130              WORD wPivot_Bch;
 131              WORD wGainVal_Rch0;
 132              WORD wGainVal_Rch1;
 133              WORD wGainVal_Gch0;
 134              WORD wGainVal_Gch1;
 135              WORD wGainVal_Bch0;
 136              WORD wGainVal_Bch1;
 137          } msADCMismatchCalVal;
 138          
 139          
 140          //-------------------------------------------------------------------------------------------------
 141          //  Global Variables
 142          //-------------------------------------------------------------------------------------------------
 143          
 144          msADCBackupSetting xdata gADCBackupSetting;
 145          msScalerBackupSetting xdata gScalerBackupSetting;
 146          msADCMismatchCalVal xdata gADCMismatchAvgVal;
 147          
 148          //-------------------------------------------------------------------------------------------------
 149          //  Local Variables
 150          //-------------------------------------------------------------------------------------------------
 151          
 152          
 153          
 154          //-------------------------------------------------------------------------------------------------
 155          //  Local Functions
 156          //-------------------------------------------------------------------------------------------------
 157          
 158          static void drvADC_LoadTable(TAB_Info* pTab_info);
 159          //static void drvADC_Write2BytesMask(WORD u16regadr, WORD u16val, WORD u16mask);
 160          //static BYTE drvADC_ReadByte(WORD u16regadr);
 161          //static BYTE drvADC_WaitAutoStatusReady(WORD regAddr, BYTE regFlag);
 162          static void drvADC_SetMux(ADC_MUX_TYPE ipmux_type);
 163          static BYTE drvADC_SearchFreqSetTableIndex(WORD u16OriginalPixClk);
 164          static void drvADC_BackupADCSetting(void);
 165          static void drvADC_RecoverADCSetting(void);
 166          static void drvADC_SetFreeRunClock(void);
 167          #if (CHIP_ID == CHIP_TSUMD || CHIP_ID == CHIP_TSUM9 || CHIP_ID == CHIP_TSUMF ) 
              static void drvADC_MismatchLinearityCal(void);
              #endif
 170          static void drvADC_MismatchOffsetCal(void);
 171          static void drvADC_MismatchGainCal(void);
 172          static Bool drvADC_AutoAdjustAdcGain(BYTE vsyncTime);
 173          static BYTE drvADC_CheckPGAGain(BYTE vsyncTime);
 174          static void drvADC_SetPGAGainCode(BYTE ucAdcPgaGain);  //Steven110329, Solve check PGA gain issue.
 175          
 176          #if DADCPLLPROTECTION
C51 COMPILER V9.01   DRVADC                                                                03/09/2023 15:39:15 PAGE 4   

 177          static void drvADC_IsEnableFreeRun(Bool bflag);
 178          static void drvADC_SetAutoProst(Bool bflag);
 179          #endif // #ifdef DADCPLLPROTECTION
 180          
 181          #if (((_DGAIN_CAL_WITHOUT_INPUT_) && (DADCNEWGAINCALMETHOD == 0)) || (_DGAIN_CAL_WITH_INPUT_))
              static void drvADC_BackupScalerSetting(void);
              static void drvADC_RecoverScalerSetting(void);
              #if _DGAIN_CAL_WITHOUT_INPUT_
              #if (DADCNEWGAINCALMETHOD==0)
              static void drvADC_EnableScalerPG(msADCScalerPG_HtotalSel ht_sel);
              static void _msADC_MaskExternalSync(Bool bflag);
              #endif
              #endif
              static void drvADC_SetInternalVcal(msADC_InternalVcal vcal);
              static Bool drvADC_IsReadLineBuffer(Bool bflag);
              static msADCAvgVal drvADC_GetRGBLineBufAverageData(WORD wLineBufAddress, BYTE LineBuf, BYTE AvgCnt);
              static Bool drvADC_AutoGainAdjustment(void);
              #endif
 195          
 196          
 197          //-------------------------------------------------------------------------------------------------
 198          //  Global Functions
 199          //-------------------------------------------------------------------------------------------------
 200          extern Bool CheckSyncLoss(void);
 201          
 202          //**************************************************************************
 203          //  [Function Name]:
 204          //                  drvADC_init()
 205          //  [Description]
 206          //                  ADC init
 207          //  [Arguments]:
 208          //                  IsShareGrd: is used shared negative pin with R/G/B
 209          //  [Return]:
 210          //
 211          //**************************************************************************
 212          void drvADC_init(Bool IsShareGrd)
 213          {
 214   1          TAB_Info xdata Tab_info;
 215   1         // xdata BYTE no_use = 0;
 216   1      #if ((CHIP_ID == CHIP_TSUMC) || (CHIP_ID == CHIP_TSUMD) || (CHIP_ID == CHIP_TSUM9 )|| (CHIP_ID == CHIP_TSU
             -MF))
 217   1          BYTE xdata  u8ADCBandgapTrimVal = 0;
 218   1      #endif
 219   1      
 220   1          Tab_info.pTable = (void*)MST_ADCINIT_TBL;
 221   1          Tab_info.u8TabCols = REG_ADDR_SIZE+REG_MASK_SIZE+ADC_TABLE_INIT_NUMS*REG_DATA_SIZE;
 222   1          Tab_info.u8TabRows = sizeof(MST_ADCINIT_TBL)/Tab_info.u8TabCols;
 223   1          Tab_info.u8TabIdx = 0;
 224   1      
 225   1          //ADC_DPUTSTR("ADC Tbl:init\n");
 226   1          drvADC_LoadTable(&Tab_info);
 227   1      
 228   1          // Set share ground bit
 229   1          drvADC_Write2BytesMask( REG_ADC_ATOP_22_L, IsShareGrd ? BIT9 : 0, BIT9 );
 230   1      
 231   1      #if ((CHIP_ID==CHIP_TSUMC) || (CHIP_ID==CHIP_TSUMD)|| (CHIP_ID == CHIP_TSUM9 )||(CHIP_ID == CHIP_TSUMF))
 232   1      
 233   1          #if (CHIP_ID == CHIP_TSUM9) || (CHIP_ID == CHIP_TSUMF)
                   u8ADCBandgapTrimVal = msEread_GetDataFromEfuse(0x0001);
                       #else
 236   1          u8ADCBandgapTrimVal = msEread_GetADCBandgapTrimValFromEfuse();
 237   1              #endif
C51 COMPILER V9.01   DRVADC                                                                03/09/2023 15:39:15 PAGE 5   

 238   1          if(u8ADCBandgapTrimVal & BIT7)
 239   1          {
 240   2              drvADC_Write2BytesMask( REG_ADC_ATOP_34_L, ((u8ADCBandgapTrimVal & 0x1F)<<8)|BIT7, 0x1F80);
 241   2              ADC_DPRINTF("$$ ADC Bandgap Trim value = 0x%x\n", u8ADCBandgapTrimVal);
 242   2          }
 243   1      #endif
 244   1      
 245   1          drvADC_SetPGAGainCode(UserPrefAdcPgaGain);  //Steven110329, Solve check PGA gain issue.
 246   1          
 247   1          drvADC_SetHsyncRefLevel(ADC_HSYNC_LVL_DEF); // REFH=1.87V, REFL=0.88V // 120725 coding, moves here
 248   1          
 249   1          //if(no_use)
 250   1          //{
 251   1             // drvADC_Test_Funct(0 ,0);
 252   1          //}
 253   1      }
 254          
 255          //**************************************************************************
 256          //  [Function Name]:
 257          //                  drvADC_SetInputMux()
 258          //  [Description]
 259          //                  Setup analog input mux
 260          //  [Arguments]:
 261          //                  port_type: InputPortType
 262          //  [Return]:
 263          //
 264          //**************************************************************************
 265          void drvADC_SetInputMux(InputPortType port_type )
 266          {
 267   1          switch(port_type)
 268   1          {
 269   2              default:
 270   2              case Input_VGA:
 271   2                  drvADC_SetMux(ADC_TABLE_MUX_RGB0_Sync);
 272   2      #if ((CHIP_ID != CHIP_TSUMC) && (CHIP_ID != CHIP_TSUMD) && (CHIP_ID != CHIP_TSUM9 ) && (CHIP_ID != CHIP_TS
             -UMF ))
                          drvADC_SetMux(ADC_TABLE_MUX_RGB0_Data);
              #endif
 275   2                  break;
 276   2          }
 277   1      }
 278          
 279          //**************************************************************************
 280          //  [Function Name]:
 281          //                  drvADC_SetADCSource()
 282          //  [Description]
 283          //                  Setup ADC source is RGB or YPbPr or SOG
 284          //  [Arguments]:
 285          //                  inputsrc_type: RGB / YPbPr / SOG
 286          //  [Return]:
 287          //
 288          //**************************************************************************
 289          void drvADC_SetADCSource(ADC_SOURCE_TYPE inputsrc_type)
 290          {
 291   1          TAB_Info Tab_info;
 292   1          Tab_info.pTable = (void*)MST_ADCSOURCE_TBL;
 293   1          Tab_info.u8TabCols = REG_ADDR_SIZE+REG_MASK_SIZE+ADC_TABLE_SOURCE_NUMS*REG_DATA_SIZE;
 294   1          Tab_info.u8TabRows = sizeof(MST_ADCSOURCE_TBL)/Tab_info.u8TabCols;
 295   1          Tab_info.u8TabIdx = inputsrc_type;
 296   1      
 297   1          //ADC_DPRINTF("ADC Tbl:set src %d \n", inputsrc_type);
 298   1          drvADC_LoadTable(&Tab_info);
C51 COMPILER V9.01   DRVADC                                                                03/09/2023 15:39:15 PAGE 6   

 299   1      }
 300          
 301          //**************************************************************************
 302          //  [Function Name]:
 303          //                  drvADC_SetADCModeSetting()
 304          //  [Description]
 305          //                  Set ADC related settings by mode
 306          //  [Arguments]:
 307          //                  enADCInput: RGB / YPbPr
 308          //                  u16PixelClk: Input pixel clock(MHz)
 309          //  [Return]:
 310          //
 311          //**************************************************************************
 312          void drvADC_SetADCModeSetting(ADC_INPUTSOURCE_TYPE enADCInput, WORD u16PixelClk)
 313          {
 314   1          TAB_Info xdata Tab_info;
 315   1      
 316   1          if ( enADCInput & ADC_INPUTSOURCE_YPBPR ) // YPbPr
 317   1          {
 318   2      #if (CHIP_ID == CHIP_TSUM9 || CHIP_ID == CHIP_TSUMF) && (ENABLE_XTAL_LESS)
                      Tab_info.pTable = (void*)MST_ADCSetMode_OSCYUV_TBL;
                      Tab_info.u8TabCols = REG_ADDR_SIZE+REG_MASK_SIZE+ADC_TABLE_SetMode_NUMS*REG_DATA_SIZE;
                      Tab_info.u8TabRows = sizeof(MST_ADCSetMode_OSCYUV_TBL)/Tab_info.u8TabCols;
              #else
 323   2              Tab_info.pTable = (void*)MST_ADCSetModeYUV_TBL;
 324   2              Tab_info.u8TabCols = REG_ADDR_SIZE+REG_MASK_SIZE+ADC_TABLE_SetMode_NUMS*REG_DATA_SIZE;
 325   2              Tab_info.u8TabRows = sizeof(MST_ADCSetModeYUV_TBL)/Tab_info.u8TabCols;
 326   2      #endif // #if (CHIP_ID == CHIP_TSUM9) && (ENABLE_XTAL_LESS)
 327   2          }
 328   1          else if( enADCInput & ADC_INPUTSOURCE_RGB )// RGB
 329   1          {
 330   2      #if (CHIP_ID == CHIP_TSUM9 || CHIP_ID == CHIP_TSUMF) && (ENABLE_XTAL_LESS)
                      Tab_info.pTable = (void*)MST_ADCSetMode_OSCRGB_TBL;
                      Tab_info.u8TabCols = REG_ADDR_SIZE+REG_MASK_SIZE+ADC_TABLE_SetMode_NUMS*REG_DATA_SIZE;
                      Tab_info.u8TabRows = sizeof(MST_ADCSetMode_OSCRGB_TBL)/Tab_info.u8TabCols;
              #else
 335   2              Tab_info.pTable = (void*)MST_ADCSetModeRGB_TBL;
 336   2              Tab_info.u8TabCols = REG_ADDR_SIZE+REG_MASK_SIZE+ADC_TABLE_SetMode_NUMS*REG_DATA_SIZE;
 337   2              Tab_info.u8TabRows = sizeof(MST_ADCSetModeRGB_TBL)/Tab_info.u8TabCols;
 338   2      #endif // #if (CHIP_ID == CHIP_TSUM9||CHIP_ID == CHIP_TSUMF) && (ENABLE_XTAL_LESS)
 339   2          }
 340   1      
 341   1          Tab_info.u8TabIdx = drvADC_SearchFreqSetTableIndex(u16PixelClk);
 342   1      
 343   1          ADC_DPRINTF("ADC Tbl: TabIdx %d\n", Tab_info.u8TabIdx);
 344   1          drvADC_LoadTable(&Tab_info);
 345   1      #if (CHIP_ID == CHIP_TSUM9) && ENABLE_XTAL_LESS
                      gADCBackupSetting.BWCoef = drvADC_ReadByte(REG_ADC_DTOP_02_L);
                      gADCBackupSetting.DampCoef = drvADC_ReadByte(REG_ADC_DTOP_03_L);
              #endif
 349   1      }
 350          
 351          //**************************************************************************
 352          //  [Function Name]:
 353          //                  drvADC_AdjustHTotal()
 354          //  [Description]
 355          //                  Adjust PLL divider
 356          //  [Arguments]:
 357          //                  htotal: Htotal -3
 358          //  [Return]:
 359          //
 360          //**************************************************************************
C51 COMPILER V9.01   DRVADC                                                                03/09/2023 15:39:15 PAGE 7   

 361          void drvADC_AdjustHTotal(WORD u16HTotal)
 362          {
 363   1      #if ENABLE_MENULOAD     //111223 Modify
                      msML_WaitReady();
                      msML_WriteByte(ML_MODE_NORMAL ,REG_ADC_DTOP_01_L, (u16HTotal-3));
                      msML_WriteByte(ML_MODE_NORMAL ,REG_ADC_DTOP_01_H, (u16HTotal-3)>>8);
                      msML_Trigger(ML_TRIG_OUT_VDE_END);// Vde-end-OP
              
              #elif  ENABLE_SW_DOUBLE_BUFFER
 370   1              msSWDBWaitForRdy();
 371   1              DB_Mode(ML_MODE_NORMAL);
 372   1              DB_WB(REG_ADC_DTOP_01_L, (u16HTotal-3));
 373   1              DB_WB(REG_ADC_DTOP_01_H, (u16HTotal-3)>>8);
 374   1              msSWDBWriteToRegister();
 375   1      #else
                  drvADC_Write2BytesMask(REG_ADC_DTOP_01_L, u16HTotal-3, 0x1FFF);
              #endif
 378   1      }
 379          
 380          //**************************************************************************
 381          //  [Function Name]:
 382          //                  drvADC_SetPhaseCode()
 383          //  [Description]
 384          //                  Set ADC phase code
 385          //  [Arguments]:
 386          //                  code: code, 0~127
 387          //  [Return]:
 388          //
 389          //**************************************************************************
 390          void drvADC_SetPhaseCode(BYTE u8PhaseCode)
 391          {
 392   1      #if (CHIP_ID == CHIP_TSUMF)
                  #define BIT(_bit_)                  (1 << (_bit_))
                  #define BMASK(_bits_)               (BIT(((1)?_bits_)+1)-BIT(((0)?_bits_)))
                      
                  BYTE u8ADCPllMod = (drvADC_ReadByte(REG_ADC_ATOP_0A_L) & BMASK(4:3)) >> 3; // ADC_ATOP_09_L[12:11]: re
             -g_adc_pll_mod
                  WORD u16Mask = BMASK((6+u8ADCPllMod):0) ;
                  WORD u16PhaseCode = u8PhaseCode * (1<<u8ADCPllMod);
              
                  // fix ADC phase not be set while AC/DC On/Off
                  drvADC_Write2BytesMask(REG_ADC_ATOP_15_L, (WORD)u16PhaseCode-(1<<u8ADCPllMod), u16Mask);
                  drvADC_Write2BytesMask(REG_ADC_ATOP_15_L, (WORD)u16PhaseCode, u16Mask);
              #else
 404   1          // fix ADC phase not be set while AC/DC On/Off
 405   1          drvADC_Write2BytesMask(REG_ADC_ATOP_0F_L, (WORD)u8PhaseCode-1, 0x03FF);
 406   1          drvADC_Write2BytesMask(REG_ADC_ATOP_0F_L, (WORD)u8PhaseCode, 0x03FF);
 407   1      #endif // #if (CHIP_ID == CHIP_TSUMF)
 408   1      }
 409          
 410          //**************************************************************************
 411          //  [Function Name]:
 412          //                  drvADC_SetRGBGainCode()
 413          //  [Description]
 414          //                  Set ADC R/G/B gain code
 415          //  [Arguments]:
 416          //                  rcode/gcode/bcode: R/G/B gain value, 0~2047
 417          //  [Return]:
 418          //
 419          //**************************************************************************
 420          void drvADC_SetRGBGainCode(WORD u16RCode, WORD u16GCode, WORD u16BCode)
 421          {
C51 COMPILER V9.01   DRVADC                                                                03/09/2023 15:39:15 PAGE 8   

 422   1          drvADC_Write2BytesMask(REG_ADC_DTOP_45_L, u16RCode, 0x0FFF);
 423   1          drvADC_Write2BytesMask(REG_ADC_DTOP_48_L, u16GCode, 0x0FFF);
 424   1          drvADC_Write2BytesMask(REG_ADC_DTOP_51_L, u16BCode, 0x0FFF);
 425   1      }
 426          
 427          #if AboutDSUBFunc_Enable
 428          void drvADC_SetRedGainCode(WORD u16RCode)
 429          {
 430   1          drvADC_Write2BytesMask(REG_ADC_DTOP_45_L, u16RCode, 0x0FFF);
 431   1      }
 432          void drvADC_SetGreenGainCode(WORD u16GCode)
 433          {
 434   1          drvADC_Write2BytesMask(REG_ADC_DTOP_48_L, u16GCode, 0x0FFF);
 435   1      }
 436          void drvADC_SetBlueGainCode(WORD u16BCode)
 437          {
 438   1          drvADC_Write2BytesMask(REG_ADC_DTOP_51_L, u16BCode, 0x0FFF);
 439   1      }
 440          #endif
 441          //**************************************************************************
 442          //  [Function Name]:
 443          //                  drvADC_SetRGBOffsetCode()
 444          //  [Description]
 445          //                  Set ADC R/G/B offset code
 446          //  [Arguments]:
 447          //                  rcode/gcode/bcode: R/G/B offset value, กำ0~1023(S10)
 448          //  [Return]:
 449          //
 450          //**************************************************************************
 451          #if 1//CHIP_ID==CHIP_TSUML
 452          void drvADC_SetRGBOffsetCode(WORD u16RCode, WORD u16GCode, WORD u16BCode)
 453          {
 454   1          drvADC_Write2BytesMask(REG_ADC_DTOP_46_L, u16RCode, 0x07FF);
 455   1          drvADC_Write2BytesMask(REG_ADC_DTOP_49_L, u16GCode, 0x07FF);
 456   1          drvADC_Write2BytesMask(REG_ADC_DTOP_52_L, u16BCode, 0x07FF);
 457   1      }
 458          #endif
 459          
 460          #if AboutDSUBFunc_Enable
 461          void drvADC_SetRedOffsetCode(WORD u16RCode)
 462          {
 463   1          drvADC_Write2BytesMask(REG_ADC_DTOP_46_L, u16RCode, 0x07FF);
 464   1      }
 465          void drvADC_SetGreenOffsetCode(WORD u16GCode)
 466          {
 467   1          drvADC_Write2BytesMask(REG_ADC_DTOP_49_L, u16GCode, 0x07FF);
 468   1      }
 469          void drvADC_SetBlueOffsetCode(WORD u16BCode)
 470          {
 471   1          drvADC_Write2BytesMask(REG_ADC_DTOP_52_L, u16BCode, 0x07FF);
 472   1      }
 473          #endif
 474          //**************************************************************************
 475          //  [Function Name]:
 476          //                  drvADC_ADCOffsetGainMismatchCal()
 477          //  [Description]
 478          //                  Do ADC self mismatch calibration
 479          //  [Arguments]:
 480          //
 481          //  [Return]:
 482          //
 483          //**************************************************************************
C51 COMPILER V9.01   DRVADC                                                                03/09/2023 15:39:15 PAGE 9   

 484          void drvADC_ADCOffsetGainMismatchCal(void)
 485          {
 486   1          BYTE xdata loop;
 487   1          WORD xdata wRch0diff, wRch1diff, wGch0diff, wGch1diff, wBch0diff, wBch1diff;
 488   1      
 489   1          memset(&gADCMismatchAvgVal, 0, sizeof(gADCMismatchAvgVal));
 490   1      
 491   1          drvADC_Write2BytesMask(REG_ADC_ATOP_51_L, 0x0003, 0x0003); // [1:0]: no ADCA interleve H/V dither
 492   1          drvADC_Write2BytesMask(REG_ADC_ATOP_22_L, 0x0800, 0x0C00); // [11:10]: CLAMP_RGB_OV[1:0] = 2'b10 disab
             -le clamp
 493   1      
 494   1      #if ((CHIP_ID == CHIP_TSUMD) || (CHIP_ID == CHIP_TSUM9 )|| (CHIP_ID == CHIP_TSUMF))
              #if (CHIP_ID == CHIP_TSUM9)
                  drvADC_SetPGAGainCode(0x00);  // for ADC linearity calibration, PGA gain must be set to 0
              #elif (CHIP_ID == CHIP_TSUMF)
                  drvADC_SetPGAGainCode(0x2A);  // for ADC linearity calibration, PGA gain must be set to 0
              #endif // #if (CHIP_ID == CHIP_TSUM9)
                  // Do mismatch linearity calibration
                  drvADC_MismatchLinearityCal();
                  drvADC_SetPGAGainCode(UserPrefAdcPgaGain);  //for ADC linearity calibration
              #endif // #if ((CHIP_ID == CHIP_TSUMD))
 504   1      
 505   1          for(loop=0; loop< DADCMISMATCHLOOP ; loop++)
 506   1          {
 507   2              drvADC_Write2BytesMask(REG_ADC_ATOP_55_L, 0x0000, 0x003F); // [5:0]:disable mismatch offsset and g
             -ain update enable
 508   2      
 509   2              // 1. backup ADC related settings
 510   2              drvADC_BackupADCSetting();
 511   2              // 2. Set free run clock at 720p
 512   2              drvADC_SetFreeRunClock();
 513   2              // 3. Do mismatch offset calibration
 514   2              drvADC_MismatchOffsetCal();
 515   2              // 4. Do mismatch gain calibration
 516   2              drvADC_MismatchGainCal();
 517   2              // 5. recover ADC related settings & turn off free run clock
 518   2              drvADC_RecoverADCSetting();
 519   2      
 520   2              Delay1ms(10);
 521   2          }
 522   1              
 523   1          // Disable ADC dither to fix horizontal/Vertical line noise in some specific panels 
 524   1          //drvADC_Write2BytesMask(REG_ADC_ATOP_51_L, 0x0003, 0x0003); // [1:0]: ADCA interleve H/V dither in th
             -e normal display
 525   1          drvADC_Write2BytesMask(REG_ADC_ATOP_22_L, 0x0000, 0x0C00); // [11:10]: CLAMP_RGB_OV[1:0] = 2'b00 enabl
             -e clamp
 526   1      
 527   1          gADCMismatchAvgVal.wOffsetVal_Rch0 /= DADCMISMATCHLOOP;
 528   1          gADCMismatchAvgVal.wOffsetVal_Rch1 /= DADCMISMATCHLOOP;
 529   1          gADCMismatchAvgVal.wPivot_Rch /= DADCMISMATCHLOOP;
 530   1          gADCMismatchAvgVal.wOffsetVal_Gch0 /= DADCMISMATCHLOOP;
 531   1          gADCMismatchAvgVal.wOffsetVal_Gch1 /= DADCMISMATCHLOOP;
 532   1          gADCMismatchAvgVal.wPivot_Gch /= DADCMISMATCHLOOP;
 533   1          gADCMismatchAvgVal.wOffsetVal_Bch0 /= DADCMISMATCHLOOP;
 534   1          gADCMismatchAvgVal.wOffsetVal_Bch1 /= DADCMISMATCHLOOP;
 535   1          gADCMismatchAvgVal.wPivot_Bch /= DADCMISMATCHLOOP;
 536   1          wRch0diff = gADCMismatchAvgVal.wOffsetVal_Rch0 >= gADCMismatchAvgVal.wOffsetVal_Rch1 ? (gADCMismatchAv
             -gVal.wOffsetVal_Rch1 - gADCMismatchAvgVal.wOffsetVal_Rch0) : 0;
 537   1          wRch1diff = gADCMismatchAvgVal.wOffsetVal_Rch1 >= gADCMismatchAvgVal.wOffsetVal_Rch0 ? (gADCMismatchAv
             -gVal.wOffsetVal_Rch0 - gADCMismatchAvgVal.wOffsetVal_Rch1) : 0;
 538   1          wGch0diff = gADCMismatchAvgVal.wOffsetVal_Gch0 >= gADCMismatchAvgVal.wOffsetVal_Gch1 ? (gADCMismatchAv
             -gVal.wOffsetVal_Gch1 - gADCMismatchAvgVal.wOffsetVal_Gch0) : 0;
C51 COMPILER V9.01   DRVADC                                                                03/09/2023 15:39:15 PAGE 10  

 539   1          wGch1diff = gADCMismatchAvgVal.wOffsetVal_Gch1 >= gADCMismatchAvgVal.wOffsetVal_Gch0 ? (gADCMismatchAv
             -gVal.wOffsetVal_Gch0 - gADCMismatchAvgVal.wOffsetVal_Gch1) : 0;
 540   1          wBch0diff = gADCMismatchAvgVal.wOffsetVal_Bch0 >= gADCMismatchAvgVal.wOffsetVal_Bch1 ? (gADCMismatchAv
             -gVal.wOffsetVal_Bch1 - gADCMismatchAvgVal.wOffsetVal_Bch0) : 0;
 541   1          wBch1diff = gADCMismatchAvgVal.wOffsetVal_Bch1 >= gADCMismatchAvgVal.wOffsetVal_Bch0 ? (gADCMismatchAv
             -gVal.wOffsetVal_Bch0 - gADCMismatchAvgVal.wOffsetVal_Bch1) : 0;
 542   1      
 543   1          gADCMismatchAvgVal.wGainVal_Rch0 /= DADCMISMATCHLOOP;
 544   1          gADCMismatchAvgVal.wGainVal_Rch1 /= DADCMISMATCHLOOP;
 545   1          gADCMismatchAvgVal.wGainVal_Gch0 /= DADCMISMATCHLOOP;
 546   1          gADCMismatchAvgVal.wGainVal_Gch1 /= DADCMISMATCHLOOP;
 547   1          gADCMismatchAvgVal.wGainVal_Bch0 /= DADCMISMATCHLOOP;
 548   1          gADCMismatchAvgVal.wGainVal_Bch1 /= DADCMISMATCHLOOP;
 549   1      
 550   1          // Restrict mismatch gain couldn't less than 0.94. otherwise it will make iclamp engine unstable
 551   1          // The maxi code is 1023, the middle point is 512 and iclamp code is 32
 552   1          // Input signal will be (1)-512 (2) x mismatch gain (3) +512, 
 553   1          // if input signal less than iclamp code, iclamp engine will be charge and discharge iteratively then 
             -makes engine crash
 554   1          // so 32/512 = 0.0625, mismatch gain must be large than (1-0.0625), that is 0.94 = 0x3C2
 555   1          gADCMismatchAvgVal.wGainVal_Rch0 = (gADCMismatchAvgVal.wGainVal_Rch0 > 0x3C2) ? gADCMismatchAvgVal.wGa
             -inVal_Rch0 : 0x3C2;
 556   1          gADCMismatchAvgVal.wGainVal_Rch1 = (gADCMismatchAvgVal.wGainVal_Rch1 > 0x3C2) ? gADCMismatchAvgVal.wGa
             -inVal_Rch1 : 0x3C2;
 557   1          gADCMismatchAvgVal.wGainVal_Gch0 = (gADCMismatchAvgVal.wGainVal_Gch0 > 0x3C2) ? gADCMismatchAvgVal.wGa
             -inVal_Gch0 : 0x3C2;
 558   1          gADCMismatchAvgVal.wGainVal_Gch1 = (gADCMismatchAvgVal.wGainVal_Gch1 > 0x3C2) ? gADCMismatchAvgVal.wGa
             -inVal_Gch1 : 0x3C2;
 559   1          gADCMismatchAvgVal.wGainVal_Bch0 = (gADCMismatchAvgVal.wGainVal_Bch0 > 0x3C2) ? gADCMismatchAvgVal.wGa
             -inVal_Bch0 : 0x3C2;
 560   1          gADCMismatchAvgVal.wGainVal_Bch1 = (gADCMismatchAvgVal.wGainVal_Bch1 > 0x3C2) ? gADCMismatchAvgVal.wGa
             -inVal_Bch1 : 0x3C2;
 561   1          
 562   1          // Set mismatch offset componsate code
 563   1          drvADC_Write2BytesMask(REG_ADC_ATOP_56_L, wRch0diff, 0x07FF); // Set ADC channel 0 offset compensated 
             -code
 564   1          drvADC_Write2BytesMask(REG_ADC_ATOP_57_L, wRch1diff, 0x07FF); // Set ADC channel 1 offset compensated 
             -code
 565   1          drvADC_Write2BytesMask(REG_ADC_ATOP_75_L, gADCMismatchAvgVal.wPivot_Rch, 0x03FF); // Set ADCR pivot-po
             -int value, choose minimum one
 566   1          drvADC_Write2BytesMask(REG_ADC_ATOP_5A_L, wGch0diff, 0x07FF); // Set ADC channel 0 offset compensated 
             -code
 567   1          drvADC_Write2BytesMask(REG_ADC_ATOP_5B_L, wGch1diff, 0x07FF); // Set ADC channel 1 offset compensated 
             -code
 568   1          drvADC_Write2BytesMask(REG_ADC_ATOP_76_L, gADCMismatchAvgVal.wPivot_Gch, 0x03FF); // Set ADCG pivot-po
             -int value, choose minimum one
 569   1          drvADC_Write2BytesMask(REG_ADC_ATOP_5E_L, wBch0diff, 0x07FF); // Set ADC channel 0 offset compensated 
             -code
 570   1          drvADC_Write2BytesMask(REG_ADC_ATOP_5F_L, wBch1diff, 0x07FF); // Set ADC channel 1 offset compensated 
             -code
 571   1          drvADC_Write2BytesMask(REG_ADC_ATOP_77_L, gADCMismatchAvgVal.wPivot_Bch, 0x03FF); // Set ADCB pivot-po
             -int value, choose minimum one
 572   1          // Set mismatch gain componsate code
 573   1          drvADC_Write2BytesMask(REG_ADC_ATOP_58_L, gADCMismatchAvgVal.wGainVal_Rch0, 0x07FF); // Set ADC channe
             -l 0 gain compensated code
 574   1          drvADC_Write2BytesMask(REG_ADC_ATOP_59_L, gADCMismatchAvgVal.wGainVal_Rch1, 0x07FF); // Set ADC channe
             -l 1 gain compensated code
 575   1          drvADC_Write2BytesMask(REG_ADC_ATOP_5C_L, gADCMismatchAvgVal.wGainVal_Gch0, 0x07FF); // Set ADC channe
             -l 0 gain compensated code
 576   1          drvADC_Write2BytesMask(REG_ADC_ATOP_5D_L, gADCMismatchAvgVal.wGainVal_Gch1, 0x07FF); // Set ADC channe
             -l 1 gain compensated code
 577   1          drvADC_Write2BytesMask(REG_ADC_ATOP_60_L, gADCMismatchAvgVal.wGainVal_Bch0, 0x07FF); // Set ADC channe
C51 COMPILER V9.01   DRVADC                                                                03/09/2023 15:39:15 PAGE 11  

             -l 0 gain compensated code
 578   1          drvADC_Write2BytesMask(REG_ADC_ATOP_61_L, gADCMismatchAvgVal.wGainVal_Bch1, 0x07FF); // Set ADC channe
             -l 1 gain compensated code
 579   1      
 580   1      #if 1
 581   1          ADC_DPUTSTR("\nAverage result:\n");
 582   1          ADC_DPRINTF("R Ch0 offset code= 0x%x", wRch0diff);
 583   1          ADC_DPRINTF("R Ch1 offset code= 0x%x", wRch1diff);
 584   1          ADC_DPRINTF("R Pivot-point= 0x%x", gADCMismatchAvgVal.wPivot_Rch);
 585   1          ADC_DPRINTF("G Ch0 offset code= 0x%x", wGch0diff);
 586   1          ADC_DPRINTF("G Ch1 offset code= 0x%x", wGch1diff);
 587   1          ADC_DPRINTF("G Pivot-point= 0x%x", gADCMismatchAvgVal.wPivot_Gch);
 588   1          ADC_DPRINTF("B Ch0 offset code= 0x%x", wBch0diff);
 589   1          ADC_DPRINTF("B Ch1 offset code= 0x%x", wBch1diff);
 590   1          ADC_DPRINTF("B Pivot-point= 0x%x \n", gADCMismatchAvgVal.wPivot_Bch);
 591   1      
 592   1          ADC_DPRINTF("R Ch0 gain code= 0x%x", gADCMismatchAvgVal.wGainVal_Rch0);
 593   1          ADC_DPRINTF("R Ch1 gain code= 0x%x", gADCMismatchAvgVal.wGainVal_Rch1);
 594   1          ADC_DPRINTF("G Ch0 gain code= 0x%x", gADCMismatchAvgVal.wGainVal_Gch0);
 595   1          ADC_DPRINTF("G Ch1 gain code= 0x%x", gADCMismatchAvgVal.wGainVal_Gch1);
 596   1          ADC_DPRINTF("B Ch0 gain code= 0x%x", gADCMismatchAvgVal.wGainVal_Bch0);
 597   1          ADC_DPRINTF("B Ch1 gain code= 0x%x", gADCMismatchAvgVal.wGainVal_Bch1);
 598   1      #endif
 599   1      }
 600          
 601          #if 0 // wait for re-manege
              //**************************************************************************
              //  [Function Name]:
              //                  drvADC_AutoPhaseAdjustment()
              //  [Description]
              //                  Do ADC good phase adjustment
              //  [Arguments]:
              //                  vsyncTime: frame rate of the current input
              //  [Return]:
              //                  TRUE: done, FALSE: fail
              //**************************************************************************
              Bool drvADC_AutoPhaseAdjustment(BYTE u8VSyncTime)
              {
                  BYTE u8AdjPhase, i;
              
                  ADC_DPUTSTR("drvADC_AutoPhaseAdjustment\n");
              #if (DADCWORSTPHASE)
              {
                  BYTE worsePhase, worsePhase2;
                  DWORD mincksum, cksum;
              
                  mincksum=0xFFFFFFFFul;
                  for (u8AdjPhase=0; u8AdjPhase<0x80; u8AdjPhase+=7)
                  {
                      drvADC_SetPhaseCode(u8AdjPhase);
                      Delay1ms(u8VSyncTime);
                      drvADC_WaitAutoStatusReady(SC0_8B, BIT1);
                      cksum=msRead2Byte(SC0_8E);
                      cksum=(cksum<<16)|msRead2Byte(SC0_8C);
                      if (cksum<mincksum)
                      {
                          mincksum=cksum;
                          worsePhase=u8AdjPhase;
                      }
                      if (CheckSyncLoss())//||CheckPowerKeyStatus())
                          return FALSE;
                  }
C51 COMPILER V9.01   DRVADC                                                                03/09/2023 15:39:15 PAGE 12  

                  //  printData("coast phase %d", bestPhase);
                  // 2nd Search
                  if (worsePhase<7)
                      worsePhase=(worsePhase+127)%0x80; // 128-7
                  else
                      worsePhase-=7;
                  mincksum=0xFFFFFFFFul;
                  for (u8AdjPhase=worsePhase; u8AdjPhase<worsePhase+10; u8AdjPhase++)
                  {
                      i=u8AdjPhase%0x80;
                      drvADC_SetPhaseCode(i);
                      Delay1ms(u8VSyncTime);
                      drvADC_WaitAutoStatusReady(SC0_8B, BIT1);
                      cksum=msRead2Byte(SC0_8E);
                      cksum=(cksum<<16)|msRead2Byte(SC0_8C);
                      if (cksum<mincksum)
                      {
                          mincksum=cksum;
                          worsePhase2=i;
                      }
                      if (CheckSyncLoss())//||CheckPowerKeyStatus())
                          return FALSE;
                  }
                  u8AdjPhase=(worsePhase2+63)%0x80;
                  #define FINAL_PHASE u8AdjPhase
              }
              #else
              {
                  BYTE bestPhase, bestPhase2;
                  DWORD maxcksum, cksum;
              
                  maxcksum=0;
                  for (u8AdjPhase=0; u8AdjPhase<0x80; u8AdjPhase+=7)
                  {
                      drvADC_SetPhaseCode(u8AdjPhase);
                      ForceDelay1ms(u8VSyncTime);
                      drvADC_WaitAutoStatusReady(SC0_8B, BIT1);
                      cksum=msRead2Byte(SC0_8E);
                      cksum=(cksum<<16)|msRead2Byte(SC0_8C);
                      if (cksum>maxcksum)
                      {
                          maxcksum=cksum;
                          bestPhase=u8AdjPhase;
                      }
                      if (CheckSyncLoss())//||CheckPowerKeyStatus())
                          return FALSE;
                  }
                  //  printData("coast phase %d", bestPhase);
                  // 2nd Search
                  if (bestPhase<7)
                      bestPhase=(bestPhase+121)%0x80; // 128-7
                  else
                      bestPhase-=7;
                  maxcksum=0;
                  for (u8AdjPhase=bestPhase; u8AdjPhase<bestPhase+10; u8AdjPhase++)
                  {
                      i=u8AdjPhase%0x80;
                      drvADC_SetPhaseCode(i);
                      ForceDelay1ms(u8VSyncTime);
                      drvADC_WaitAutoStatusReady(SC0_8B, BIT1);
                      cksum=msRead2Byte(SC0_8E);
                      cksum=(cksum<<16)|msRead2Byte(SC0_8C);
C51 COMPILER V9.01   DRVADC                                                                03/09/2023 15:39:15 PAGE 13  

                      if (cksum>maxcksum)
                      {
                          maxcksum=cksum;
                          bestPhase2=i;
                      }
                      if (CheckSyncLoss())//||CheckPowerKeyStatus())
                          return FALSE;
                  }
                  u8AdjPhase=bestPhase2;
                  #define FINAL_PHASE u8AdjPhase
              }
              #endif // DADCWORSTPHASE
              
                  drvADC_SetPhaseCode(FINAL_PHASE);
                  ADC_DPRINTF("final phase %d", FINAL_PHASE);
                  //UPPHASE_SET_BY_REAL_VALUE(FINAL_PHASE);
                  #undef FINAL_PHASE
                  return TRUE;
              }
              #endif
 720          //**************************************************************************
 721          //  [Function Name]:
 722          //                  drvADC_AutoAdcColor()
 723          //  [Description]
 724          //                  Do the ADC auto color adjustment
 725          //  [Arguments]:
 726          //                  vsyncTime: frame rate of the current input
 727          //  [Return]:
 728          //                  TRUE: done, FALSE: fail
 729          //**************************************************************************
 730          Bool drvADC_AutoAdcColor(BYTE u8VSyncTime)
 731          {
 732   1          BYTE xdata result;
 733   1          BYTE xdata u8AdcPgaGain;
 734   1      
 735   1          if (!(CURRENT_INPUT_IS_VGA()))//(SrcInputType!=Input_ANALOG)
 736   1              return FALSE;
 737   1      
 738   1          ADC_DPUTSTR("drvADC_AutoAdcColor\n");
 739   1          //drvADC_SetPGAGainCode(0);
 740   1          //if(USER_PREF_INPUT_COLOR_FORMAT==INPUT_COLOR_YPBPR) //YPbPr or YUV_H+V
 741   1          //    drvADC_SetRGBOffsetCode(0x200, 0x40, 0x200);
 742   1          //else
 743   1               drvADC_SetRGBOffsetCode(0x800-OffsetValue, 0x800-OffsetValue, 0x800-OffsetValue);
 744   1           //   drvADC_SetRGBOffsetCode(0, 0, 0);
 745   1          drvADC_SetRGBGainCode(0x421, 0x421, 0x421);
 746   1      
 747   1          msWriteByte(SC0_78, 0x01); // enable auto Gain
 748   1          u8AdcPgaGain=drvADC_CheckPGAGain(u8VSyncTime);
 749   1      
 750   1          result = drvADC_AutoAdjustAdcGain(u8VSyncTime);
 751   1      
 752   1          if(result)
 753   1          {
 754   2      #if ENABLE_AUTO_CLOLR_WITHOUT_INPUT
 755   2              FactoryAutoColorDone = 1;
 756   2      #endif
 757   2      
 758   2              UserPrefAdcPgaGain = u8AdcPgaGain;
 759   2              UserPrefAdcRedOffset = 0x800-OffsetValue;
 760   2              UserPrefAdcGreenOffset = 0x800-OffsetValue;
 761   2              UserPrefAdcBlueOffset = 0x800-OffsetValue;
C51 COMPILER V9.01   DRVADC                                                                03/09/2023 15:39:15 PAGE 14  

 762   2              drvADC_SetRGBOffsetCode(UserPrefAdcRedOffset, UserPrefAdcGreenOffset, UserPrefAdcBlueOffset);     
             -   
 763   2          }
 764   1          else
 765   1          {
 766   2              drvADC_SetPGAGainCode( UserPrefAdcPgaGain );
 767   2              drvADC_SetRGBGainCode(UserPrefAdcRedGain, UserPrefAdcGreenGain, UserPrefAdcBlueGain);
 768   2              drvADC_SetRGBOffsetCode(UserPrefAdcRedOffset, UserPrefAdcGreenOffset, UserPrefAdcBlueOffset);
 769   2          }
 770   1      
 771   1      /*    
 772   1          if (!result)
 773   1          {
 774   1              ADC_DPUTSTR( "Auto color failed !!");
 775   1              drvADC_SetPGAGainCode(UserPrefAdcPgaGain);
 776   1              drvADC_SetRGBGainCode(UserPrefAdcRedGain, UserPrefAdcGreenGain, UserPrefAdcBlueGain);
 777   1          }
 778   1          else
 779   1          {
 780   1              UserPrefAdcPgaGain=u8AdcPgaGain;
 781   1          }
 782   1      */    
 783   1          
 784   1          msWriteByte(SC0_78, 0); // disable auto Gain
 785   1      
 786   1          #if 0
                  ADC_DPRINTF("adc gain red 0x%x", USER_PREF_ADC_RED_GAIN);
                  ADC_DPRINTF("adc gain green 0x%x", USER_PREF_ADC_GREEN_GAIN);
                  ADC_DPRINTF("adc gain blue 0x%x", USER_PREF_ADC_BLUE_GAIN);
                  ADC_DPRINTF("adc gain PGA 0x%x", USER_PREF_ADC_PGA_GAIN);
                  #endif
 792   1      
 793   1          return result;
 794   1      }
 795          
 796          //**************************************************************************
 797          //  [Function Name]:
 798          //                  drvADC_SetupHsyncPolarity()
 799          //  [Description]
 800          //                  Setup Hsync polarity
 801          //  [Arguments]:
 802          //                  bActiveHigh: TRUE -> active high, FALSE: active low
 803          //  [Return]:
 804          //
 805          //**************************************************************************
 806          void drvADC_SetupHsyncPolarity(Bool IsActiveHigh)
 807          {
 808   1          drvADC_Write2BytesMask(REG_ADC_DTOP_07_L,(IsActiveHigh?BIT7:0),(BIT7));
 809   1      }
 810          //**************************************************************************
 811          //  [Function Name]:
 812          //                  drvADC_AdjustCalDuring()
 813          //  [Description]
 814          //                  Adjust ADC calibration during for specific reduced blanking timings
 815          //  [Arguments]:
 816          //                  u8CalDur: pixel
 817          //  [Return]:
 818          //
 819          //**************************************************************************
 820          void drvADC_AdjustCalDuring(BYTE u8CalDur)
 821          {
 822   1          drvADC_Write2BytesMask(REG_ADC_DTOP_18_L, u8CalDur, 0x00FF);
C51 COMPILER V9.01   DRVADC                                                                03/09/2023 15:39:15 PAGE 15  

 823   1      }
 824          
 825          //**************************************************************************
 826          //  [Function Name]:
 827          //                  drvADC_SetupADCLPF()
 828          //  [Description]
 829          //                  Setup ADC LPF
 830          //  [Arguments]:
 831          //                  val: 3dB bandwidth
 832          //                  - VGA(RGB(YUV)_H+V): Pixel Clock/1.2 < 3dB BW
 833          //                  - SOG(Sync on G or Y): Pixel Clock/2 < 3dB BW
 834          //  [Return]:
 835          //
 836          //**************************************************************************
 837          #if 0
              void drvADC_SetupADCLPF(ADCLPFBW_LIST val)
              {
                  // Bch: ATOP_23[3:0]: +, ATOP_23[7:4]: -
                  // Gch: ATOP_23[15:12]: +, ATOP_23[11:8]: -
                  // Rch: ATOP_24[3:0]: +, ATOP_24[7:4]: -
                  drvADC_Write2BytesMask(REG_ADC_ATOP_23_L, val<<12|val<<8|val<<4|val, 0xFFFF);
                  drvADC_Write2BytesMask(REG_ADC_ATOP_24_L, val<<4|val, 0x00FF);
              }
              #endif
 847          #if DADCPLLPROTECTION
 848          //**************************************************************************
 849          //  [Function Name]:
 850          //                  drvADC_SetModewithPLLProtection()
 851          //  [Description]
 852          //                  Mode changed with applying ADC PLL protection mechnism
 853          //  [Arguments]:
 854          //                  enADCInput: RGB / YPbPr
 855          //                  u16PixelClk: Input pixel clock(MHz)
 856          //                  htotal: Htotal -3
 857          //  [Return]:
 858          //                  TRUE: done, FALSE: fail
 859          //**************************************************************************
 860          Bool drvADC_SetModewithPLLProtection(ADC_INPUTSOURCE_TYPE enADCInput, WORD u16PixelClk, WORD u16HTotal)
 861          {
 862   1          Bool result;
 863   1          BYTE regval1, regval2;
 864   1      
 865   1          //ADC_DPUTSTR("drvADC_SetModewithPLLProtection\n");
 866   1          drvADC_IsEnableFreeRun(TRUE);
 867   1          drvADC_SetAutoProst(TRUE);
 868   1          drvADC_SetADCModeSetting(enADCInput, u16PixelClk);
 869   1          drvADC_SetAutoProst(FALSE);
 870   1          Delay1ms(1);
 871   1          drvADC_AdjustHTotal(u16HTotal);
 872   1          drvADC_IsEnableFreeRun(FALSE);
 873   1          Delay1ms(10); // PLL lock status would depend on input frequency, low frequency would take longer time
             - to lock
 874   1          regval1 = drvADC_ReadByte(REG_ADC_ATOP_0D_H);
 875   1          regval2 = drvADC_ReadByte(REG_ADC_DTOP_05_L);
 876   1          if(!(regval1 & 0x02) && (regval2 & 0x80))
 877   1          {
 878   2              result = TRUE;
 879   2          }
 880   1          else // 1st trial failed, wait 10msec to try 2nd round
 881   1          {
 882   2              //ADC_DPUTSTR("drvADC_SetModewithPLLProtection 1st failed\n");
 883   2              //ADC_DPRINTF("@@HV_flag = 0x%x", regval1);
C51 COMPILER V9.01   DRVADC                                                                03/09/2023 15:39:15 PAGE 16  

 884   2              //ADC_DPRINTF("@@PLL_flag = 0x%x", regval2);
 885   2              Delay1ms(10);
 886   2              drvADC_IsEnableFreeRun(TRUE);
 887   2              drvADC_SetAutoProst(TRUE);
 888   2              drvADC_SetADCModeSetting(enADCInput, u16PixelClk);
 889   2              drvADC_SetAutoProst(FALSE);
 890   2              Delay1ms(1);
 891   2              drvADC_AdjustHTotal(u16HTotal);
 892   2              drvADC_IsEnableFreeRun(FALSE);
 893   2              Delay1ms(10); // PLL lock status would depend on input frequency, low frequency would take longer 
             -time to lock
 894   2              regval1 = drvADC_ReadByte(REG_ADC_ATOP_0D_H);
 895   2              regval2 = drvADC_ReadByte(REG_ADC_DTOP_05_L);
 896   2              if(!(regval1 & 0x02) && (regval2 & 0x80))
 897   2              {
 898   3                  result = TRUE;
 899   3              }
 900   2              else
 901   2                  result = FALSE;
 902   2          }
 903   1      #if ENABLE_ADC_RESET 
 904   1          // ADC software reset for ฐชทลฅีซฬissue
 905   1          drvADC_Write2BytesMask(REG_ADC_ATOP_07_L, BIT0, BIT0);
 906   1          drvADC_Write2BytesMask(REG_ADC_ATOP_07_L, 0, BIT0);
 907   1          Delay1ms(2);
 908   1      #endif
 909   1          // trigger ADC phase dac alignment to avoid phase shift after DC off/on
 910   1          drvADC_Write2BytesMask(REG_ADC_ATOP_11_L, BIT8, BIT8);
 911   1          drvADC_Write2BytesMask(REG_ADC_ATOP_11_L, 0, BIT8);
 912   1          ADC_DPRINTF("drvADC_SetModewithPLLProtection result = %d\n", result);
 913   1          return result;
 914   1      }
 915          #endif //#ifdef DADCPLLPROTECTION
 916          
 917          #if _DGAIN_CAL_WITHOUT_INPUT_
 918          //**************************************************************************
 919          //  [Function Name]:
 920          //                  drvADC_ADCAutoGainCalwithoutInput()
 921          //  [Description]
 922          //                  Do ADC gain calibration without input
 923          //  [Arguments]:
 924          //
 925          //  [Return]:
 926          //
 927          //**************************************************************************
 928          void drvADC_ADCAutoGainCalwithoutInput(void)
 929          {
 930   1      #if DADCNEWGAINCALMETHOD == 1
              
                  UserPrefAdcRedGain  = 0x421;
                  UserPrefAdcGreenGain = 0x421;
                  UserPrefAdcBlueGain = 0x421;
                  drvADC_SetRGBGainCode(UserPrefAdcRedGain, UserPrefAdcGreenGain, UserPrefAdcBlueGain);
              
              #elif DADCNEWGAINCALMETHOD == 2
 938   1      
 939   1          #if (CHIP_ID == CHIP_TSUMF)
              
                  // Digital target gain: 1024/(1024-32)*PGA gain/0.7
                  // ADC PGA gain:
                  //  00: 1.0 / 01: 1.2 / 10: 0.8 / 11: 0.96
                  switch(UserPrefAdcPgaGain)
C51 COMPILER V9.01   DRVADC                                                                03/09/2023 15:39:15 PAGE 17  

                  {
                      case 0x00: // 1.474654
                                      UserPrefAdcRedGain = 1510 + ADC_GAIN_FIX_LUM_0;
                                      UserPrefAdcGreenGain = 1510 + ADC_GAIN_FIX_LUM_0;
                                      UserPrefAdcBlueGain = 1510 + ADC_GAIN_FIX_LUM_0;
                                      break;
                              case 0x15: // 1.769584
                                      UserPrefAdcRedGain = 1812 + ADC_GAIN_FIX_LUM_1;
                                      UserPrefAdcGreenGain = 1812 + ADC_GAIN_FIX_LUM_1;
                                      UserPrefAdcBlueGain = 1812 + ADC_GAIN_FIX_LUM_1;
                                      break;
                              case 0x2A: // 1.179723
                                      UserPrefAdcRedGain = 1208 + ADC_GAIN_FIX_LUM_2;
                                      UserPrefAdcGreenGain = 1208 + ADC_GAIN_FIX_LUM_2;
                                      UserPrefAdcBlueGain = 1208 + ADC_GAIN_FIX_LUM_2;
                                      break;
                              case 0x3F: // 1.415667
                                      UserPrefAdcRedGain = 1449 + ADC_GAIN_FIX_LUM_3;
                                      UserPrefAdcGreenGain = 1449 + ADC_GAIN_FIX_LUM_3;
                                      UserPrefAdcBlueGain = 1449 + ADC_GAIN_FIX_LUM_3;
                          break;
                      default:
                          break;
                  }
              
                  #else
 971   1          // Digital target gain: 1024/(1024-32)*PGA gain/0.7
 972   1          // ADC PGA gain:
 973   1          //  00: 0.861538 / 01: 0.969231 / 10: 1.076923 / 11: 1.184615
 974   1          switch(UserPrefAdcPgaGain)
 975   1          {
 976   2              case 0x00:
 977   2                              UserPrefAdcRedGain = 0x514 + ADC_GAIN_FIX_LUM_0;
 978   2                              UserPrefAdcGreenGain = 0x514 + ADC_GAIN_FIX_LUM_0;
 979   2                              UserPrefAdcBlueGain = 0x514 + ADC_GAIN_FIX_LUM_0;
 980   2                  break;
 981   2              case 0x15:
 982   2                              UserPrefAdcRedGain = 0x5B7 + ADC_GAIN_FIX_LUM_1;
 983   2                              UserPrefAdcGreenGain = 0x5B7 + ADC_GAIN_FIX_LUM_1;
 984   2                              UserPrefAdcBlueGain = 0x5B7 + ADC_GAIN_FIX_LUM_1;
 985   2                  break;
 986   2              case 0x2A:
 987   2                              UserPrefAdcRedGain = 0x65A + ADC_GAIN_FIX_LUM_2;
 988   2                              UserPrefAdcGreenGain = 0x65A + ADC_GAIN_FIX_LUM_2;
 989   2                              UserPrefAdcBlueGain = 0x65A + ADC_GAIN_FIX_LUM_2;
 990   2                  break;
 991   2              case 0x3F:
 992   2                              UserPrefAdcRedGain = 0x6FC + ADC_GAIN_FIX_LUM_3;
 993   2                              UserPrefAdcGreenGain = 0x6FC + ADC_GAIN_FIX_LUM_3;
 994   2                              UserPrefAdcBlueGain = 0x6FC + ADC_GAIN_FIX_LUM_3;
 995   2                  break;
 996   2              default:
 997   2                  break;
 998   2          }
 999   1      
1000   1      
1001   1          #endif // #if (CHIP_ID == CHIP_TSUMF)
1002   1          drvADC_SetRGBGainCode(UserPrefAdcRedGain, UserPrefAdcGreenGain, UserPrefAdcBlueGain);
1003   1      
1004   1      #else
              
                  // 1. backup ADC and Scaler related settings
C51 COMPILER V9.01   DRVADC                                                                03/09/2023 15:39:15 PAGE 18  

                  drvADC_BackupADCSetting();
                  drvADC_BackupScalerSetting();
              
                  // 2. Set free run clock at 720p
                  _msADC_MaskExternalSync(TRUE);
                  drvADC_SetFreeRunClock();
              
                  // 3. Enable scaler pattern generator to generate Hsync and Vsync for line buffer
                  drvADC_EnableScalerPG(E_PG_Htotal_256);
              
                  // 4. Set ADC input LPF to lowest bandwidth
                  drvADC_Write2BytesMask(REG_ADC_ATOP_23_L, 0xFFFF, 0xFFFF);
                  drvADC_Write2BytesMask(REG_ADC_ATOP_24_L, 0x00FF, 0x00FF);
              
                  // 5. Calibrate ADC R/G/B gain setting value
                  // Set R/G/B gain initial setting value at 0x0400
                  // 6. Gain calibration target value for RGB color space mode is 182 (8bit data) 255 * 0.5 / 0.7 = 182
                  // 7. Get the ADC digital output with Turn-On LDO and Set VCAL to 1.05v
                  // 8. Get the ADC digital output with VCAL to 0.55v
                  // 9. Calculate the difference between 1.05V and 0.55V of these 3 channels.
                  //    Compare the difference value with target value (182 at RGB color space) to adjust R/G/B channel 
             -gain register
                  drvADC_AutoGainAdjustment();
              
                  // 10. recover ADC and scaler related settings & turn off free run clock & turn off internal Vcal
                  _msADC_MaskExternalSync(FALSE);
                  drvADC_RecoverADCSetting();
                  drvADC_RecoverScalerSetting();
              
              #endif // #if DADCNEWGAINCALMETHOD
1036   1      }
1037          #endif
1038          
1039          #if _DGAIN_CAL_WITH_INPUT_
              //**************************************************************************
              //  [Function Name]:
              //                  drvADC_ADCAutoGainCalwithInput()
              //  [Description]
              //                  Do ADC gain calibration with input
              //  [Arguments]:
              //
              //  [Return]:
              //
              //**************************************************************************
              void drvADC_ADCAutoGainCalwithInput(void)
              {
                  WORD wStartAddress;
              
                  // 1. backup ADC and Scaler related settings
                  drvADC_BackupADCSetting();
                  drvADC_BackupScalerSetting();
              
                  // 2. Set free run clock at 720p
                  //drvADC_SetFreeRunClock();
              
                  // 3. Enable scaler pattern generator to generate Hsync and Vsync for line buffer
                  //drvADC_EnableScalerPG(E_PG_Htotal_256);
              
                  // 4. Set ADC input LPF to lowest bandwidth
                  drvADC_Write2BytesMask(REG_ADC_ATOP_23_L, 0xFFFF, 0xFFFF);
                  drvADC_Write2BytesMask(REG_ADC_ATOP_24_L, 0x00FF, 0x00FF);
                  drvADC_SetRGBOffsetCode(0, 0, 0);
C51 COMPILER V9.01   DRVADC                                                                03/09/2023 15:39:15 PAGE 19  

                  drvADC_SetRGBGainCode(0x421, 0x421, 0x421);
              
                  // Find the white pattern region in line buffer
                  wStartAddress = drvADC_FindWhiteRegion(0, 16);
                  // 5. Calibrate ADC R/G/B gain setting value
                  // Set R/G/B gain initial setting value at 0x0400
                  // 6. Gain calibration target value for RGB color space mode is 182 (8bit data) 255 * 0.5 / 0.7 = 182
                  // 7. Get the ADC digital output with Turn-On LDO and Set VCAL to 1.05v
                  // 8. Get the ADC digital output with VCAL to 0.55v
                  // 9. Calculate the difference between 1.05V and 0.55V of these 3 channels.
                  //    Compare the difference value with target value (182 at RGB color space) to adjust R/G/B channel 
             -gain register
                  drvADC_AutoGainAdjustment_WithInput(wStartAddress, 0, 32);
              
                  // 10. recover ADC and scaler related settings & turn off free run clock & turn off internal Vcal
                  drvADC_RecoverADCSetting();
                  drvADC_RecoverScalerSetting();
              }
              
              #endif
1087          
1088          //-------------------------------------------------------------------------------------------------
1089          //  Local Functions
1090          //-------------------------------------------------------------------------------------------------
1091          
1092          #if 0
              //**************************************************************************
              //  [Function Name]:
              //                  drvADC_Write2BytesMask()
              //  [Description]:
              //                  Load ADC driver table setting
              //  [Precondition]:
              //
              //  [Arguments]:
              //                 u16regadr : 16 bits register address
              //                 u16val : 16 bits register value
              //                 u16mask : 16 bits register mask
              //  [Return]:
              //
              //**************************************************************************
              static void drvADC_Write2BytesMask(WORD u16regadr, WORD u16val, WORD u16mask)
              {
              #if 1//CHIP_ID == CHIP_TSUMU
                  msWrite2ByteMask( u16regadr, u16val, u16mask );
              #else
              
                  BYTE ucBank, ucCurBank, ucCurReg;
              
                  ucBank = mStar_ReadByte(REGBK); // backup bank
              
                  ucCurBank = (BYTE)(u16regadr >> 8);
                  ucCurReg = (BYTE)(u16regadr & 0xFF);
              
                  if(ucCurBank != ucBank)
                      mStar_WriteByte(REGBK, ucCurBank);
              
                  if(u16mask & 0x00FF)
                      mStar_WriteByteMask(ucCurReg, (BYTE)(u16val&0xFF), (BYTE)(u16mask&0xFF));
                  if(u16mask & 0xFF00)
                      mStar_WriteByteMask(ucCurReg+1, (BYTE)(u16val>>8), (BYTE)(u16mask>>8));
              
                  mStar_WriteByte(REGBK, ucBank);        // Switch to Original bank
C51 COMPILER V9.01   DRVADC                                                                03/09/2023 15:39:15 PAGE 20  

              #endif
              }
              #endif
1132          #if 0
              //**************************************************************************
              //  [Function Name]:
              //                  drvADC_ReadByte()
              //  [Description]:
              //                  Read ADC register value
              //  [Precondition]:
              //
              //  [Arguments]:
              //                 u16regadr : 16 bits register address
              //  [Return]:
              //                 register value(1 byte)
              //**************************************************************************
              static BYTE drvADC_ReadByte(WORD u16regadr)
              {
              #if 1//CHIP_ID == CHIP_TSUMU
                  return msReadByte( u16regadr );
              #else
              
                  BYTE ucBank, ucCurBank, ucCurReg, retval;
              
                  ucBank = mStar_ReadByte(REGBK); // backup bank
              
                  ucCurBank = (BYTE)(u16regadr >> 8);
                  ucCurReg = (BYTE)(u16regadr & 0xFF);
              
                  if(ucCurBank != ucBank)
                      mStar_WriteByte(REGBK, ucCurBank);
                  retval = mStar_ReadByte(ucCurReg);
              
                  mStar_WriteByte(REGBK, ucBank);        // Switch to Original bank
              
                  return retval;
              #endif
              }
              #endif
1168          //**************************************************************************
1169          //  [Function Name]:
1170          //                  drvADC_WaitAutoStatusReady()
1171          //  [Description]:
1172          //                  Wait ready bit is ready
1173          //  [Precondition]:
1174          //
1175          //  [Arguments]:
1176          //                 regAddr: 16 bit register address
1177          //                 regFlag: Ready bit
1178          //  [Return]:
1179          //
1180          //**************************************************************************
1181          BYTE drvADC_WaitAutoStatusReady(WORD regAddr, BYTE regFlag)
1182          {
1183   1      #if 0
                  WORD waits=5000; // MCU 1x: 1500, 2x:3000, 3x: 4500
                  while (waits-- && !(mStar_ReadByte(regAddr)&regFlag));
              #else
1187   1          BYTE u8Value;
1188   1          //TimeOutCounter=50;// 50 msec, at least two frames
1189   1          SetTimOutConter(50);
1190   1          while( bTimeOutCounterFlag && !( (u8Value=msReadByte( regAddr ))&regFlag ) );
C51 COMPILER V9.01   DRVADC                                                                03/09/2023 15:39:15 PAGE 21  

1191   1      #endif
1192   1          //ADC_DPRINTF("drvADC_WaitAutoStatusReady= %d\n", u8Delay);
1193   1          return u8Value;
1194   1      }
1195          
1196          //**************************************************************************
1197          //  [Function Name]:
1198          //                  Hal_ADC_LoadTable()
1199          //  [Description]:
1200          //                  Load ADC driver table setting
1201          //  [Precondition]:
1202          //
1203          //  [Arguments]:
1204          //                 pTab_info
1205          //  [Return]:
1206          //
1207          //**************************************************************************
1208          static void drvADC_LoadTable(TAB_Info* pTab_info)
1209          {
1210   1          WORD xdata i, u16Addr;
1211   1          BYTE xdata u8Mask, u8Value, u8DoNotSet;
1212   1      
1213   1          if (pTab_info->pTable == NULL || pTab_info->u8TabRows == 0 || pTab_info->u8TabRows == 1)
1214   1              return;
1215   1      
1216   1          if (REG_ADDR_SIZE+REG_MASK_SIZE+pTab_info->u8TabIdx*REG_DATA_SIZE >= pTab_info->u8TabCols)
1217   1          {
1218   2              ADC_DPUTSTR("Tab_info error\n");
1219   2              return;
1220   2          }
1221   1      
1222   1          for (i=0; i<pTab_info->u8TabRows-1; i++)
1223   1          {
1224   2               u16Addr =  (WORD)( (pTab_info->pTable[0]<<8) + pTab_info->pTable[1] );
1225   2      
1226   2               if(u16Addr == REG_ADC_DTOP_FE_L)
1227   2               {
1228   3                  // delay only, skip to write next register
1229   3                  u8Value = pTab_info->pTable[REG_ADDR_SIZE+REG_MASK_SIZE+pTab_info->u8TabIdx*REG_DATA_SIZE + 1]
             -;
1230   3                  //ADC_DPRINTF("ADC tbl delay (%d) ms \n",u8Value);
1231   3                  ForceDelay1ms(u8Value);
1232   3                  goto NEXT;
1233   3               }
1234   2      
1235   2               u8Mask  = pTab_info->pTable[2];
1236   2               u8DoNotSet = pTab_info->pTable[REG_ADDR_SIZE+REG_MASK_SIZE+pTab_info->u8TabIdx*REG_DATA_SIZE];
1237   2               u8Value = pTab_info->pTable[REG_ADDR_SIZE+REG_MASK_SIZE+pTab_info->u8TabIdx*REG_DATA_SIZE + 1];
1238   2      
1239   2               //printf("[addr=%06lx, msk=%02x, enb=%02x val=%02x]\n", u32Addr, u8Mask,u8DoNotSet, u8Value);
1240   2      
1241   2               if ( !u8DoNotSet )
1242   2               {
1243   3                  //ADC_DPUTSTR("@@ register value Mask = ");
1244   3                  //ADC_DPRINTF("0x%x", u16Addr);
1245   3                  //ADC_DPRINTF("0x%x", u8Value);
1246   3                  //ADC_DPRINTF("0x%x", u8Mask);
1247   3                  msWriteByteMask( u16Addr, u8Value, u8Mask );
1248   3               }
1249   2      NEXT:
1250   2               pTab_info->pTable+=pTab_info->u8TabCols; // next
1251   2          }
C51 COMPILER V9.01   DRVADC                                                                03/09/2023 15:39:15 PAGE 22  

1252   1      }
1253          
1254          //**************************************************************************
1255          //  [Function Name]:
1256          //                  drvADC_SetMux()
1257          //  [Description]
1258          //                  ADC set sync and data mux
1259          //  [Arguments]:
1260          //                  ipmux_type: sync / data
1261          //  [Return]:
1262          //
1263          //**************************************************************************
1264          static void drvADC_SetMux(ADC_MUX_TYPE ipmux_type)
1265          {
1266   1          TAB_Info Tab_info;
1267   1          Tab_info.pTable = (void*)MST_ADCMUX_TBL;
1268   1          Tab_info.u8TabCols = REG_ADDR_SIZE+REG_MASK_SIZE+ADC_TABLE_MUX_NUMS*REG_DATA_SIZE;
1269   1          Tab_info.u8TabRows = sizeof(MST_ADCMUX_TBL)/Tab_info.u8TabCols;
1270   1          Tab_info.u8TabIdx = ipmux_type;
1271   1      
1272   1          ADC_DPRINTF("ADC Tbl:set mux %d \n",ipmux_type);
1273   1          drvADC_LoadTable(&Tab_info);
1274   1      
1275   1      }
1276          
1277          //**************************************************************************
1278          //  [Function Name]:
1279          //                  drvADC_SearchFreqSetTableIndex()
1280          //  [Description]:
1281          //                  Search the Frequncy table index
1282          //  [Precondition]:
1283          //
1284          //  [Arguments]:
1285          //                 u16OriginalPixClk: xxxMHz
1286          //  [Return]:
1287          //
1288          //**************************************************************************
1289          static BYTE drvADC_SearchFreqSetTableIndex(WORD u16OriginalPixClk)
1290          {
1291   1          BYTE  u8ClkIndex;
1292   1      
1293   1          for(u8ClkIndex=0; u8ClkIndex<sizeof(MST_ADC_FreqRange_TBL)/sizeof(ADC_FREQ_RANGE); u8ClkIndex++)
1294   1          {
1295   2              if((u16OriginalPixClk < MST_ADC_FreqRange_TBL[u8ClkIndex].FreqHLimit) &&
1296   2                  (u16OriginalPixClk >= MST_ADC_FreqRange_TBL[u8ClkIndex].FreqLLimit))
1297   2                  break;
1298   2          }
1299   1      
1300   1          return u8ClkIndex;
1301   1      }
1302          
1303          
1304          //**************************************************************************
1305          //  [Function Name]:
1306          //                  drvADC_BackupADCSetting()
1307          //  [Description]:
1308          //                  Backup ADC settings
1309          //  [Precondition]:
1310          //
1311          //  [Arguments]:
1312          //
1313          //  [Return]:
C51 COMPILER V9.01   DRVADC                                                                03/09/2023 15:39:15 PAGE 23  

1314          //
1315          //**************************************************************************
1316          static void drvADC_BackupADCSetting(void)
1317          {
1318   1          memset(&gADCBackupSetting, 0, sizeof(gADCBackupSetting));
1319   1      #if ENABLE_XTAL_LESS
                  gADCBackupSetting.BWCoef = drvADC_ReadByte(REG_ADC_DTOP_02_L);
                  gADCBackupSetting.DampCoef = drvADC_ReadByte(REG_ADC_DTOP_03_L);
              #endif
1323   1          gADCBackupSetting.PLL_Ictrl = drvADC_ReadByte(REG_ADC_ATOP_09_H) & 0x03;
1324   1          gADCBackupSetting.PLL_Mult_Mod_216m = drvADC_ReadByte(REG_ADC_ATOP_0A_L) & 0x3F;
1325   1          gADCBackupSetting.LPF_Rch = drvADC_ReadByte(REG_ADC_ATOP_24_L) & 0x0F;
1326   1          gADCBackupSetting.LPF_Gch = drvADC_ReadByte(REG_ADC_ATOP_23_H) & 0x0F;
1327   1          gADCBackupSetting.LPF_Bch = drvADC_ReadByte(REG_ADC_ATOP_23_L) & 0x0F;
1328   1          gADCBackupSetting.Blacklevel_Rch = (drvADC_ReadByte(REG_ADC_DTOP_44_H) << 8 | drvADC_ReadByte(REG_ADC_
             -DTOP_44_L)) & 0x03FF;
1329   1          gADCBackupSetting.Blacklevel_Gch = (drvADC_ReadByte(REG_ADC_DTOP_47_H) << 8 | drvADC_ReadByte(REG_ADC_
             -DTOP_47_L)) & 0x03FF;
1330   1          gADCBackupSetting.Blacklevel_Bch = (drvADC_ReadByte(REG_ADC_DTOP_50_H) << 8 | drvADC_ReadByte(REG_ADC_
             -DTOP_50_L)) & 0x03FF;
1331   1          gADCBackupSetting.Offset_Rch = (drvADC_ReadByte(REG_ADC_DTOP_46_H) << 8 | drvADC_ReadByte(REG_ADC_DTOP
             -_46_L)) & 0x07FF;
1332   1          gADCBackupSetting.Offset_Gch = (drvADC_ReadByte(REG_ADC_DTOP_49_H) << 8 | drvADC_ReadByte(REG_ADC_DTOP
             -_49_L)) & 0x07FF;
1333   1          gADCBackupSetting.Offset_Bch = (drvADC_ReadByte(REG_ADC_DTOP_52_H) << 8 | drvADC_ReadByte(REG_ADC_DTOP
             -_52_L)) & 0x07FF;
1334   1      }
1335          
1336          //**************************************************************************
1337          //  [Function Name]:
1338          //                  drvADC_RecoverADCSetting()
1339          //  [Description]:
1340          //                  Recover ADC settings
1341          //  [Precondition]:
1342          //
1343          //  [Arguments]:
1344          //
1345          //  [Return]:
1346          //
1347          //**************************************************************************
1348          static void drvADC_RecoverADCSetting(void)
1349          {
1350   1          drvADC_Write2BytesMask(REG_ADC_ATOP_54_L, 0x0000, 0xFFFF);
1351   1          drvADC_Write2BytesMask(REG_ADC_DTOP_06_L, 0x0000, 0x0080); // PLL Frequency Force Disable
1352   1      #if ENABLE_XTAL_LESS
                  drvADC_Write2BytesMask(REG_ADC_DTOP_02_L, 0x0900|gADCBackupSetting.BWCoef, 0xFFFF);
                  drvADC_Write2BytesMask(REG_ADC_DTOP_03_L, gADCBackupSetting.DampCoef, 0xFFFF);
              #else
1356   1          drvADC_Write2BytesMask(REG_ADC_DTOP_02_L, 0x0982, 0xFFFF);
1357   1          drvADC_Write2BytesMask(REG_ADC_DTOP_03_L, 0x0005, 0xFFFF);
1358   1      #endif // #if ENABLE_XTAL_LESS
1359   1          drvADC_Write2BytesMask(REG_ADC_ATOP_0A_L, gADCBackupSetting.PLL_Mult_Mod_216m, 0x003F);
1360   1          drvADC_Write2BytesMask(REG_ADC_ATOP_09_L, gADCBackupSetting.PLL_Ictrl << 8, 0x0300);
1361   1          drvADC_Write2BytesMask(REG_ADC_ATOP_23_L, (gADCBackupSetting.LPF_Gch << 8)|gADCBackupSetting.LPF_Bch ,
             - 0x0F0F);
1362   1          drvADC_Write2BytesMask(REG_ADC_ATOP_24_L, gADCBackupSetting.LPF_Rch, 0x000F);
1363   1          drvADC_Write2BytesMask(REG_ADC_DTOP_44_L, gADCBackupSetting.Blacklevel_Rch, 0x03FF);
1364   1          drvADC_Write2BytesMask(REG_ADC_DTOP_47_L, gADCBackupSetting.Blacklevel_Gch, 0x03FF);
1365   1          drvADC_Write2BytesMask(REG_ADC_DTOP_50_L, gADCBackupSetting.Blacklevel_Bch, 0x03FF);
1366   1          drvADC_Write2BytesMask(REG_ADC_DTOP_46_L, gADCBackupSetting.Offset_Rch, 0x07FF);
1367   1          drvADC_Write2BytesMask(REG_ADC_DTOP_49_L, gADCBackupSetting.Offset_Gch, 0x07FF);
1368   1          drvADC_Write2BytesMask(REG_ADC_DTOP_52_L, gADCBackupSetting.Offset_Bch, 0x07FF);
C51 COMPILER V9.01   DRVADC                                                                03/09/2023 15:39:15 PAGE 24  

1369   1      }
1370          
1371          //**************************************************************************
1372          //  [Function Name]:
1373          //                  drvADC_SetFreeRunClock()
1374          //  [Description]:
1375          //                  Set ADC free-run clock to 40MHz
1376          //  [Precondition]:
1377          //
1378          //  [Arguments]:
1379          //
1380          //  [Return]:
1381          //
1382          //**************************************************************************
1383          static void drvADC_SetFreeRunClock(void)
1384          {
1385   1          //drvADC_Write2BytesMask(REG_ADC_ATOP_01_L, 0x4001, 0xFFFF); // ADC enable
1386   1          //drvADC_Write2BytesMask(REG_ADC_ATOP_04_L, 0, 0xFFFF); // Turn on analog power down
1387   1          //drvADC_Write2BytesMask(REG_ADC_ATOP_06_L, 0, 0xFFFF); // Turn on gated
1388   1      #if 0
                  drvADC_Write2BytesMask(REG_ADC_ATOP_0A_L, 0x0008, 0x003F); // PLL_MULT = 0, DIV2_EN = 1'b1
                  drvADC_Write2BytesMask(REG_ADC_ATOP_09_L, 0x0300, 0x0300); // ADCPLL_ICTRL = 2'b11
                  drvADC_Write2BytesMask(REG_ADC_DTOP_02_L, 0xB82E, 0xFFFF);
                  drvADC_Write2BytesMask(REG_ADC_DTOP_03_L, 0x0052, 0xFFFF);
                  drvADC_Write2BytesMask(REG_ADC_DTOP_06_L, 0x0080, 0x0080); // PLL Frequency Force Enable
              #else // revise the correct free-run 40MHz setting
1395   1          drvADC_Write2BytesMask( REG_ADC_ATOP_0A_L, 0x0010, 0x003F ); // [5]:DIV2_EN = 1'b0, [4:3]:APLL_MOD=2'b
             -10, [2:0]: APLL_MULT = 0
1396   1      #if ((CHIP_ID == CHIP_TSUMC) || (CHIP_ID == CHIP_TSUMD) || (CHIP_ID == CHIP_TSUM9 )|| (CHIP_ID == CHIP_TSU
             -MF))
1397   1          drvADC_Write2BytesMask( REG_ADC_ATOP_09_L, 0x0200, 0x0700 ); // ADCPLL_ICTRL = 2'b010
1398   1      #else
                  drvADC_Write2BytesMask( REG_ADC_ATOP_09_L, 0x0200, 0x0300 ); // ADCPLL_ICTRL = 2'b10
              #endif // #if (CHIP_ID == CHIP_TSUMC)
1401   1          drvADC_Write2BytesMask( REG_ADC_DTOP_02_L, 0x6656, 0xFFFF );
1402   1          drvADC_Write2BytesMask( REG_ADC_DTOP_03_L, 0x0066, 0xFFFF );
1403   1          drvADC_Write2BytesMask( REG_ADC_DTOP_06_L, 0x0080, 0x0080 ); // PLL Frequency Force Enable
1404   1      #endif
1405   1      }
1406          
1407          
1408          #if (CHIP_ID == CHIP_TSUMD || (CHIP_ID == CHIP_TSUM9 )|| (CHIP_ID == CHIP_TSUMF ))
              //**************************************************************************
              //  [Function Name]:
              //                  drvADC_MismatchOffsetCal()
              //  [Description]:
              //                  ADC mismatch offset calibration
              //  [Precondition]:
              //
              //  [Arguments]:
              //
              //  [Return]:
              //
              //**************************************************************************
              static void drvADC_MismatchLinearityCal(void)
              {
                  //TimeOutCounter = 10; // 10 msec
              
                      SetTimOutConter(10);// Set Vcal 
                  //drvADC_Write2BytesMask(REG_ADC_ATOP_54_L, 0xF800, 0xF800); // [15]:ADC VCAL force enable, [14:11]: s
             -et Vcal
                  drvADC_Write2BytesMask(REG_ADC_ATOP_54_L, 0xF600, 0xFF00); // [15]:ADC VCAL force enable, [14:11]: set
C51 COMPILER V9.01   DRVADC                                                                03/09/2023 15:39:15 PAGE 25  

             - Vcal, [10:8]: 3'b 110, reg_rgb_self_gcal_pulse_sw
              
                  do
                  {
                      // Enable linearity calibration
                      drvADC_Write2BytesMask(REG_ADC_DTOP_66_L, 0, 0x0070); // [6:4]: Enable linearity calibration for R
             -/G/B
                      drvADC_Write2BytesMask(REG_ADC_DTOP_66_L, 0x0070, 0x0070); // [6:4]: Enable linearity calibration 
             -for R/G/B
                      // Trigger
                      drvADC_Write2BytesMask(REG_ADC_DTOP_68_L, 0x0000, 0x0700); // [10:8]: Rising trigger for R/G/B (Au
             -to/Manual mode)
                      drvADC_Write2BytesMask(REG_ADC_DTOP_68_L, 0x0700, 0x0700); // [10:8]: Rising trigger for R/G/B (Au
             -to/Manual mode)
                      drvADC_Write2BytesMask(REG_ADC_DTOP_68_L, 0x0000, 0x0700); // [10:8]: Rising trigger for R/G/B (Au
             -to/Manual mode)
                      // wait done
                      ForceDelay1ms(1);
                  } while( bTimeOutCounterFlag && ((drvADC_ReadByte(REG_ADC_DTOP_69_H) & 0x70) != 0x70) ); // [14:12]: l
             -inearity calibration done
                  // Set Vcal 
                  //drvADC_Write2BytesMask(REG_ADC_ATOP_54_L, 0, 0xF800); // [15]:ADC VCAL force enable, [14:11]: set Vc
             -al
                  drvADC_Write2BytesMask(REG_ADC_ATOP_54_L, 0, 0xFF00); // [15]:ADC VCAL force enable, [14:11]: set Vcal
             -, [10:8]: 3'b 110, reg_rgb_self_gcal_pulse_sw
              
              #if 0
                  if((drvADC_ReadByte(REG_ADC_DTOP_69_H) & 0x70) == 0x70)
                  {
                      ADC_DPRINTF("@@ L_T= %d\n", TimeOutCounter);
                      ADC_DPRINTF("@@ ADC R_ACCU_CH0 = 0x%x\n", msRead2Byte(REG_ADC_DTOP_6A_L));
                      ADC_DPRINTF("@@ ADC R_ACCU_CH1 = 0x%x\n", msRead2Byte(REG_ADC_DTOP_6B_L));
                      ADC_DPRINTF("@@ ADC G_ACCU_CH0 = 0x%x\n", msRead2Byte(REG_ADC_DTOP_6C_L));
                      ADC_DPRINTF("@@ ADC G_ACCU_CH1 = 0x%x\n", msRead2Byte(REG_ADC_DTOP_6D_L));
                      ADC_DPRINTF("@@ ADC B_ACCU_CH0 = 0x%x\n", msRead2Byte(REG_ADC_DTOP_6E_L));
                      ADC_DPRINTF("@@ ADC B_ACCU_CH1 = 0x%x\n", msRead2Byte(REG_ADC_DTOP_6F_L));
                  }
              #endif
              }
              #endif // #if (CHIP_ID == CHIP_TSUMD)
1459          
1460          //**************************************************************************
1461          //  [Function Name]:
1462          //                  drvADC_MismatchOffsetCal()
1463          //  [Description]:
1464          //                  ADC mismatch offset calibration
1465          //  [Precondition]:
1466          //
1467          //  [Arguments]:
1468          //
1469          //  [Return]:
1470          //
1471          //**************************************************************************
1472          static void drvADC_MismatchOffsetCal(void)
1473          {
1474   1          WORD xdata wTimeOutCnt = 300;
1475   1          WORD xdata wRch0val, wRch1val, wGch0val, wGch1val, wBch0val, wBch1val;
1476   1          WORD xdata wRch0diff, wRch1diff, wGch0diff, wGch1diff, wBch0diff, wBch1diff;
1477   1          WORD xdata wRchPivot, wGchPivot, wBchPivot;
1478   1      
1479   1          // 1. Turn on ADC offset calibration pluse
1480   1          drvADC_Write2BytesMask(REG_ADC_ATOP_54_L, 0x0030, 0x0030);
C51 COMPILER V9.01   DRVADC                                                                03/09/2023 15:39:15 PAGE 26  

1481   1      
1482   1          // 2. Enable ADC data low Vcal accumulator
1483   1          drvADC_Write2BytesMask(REG_ADC_ATOP_55_L, 0x0080, 0x0080);
1484   1      
1485   1          ForceDelay1ms(1); // delay 1 msec
1486   1      
1487   1          // 3. Trigger ADC data low Vcal accumulator start
1488   1          drvADC_Write2BytesMask(REG_ADC_ATOP_55_L, 0x0100, 0x0100);
1489   1      
1490   1          // 4. Wait ADC data accumulation done, ADC_ATO_74_L[2:0] = 3'b 111
1491   1          while ((wTimeOutCnt>0) && (!(drvADC_ReadByte(REG_ADC_ATOP_74_L) & 0x07)))
1492   1          {
1493   2              wTimeOutCnt--;
1494   2          }
1495   1          if(wTimeOutCnt == 0)
1496   1              ADC_DPUTSTR("ADC data accumulation time out\n");
1497   1      
1498   1          // 5. Read ADC channel 0 & 1 average value
1499   1          wRch0val = ((drvADC_ReadByte(REG_ADC_ATOP_62_H)&0x03) << 8) | drvADC_ReadByte(REG_ADC_ATOP_62_L);
1500   1          wRch1val = ((drvADC_ReadByte(REG_ADC_ATOP_65_H)&0x03) << 8) | drvADC_ReadByte(REG_ADC_ATOP_65_L);
1501   1          wGch0val = ((drvADC_ReadByte(REG_ADC_ATOP_68_H)&0x03) << 8) | drvADC_ReadByte(REG_ADC_ATOP_68_L);
1502   1          wGch1val = ((drvADC_ReadByte(REG_ADC_ATOP_6B_H)&0x03) << 8) | drvADC_ReadByte(REG_ADC_ATOP_6B_L);
1503   1          wBch0val = ((drvADC_ReadByte(REG_ADC_ATOP_6E_H)&0x03) << 8) | drvADC_ReadByte(REG_ADC_ATOP_6E_L);
1504   1          wBch1val = ((drvADC_ReadByte(REG_ADC_ATOP_71_H)&0x03) << 8) | drvADC_ReadByte(REG_ADC_ATOP_71_L);
1505   1      
1506   1      #if 0
                  // Aaron test
                  wRch0val = 2000;
                  wRch1val = 1889;
                  wGch0val = 1776;
                  wGch1val = 1888;
                  wBch0val = 2;
                  wBch1val = 400;
              #endif
1515   1      
1516   1          // 6. Set ADC compensated codes and Pivot-point value
1517   1          // R-ch
1518   1          if(wRch0val > wRch1val)
1519   1          {
1520   2              wRch0diff = (WORD)(wRch1val-wRch0val); // negative number, 2's complement
1521   2              wRch1diff = 0x0000;
1522   2              wRchPivot = wRch1val; // minimum one
1523   2          }
1524   1          else if (wRch0val < wRch1val)
1525   1          {
1526   2              wRch0diff = 0x0000;
1527   2              wRch1diff = (WORD)(wRch0val-wRch1val); // negative number, 2's complement
1528   2              wRchPivot = wRch0val; // minimum one
1529   2          }
1530   1          else // wRch0val = wRch1val
1531   1          {
1532   2              wRch0diff = 0x0000;
1533   2              wRch1diff = 0x0000;
1534   2              wRchPivot = wRch0val;
1535   2          }
1536   1          // G-ch
1537   1          if(wGch0val > wGch1val)
1538   1          {
1539   2              wGch0diff = (WORD)(wGch1val-wGch0val); // negative number, 2's complement
1540   2              wGch1diff = 0x0000;
1541   2              wGchPivot = wGch1val; // minimum one
1542   2          }
C51 COMPILER V9.01   DRVADC                                                                03/09/2023 15:39:15 PAGE 27  

1543   1          else if (wGch0val < wGch1val)
1544   1          {
1545   2              wGch0diff = 0x0000;
1546   2              wGch1diff = (WORD)(wGch0val-wGch1val); // negative number, 2's complement
1547   2              wGchPivot = wGch0val; // minimum one
1548   2          }
1549   1          else // wGch0val = wGch1val
1550   1          {
1551   2              wGch0diff = 0x0000;
1552   2              wGch1diff = 0x0000;
1553   2              wGchPivot = wGch0val;
1554   2          }
1555   1          // B-ch
1556   1          if(wBch0val > wBch1val)
1557   1          {
1558   2              wBch0diff = (WORD)(wBch1val-wBch0val); // negative number, 2's complement
1559   2              wBch1diff = 0x0000;
1560   2              wBchPivot = wBch1val; // minimum one
1561   2          }
1562   1          else if (wBch0val < wBch1val)
1563   1          {
1564   2              wBch0diff = 0x0000;
1565   2              wBch1diff = (WORD)(wBch0val-wBch1val); // negative number, 2's complement
1566   2              wBchPivot = wBch0val; // minimum one
1567   2          }
1568   1          else // wBch0val = wBch1val
1569   1          {
1570   2              wBch0diff = 0x0000;
1571   2              wBch1diff = 0x0000;
1572   2              wBchPivot = wBch0val;
1573   2          }
1574   1      
1575   1          gADCMismatchAvgVal.wOffsetVal_Rch0  += wRch0val;
1576   1          gADCMismatchAvgVal.wOffsetVal_Rch1  += wRch1val;
1577   1          gADCMismatchAvgVal.wPivot_Rch       += wRchPivot;
1578   1          gADCMismatchAvgVal.wOffsetVal_Gch0  += wGch0val;
1579   1          gADCMismatchAvgVal.wOffsetVal_Gch1  += wGch1val;
1580   1          gADCMismatchAvgVal.wPivot_Gch       += wGchPivot;
1581   1          gADCMismatchAvgVal.wOffsetVal_Bch0  += wBch0val;
1582   1          gADCMismatchAvgVal.wOffsetVal_Bch1  += wBch1val;
1583   1          gADCMismatchAvgVal.wPivot_Bch       += wBchPivot;
1584   1      #if 0
                  drvADC_Write2BytesMask(REG_ADC_ATOP_56_L, wRch0diff, 0x07FF); // Set ADC channel 0 offset compensated 
             -code
                  drvADC_Write2BytesMask(REG_ADC_ATOP_57_L, wRch1diff, 0x07FF); // Set ADC channel 1 offset compensated 
             -code
                  drvADC_Write2BytesMask(REG_ADC_ATOP_75_L, wRchPivot, 0x03FF); // Set ADCR pivot-point value, choose mi
             -nimum one
                  drvADC_Write2BytesMask(REG_ADC_ATOP_5A_L, wGch0diff, 0x07FF); // Set ADC channel 0 offset compensated 
             -code
                  drvADC_Write2BytesMask(REG_ADC_ATOP_5B_L, wGch1diff, 0x07FF); // Set ADC channel 1 offset compensated 
             -code
                  drvADC_Write2BytesMask(REG_ADC_ATOP_76_L, wGchPivot, 0x03FF); // Set ADCG pivot-point value, choose mi
             -nimum one
                  drvADC_Write2BytesMask(REG_ADC_ATOP_5E_L, wBch0diff, 0x07FF); // Set ADC channel 0 offset compensated 
             -code
                  drvADC_Write2BytesMask(REG_ADC_ATOP_5F_L, wBch1diff, 0x07FF); // Set ADC channel 1 offset compensated 
             -code
                  drvADC_Write2BytesMask(REG_ADC_ATOP_77_L, wBchPivot, 0x03FF); // Set ADCB pivot-point value, choose mi
             -nimum one
              #endif
1595   1      #if 0
C51 COMPILER V9.01   DRVADC                                                                03/09/2023 15:39:15 PAGE 28  

                  ADC_DPRINTF("\nR Ch0 code= 0x%x", wRch0diff);
                  ADC_DPRINTF("R Ch1 code= 0x%x", wRch1diff);
                  ADC_DPRINTF("R Pivot-point= 0x%x", wRchPivot);
                  ADC_DPRINTF("G Ch0 code= 0x%x", wGch0diff);
                  ADC_DPRINTF("G Ch1 code= 0x%x", wGch1diff);
                  ADC_DPRINTF("G Pivot-point= 0x%x", wGchPivot);
                  ADC_DPRINTF("B Ch0 code= 0x%x", wBch0diff);
                  ADC_DPRINTF("B Ch1 code= 0x%x", wBch1diff);
                  ADC_DPRINTF("B Pivot-point= 0x%x \n", wBchPivot);
              #endif
1606   1          // 7. Turn on enable offset mismatch compensated codes
1607   1          drvADC_Write2BytesMask(REG_ADC_ATOP_55_L, 0x0015, 0x0095); // [7]: acc low disable, [4]: B mismatch of
             -fset enable, [2]: G mismatch offset enable, [0]: R mismatch offset enable,
1608   1      
1609   1          // 8. Turn off ADC offset calibration pulse
1610   1          drvADC_Write2BytesMask(REG_ADC_ATOP_54_L, 0x0000, 0x0030);
1611   1      }
1612          
1613          //**************************************************************************
1614          //  [Function Name]:
1615          //                  drvADC_MismatchGainCal()
1616          //  [Description]:
1617          //                  ADC mismatch gain calibration
1618          //  [Precondition]:
1619          //
1620          //  [Arguments]:
1621          //
1622          //  [Return]:
1623          //
1624          //**************************************************************************
1625          static void drvADC_MismatchGainCal(void)
1626          {
1627   1          WORD xdata wTimeOutCnt = 300;
1628   1          WORD xdata wRch0val, wRch1val, wGch0val, wGch1val, wBch0val, wBch1val;
1629   1          WORD xdata wRch0Div, wRch1Div, wGch0Div, wGch1Div, wBch0Div, wBch1Div;
1630   1      #if DADCNEWGAINCALMETHOD
1631   1          WORD wTargetCode;
1632   1      #endif
1633   1      
1634   1          // 1. Turn on LDO & select VCAL 1.05V, Turn on ADC gain calibration pulse
1635   1      #if DADCCALBYBANDGAP
1636   1          drvADC_Write2BytesMask(REG_ADC_ATOP_34_L, 0, BIT0); // turn off LDO
1637   1          drvADC_Write2BytesMask(REG_ADC_ATOP_34_L, 0, BIT2); // Bandgap
1638   1          drvADC_Write2BytesMask(REG_ADC_ATOP_54_L, 0, 0x000F); // disable LDO overwrite
1639   1          drvADC_Write2BytesMask(REG_ADC_ATOP_54_L, 0xF800, 0xF800); // [15]:ADC VCAL force enable, [14:11]: set
             - Vcal = 1.05V, 
1640   1      #else
                  drvADC_Write2BytesMask(REG_ADC_ATOP_34_L, BIT0, BIT0); // turn on LDO
                  drvADC_Write2BytesMask(REG_ADC_ATOP_34_L, BIT2, BIT2); // LDO
                  drvADC_Write2BytesMask(REG_ADC_ATOP_54_L, 0x0003, 0x0003); // set Vcal = 1.05V
                  drvADC_Write2BytesMask(REG_ADC_ATOP_54_L, 0x000C, 0x000C); // set Vcal from LDO
                  drvADC_Write2BytesMask(REG_ADC_ATOP_54_L, 0, 0xF800); // disable bandgap overwrite
              #endif // DADCCALBYBANDGAP
1647   1          // Turn on self Gcal pulse
1648   1          drvADC_Write2BytesMask(REG_ADC_ATOP_54_L, 0x0600, 0x0700); // [10:8]: 3'b 110, reg_rgb_self_gcal_pulse
             -_sw
1649   1      
1650   1          // 2. Enable ADC data high Vcal accumulator
1651   1          drvADC_Write2BytesMask(REG_ADC_ATOP_55_L, 0x0040, 0x0040);
1652   1      
1653   1          ForceDelay1ms(1); // delay 1 msec
1654   1      
C51 COMPILER V9.01   DRVADC                                                                03/09/2023 15:39:15 PAGE 29  

1655   1          // 3. Trigger ADC data high Vcal accumulator start
1656   1          drvADC_Write2BytesMask(REG_ADC_ATOP_55_L, 0x0100, 0x0100);
1657   1      
1658   1          // 4. Wait ADC data accumulation done, ADC_ATO_74_L[2:0] = 3'b 111
1659   1          while ((wTimeOutCnt>0) && (!(drvADC_ReadByte(REG_ADC_ATOP_74_L) & 0x07)))
1660   1          {
1661   2              wTimeOutCnt--;
1662   2          }
1663   1          if(wTimeOutCnt == 0)
1664   1              ADC_DPUTSTR("ADC data high accumulation time out\n");
1665   1      
1666   1          // 5. Select Vcal 0.55V
1667   1      #if DADCCALBYBANDGAP
1668   1          drvADC_Write2BytesMask(REG_ADC_ATOP_54_L, 0xD800, 0xF800); // [15]:ADC VCAL force enable, [14:11]: set
             - Vcal = 0.55V, 
1669   1      #else
                  drvADC_Write2BytesMask(REG_ADC_ATOP_54_L, 0x0002, 0x0003); // reg_rgb_cal_ldo_sel_sw
              #endif // DADCCALBYBANDGAP
1672   1      
1673   1          // 6. Disable ADC data high Vcal accumulator & Enable ADC data low Vcal accumulator
1674   1          drvADC_Write2BytesMask(REG_ADC_ATOP_55_L, 0x0000, 0x0040);
1675   1          drvADC_Write2BytesMask(REG_ADC_ATOP_55_L, 0x0080, 0x0080);
1676   1      
1677   1          ForceDelay1ms(1); // delay 1 msec
1678   1      
1679   1          // 7. Trigger ADC data low Vcal accumulator start
1680   1          drvADC_Write2BytesMask(REG_ADC_ATOP_55_L, 0x0100, 0x0100);
1681   1      
1682   1          // 8. Wait ADC data accumulation done, ADC_ATO_74_L[2:0] = 3'b 111
1683   1          wTimeOutCnt = 300;
1684   1          while ((wTimeOutCnt>0) && (!(drvADC_ReadByte(REG_ADC_ATOP_74_L) & 0x07)))
1685   1          {
1686   2              wTimeOutCnt--;
1687   2          }
1688   1          if(wTimeOutCnt == 0)
1689   1              ADC_DPUTSTR("ADC data low accumulation time out\n");
1690   1      
1691   1          // 9. Read ADC channel 0 & 1 difference value(Vcal_high - Vcal_low)
1692   1          wRch0val = ((drvADC_ReadByte(REG_ADC_ATOP_64_H)&0x03) << 8) | drvADC_ReadByte(REG_ADC_ATOP_64_L);
1693   1          wRch1val = ((drvADC_ReadByte(REG_ADC_ATOP_67_H)&0x03) << 8) | drvADC_ReadByte(REG_ADC_ATOP_67_L);
1694   1          wGch0val = ((drvADC_ReadByte(REG_ADC_ATOP_6A_H)&0x03) << 8) | drvADC_ReadByte(REG_ADC_ATOP_6A_L);
1695   1          wGch1val = ((drvADC_ReadByte(REG_ADC_ATOP_6D_H)&0x03) << 8) | drvADC_ReadByte(REG_ADC_ATOP_6D_L);
1696   1          wBch0val = ((drvADC_ReadByte(REG_ADC_ATOP_70_H)&0x03) << 8) | drvADC_ReadByte(REG_ADC_ATOP_70_L);
1697   1          wBch1val = ((drvADC_ReadByte(REG_ADC_ATOP_73_H)&0x03) << 8) | drvADC_ReadByte(REG_ADC_ATOP_73_L);
1698   1      
1699   1      #if 0
                  // Aaron test
                  wRch0val = 3;
                  wRch1val = 5;
                  wGch0val = 2010;
                  wGch1val = 1888;
                  wBch0val = 1000;
                  wBch1val = 1000;
              #endif
1708   1      
1709   1          // 10. Set ADC compensated codes (1.10)
1710   1      #if DADCNEWGAINCALMETHOD == 1
              
                  // target code : 1024 * 0.5 / 0.7 = 731
                  //wTargetCode = 731;
                  // target code : (1024-32) * 0.5 / 0.7 = 708
                  wTargetCode = 708;
C51 COMPILER V9.01   DRVADC                                                                03/09/2023 15:39:15 PAGE 30  

              
                  //ADC_DPRINTF("Target Code = %d\n", wTargetCode);
                  // R-ch
                  wRch0Div = ((wTargetCode / wRch0val) << 10) | (WORD)(((DWORD)(wTargetCode%wRch0val)<<10)/wRch0val);
                  wRch1Div = ((wTargetCode / wRch1val) << 10) | (WORD)(((DWORD)(wTargetCode%wRch1val)<<10)/wRch1val);
                  // G-ch
                  wGch0Div = ((wTargetCode / wGch0val) << 10) | (WORD)(((DWORD)(wTargetCode%wGch0val)<<10)/wGch0val);
                  wGch1Div = ((wTargetCode / wGch1val) << 10) | (WORD)(((DWORD)(wTargetCode%wGch1val)<<10)/wGch1val);
                  // B-ch
                  wBch0Div = ((wTargetCode / wBch0val) << 10) | (WORD)(((DWORD)(wTargetCode%wBch0val)<<10)/wBch0val);
                  wBch1Div = ((wTargetCode / wBch1val) << 10) | (WORD)(((DWORD)(wTargetCode%wBch1val)<<10)/wBch1val);
              
              #elif DADCNEWGAINCALMETHOD == 2
1729   1      
1730   1          #if (CHIP_ID == CHIP_TSUMF)
              
                  // ADC PGA gain:
                  //  00: 1.0 / 01: 1.2 / 10: 0.8 / 11: 0.96
                  //  target code : (1024-32)*0.5/PGA gain
                  switch(UserPrefAdcPgaGain)
                  {
                      case 0x00:
                          wTargetCode = 496;
                          break;
                      case 0x15:
                          wTargetCode = 413;
                          break;
                      case 0x2A:
                          wTargetCode = 620;
                          break;
                      case 0x3F:
                          wTargetCode = 516;
                          break;
                      default:
                          break;
                  }
              
                  #else
1754   1              
1755   1          // ADC PGA gain:
1756   1          //  00: 0.861538 / 01: 0.969231 / 10: 1.076923 / 11: 1.184615
1757   1          //  target code : (1024-32)*0.5/PGA gain
1758   1          switch(UserPrefAdcPgaGain)
1759   1          {
1760   2              case 0x00:
1761   2                  wTargetCode = 576;
1762   2                  break;
1763   2              case 0x15:
1764   2                  wTargetCode = 512;
1765   2                  break;
1766   2              case 0x2A:
1767   2                  wTargetCode = 461;
1768   2                  break;
1769   2              case 0x3F:
1770   2                  wTargetCode = 419;
1771   2                  break;
1772   2              default:
1773   2                  break;
1774   2          }
1775   1              
1776   1          #endif // #if (CHIP_ID == CHIP_TSUMF) 
1777   1          
C51 COMPILER V9.01   DRVADC                                                                03/09/2023 15:39:15 PAGE 31  

1778   1          //ADC_DPRINTF("Target Code = %d\n", wTargetCode);
1779   1          // R-ch
1780   1          wRch0Div = ((wTargetCode / wRch0val) << 10) | (WORD)(((DWORD)(wTargetCode%wRch0val)<<10)/wRch0val);
1781   1          wRch1Div = ((wTargetCode / wRch1val) << 10) | (WORD)(((DWORD)(wTargetCode%wRch1val)<<10)/wRch1val);
1782   1          // G-ch
1783   1          wGch0Div = ((wTargetCode / wGch0val) << 10) | (WORD)(((DWORD)(wTargetCode%wGch0val)<<10)/wGch0val);
1784   1          wGch1Div = ((wTargetCode / wGch1val) << 10) | (WORD)(((DWORD)(wTargetCode%wGch1val)<<10)/wGch1val);
1785   1          // B-ch
1786   1          wBch0Div = ((wTargetCode / wBch0val) << 10) | (WORD)(((DWORD)(wTargetCode%wBch0val)<<10)/wBch0val);
1787   1          wBch1Div = ((wTargetCode / wBch1val) << 10) | (WORD)(((DWORD)(wTargetCode%wBch1val)<<10)/wBch1val);
1788   1      
1789   1      #else
              
                  // R-ch
                  if(wRch0val > wRch1val)
                  {
                      if((wRch0val / wRch1val) > 1)
                      {
                          wRch1Div = 0x0400; // ratio is 1, 1<<10
                          //ADC_DPRINTF("drvADC_MismatchGainCal: ADC Rch1 overflow = %f\n", (float)wRch0val/wRch1val);
                      }
                      else
                      {
                          wRch1Div = ((wRch0val / wRch1val) << 10) | (WORD)(((DWORD)(wRch0val%wRch1val)<<10)/wRch1val);
                      }
                      wRch0Div = 0x0400; // ratio is 1, 1<<10
                  }
                  else if (wRch0val < wRch1val)
                  {
                      if((wRch1val / wRch0val) > 1)
                      {
                          wRch0Div = 0x0400; // ratio is 1, 1<<10
                          //ADC_DPRINTF("drvADC_MismatchGainCal: ADC Rch0 overflow = %f\n", (float)wRch1val/wRch0val);
                      }
                      else
                      {
                          wRch0Div = ((wRch1val / wRch0val) << 10) | (WORD)(((DWORD)(wRch1val%wRch0val)<<10)/wRch0val);
                      }
                      wRch1Div = 0x0400;
                  }
                  else // wRch0val = wRch1val
                  {
                      wRch0Div = 0x0400;
                      wRch1Div = 0x0400;
                      //ADC_DPUTSTR("ADC R Ch 0 and ch1's gain Componsated code are equal\n");
                  }
                  // G-ch
                  if(wGch0val > wGch1val)
                  {
                      if((wGch0val / wGch1val) > 1)
                      {
                          wGch1Div = 0x0400; // ratio is 1, 1<<10
                          //ADC_DPRINTF("drvADC_MismatchGainCal: ADC Gch1 overflow = %f\n", (float)wGch0val/wGch1val);
                      }
                      else
                      {
                          wGch1Div = ((wGch0val / wGch1val) << 10) | (WORD)(((DWORD)(wGch0val%wGch1val)<<10)/wGch1val);
                      }
                      wGch0Div = 0x0400;
                  }
                  else if (wGch0val < wGch1val)
                  {
C51 COMPILER V9.01   DRVADC                                                                03/09/2023 15:39:15 PAGE 32  

                      if((wGch1val / wGch0val) > 1)
                      {
                          wGch0Div = 0x0400; // ratio is 1, 1<<10
                          //ADC_DPRINTF("drvADC_MismatchGainCal: ADC Gch0 overflow = %f\n", (float)wGch1val/wGch0val);
                      }
                      else
                      {
                          wGch0Div = ((wGch1val / wGch0val) << 10) | (WORD)(((DWORD)(wGch1val%wGch0val)<<10)/wGch0val);
                      }
                      wGch1Div = 0x0400;
                  }
                  else // wGch0val = wGch1val
                  {
                      wGch0Div = 0x0400;
                      wGch1Div = 0x0400;
                  }
                  // B-ch
                  if(wBch0val > wBch1val)
                  {
                      if((wBch0val / wBch1val) > 1)
                      {
                          wBch1Div = 0x0400; // ratio is 1, 1<<10
                          //ADC_DPRINTF("drvADC_MismatchGainCal: ADC Bch1 overflow = %f\n", (float)wBch0val/wBch1val);
                      }
                      else
                      {
                          wBch1Div = ((wBch0val / wBch1val) << 10) | (WORD)(((DWORD)(wBch0val%wBch1val)<<10)/wBch1val);
                      }
                      wBch0Div = 0x0400;
                  }
                  else if (wBch0val < wBch1val)
                  {
                      if((wBch1val / wBch0val) > 1)
                      {
                          wBch0Div = 0x0400; // ratio is 1, 1<<10
                          //ADC_DPRINTF("drvADC_MismatchGainCal: ADC Bch0 overflow = %f\n", (float)wBch1val/wBch0val);
                      }
                      else
                      {
                          wBch0Div = ((wBch1val / wBch0val) << 10) | (WORD)(((DWORD)(wBch1val%wBch0val)<<10)/wBch0val);
                      }
                      wBch1Div = 0x0400;
                  }
                  else // wBch0val = wBch1val
                  {
                      wBch0Div = 0x0400;
                      wBch1Div = 0x0400;
                  }
                  
              #endif // #if DADCNEWGAINCALMETHOD
1890   1      
1891   1          gADCMismatchAvgVal.wGainVal_Rch0 += (wRch0Div & 0x07FF);
1892   1          gADCMismatchAvgVal.wGainVal_Rch1 += (wRch1Div & 0x07FF);
1893   1          gADCMismatchAvgVal.wGainVal_Gch0 += (wGch0Div & 0x07FF);
1894   1          gADCMismatchAvgVal.wGainVal_Gch1 += (wGch1Div & 0x07FF);
1895   1          gADCMismatchAvgVal.wGainVal_Bch0 += (wBch0Div & 0x07FF);
1896   1          gADCMismatchAvgVal.wGainVal_Bch1 += (wBch1Div & 0x07FF);
1897   1      #if 0
                  drvADC_Write2BytesMask(REG_ADC_ATOP_58_L, wRch0Div, 0x07FF); // Set ADC channel 0 gain compensated cod
             -e
                  drvADC_Write2BytesMask(REG_ADC_ATOP_59_L, wRch1Div, 0x07FF); // Set ADC channel 1 gain compensated cod
             -e
C51 COMPILER V9.01   DRVADC                                                                03/09/2023 15:39:15 PAGE 33  

                  drvADC_Write2BytesMask(REG_ADC_ATOP_5C_L, wGch0Div, 0x07FF); // Set ADC channel 0 gain compensated cod
             -e
                  drvADC_Write2BytesMask(REG_ADC_ATOP_5D_L, wGch1Div, 0x07FF); // Set ADC channel 1 gain compensated cod
             -e
                  drvADC_Write2BytesMask(REG_ADC_ATOP_60_L, wBch0Div, 0x07FF); // Set ADC channel 0 gain compensated cod
             -e
                  drvADC_Write2BytesMask(REG_ADC_ATOP_61_L, wBch1Div, 0x07FF); // Set ADC channel 1 gain compensated cod
             -e
              #endif
1905   1      #if 0
                  ADC_DPRINTF("R Ch0 gain val= 0x%x", wRch0val);
                  //ADC_DPRINTF("R Ch1 gain val= 0x%x", wRch1val);
                  ADC_DPRINTF("G Ch0 gain val= 0x%x", wGch0val);
                  //ADC_DPRINTF("G Ch1 gain val= 0x%x", wGch1val);
                  ADC_DPRINTF("B Ch0 gain val= 0x%x", wBch0val);
                  //ADC_DPRINTF("B Ch1 gain val= 0x%x", wBch1val);
                  ADC_DPRINTF("R Ch0 gain code= 0x%x", wRch0Div);
                  ADC_DPRINTF("R Ch1 gain code= 0x%x", wRch1Div);
                  ADC_DPRINTF("G Ch0 gain code= 0x%x", wGch0Div);
                  ADC_DPRINTF("G Ch1 gain code= 0x%x", wGch1Div);
                  ADC_DPRINTF("B Ch0 gain code= 0x%x", wBch0Div);
                  ADC_DPRINTF("B Ch1 gain code= 0x%x", wBch1Div);
              #endif
1919   1          // 11. Turn on enable gain mismatch compensated codes
1920   1          drvADC_Write2BytesMask(REG_ADC_ATOP_55_L, 0x002A, 0x00AA); // [7]: acc low disable, [5]: B mismatch ga
             -in enable, [3]: G mismatch gain enable, [1]: R mismatch gain enable,
1921   1      
1922   1          // 12. Turn off ADC offset calibration pulse
1923   1          drvADC_Write2BytesMask(REG_ADC_ATOP_54_L, 0x0000, 0xFF0F); // [15]:ADC VCAL force enable, [14:11]: set
             - Vcal, [10:8]: Turn off self Gcal pulse, [3:2]: reg_rgb_cal_trim_ldo_sel_sw, [1:0]: reg_rgb_cal_ldo_sel_sw
1924   1      }
1925          
1926          
1927          #define DGain_OverFlow_R_ch         BIT7
1928          #define DGain_NoneOverFlow_R_ch     BIT6
1929          #define DGain_OverFlow_G_ch         BIT5
1930          #define DGain_NoneOverFlow_G_ch     BIT4
1931          #define DGain_OverFlow_B_ch         BIT3
1932          #define DGain_NoneOverFlow_B_ch     BIT2
1933          #ifndef ADCRB_SWAP
1934          #define ADCRB_SWAP 0
1935          #endif
1936          #ifndef ADJ_GAIN_RATIO
1937          #define ADJ_GAIN_RATIO      1
1938          #endif
1939          //**************************************************************************
1940          //  [Function Name]:
1941          //                  drvADC_AutoAdjustAdcGain()
1942          //  [Description]:
1943          //                  Check input sync is lost or not
1944          //  [Precondition]:
1945          //                  Do auto gain adjustment with input source
1946          //  [Arguments]:
1947          //                  vsyncTime: frame rate of the current input
1948          //  [Return]:
1949          //                  TRUE: done, FALSE: fail
1950          //**************************************************************************
1951          static Bool drvADC_AutoAdjustAdcGain(BYTE u8VSyncTime)
1952          {
1953   1          WORD rGain, gGain, bGain;
1954   1          WORD maxRGain, maxGGain, maxBGain;
1955   1          WORD minRGain, minGGain, minBGain;
C51 COMPILER V9.01   DRVADC                                                                03/09/2023 15:39:15 PAGE 34  

1956   1          BYTE retry=12;
1957   1          BYTE adcStatus;
1958   1          BYTE atgFlags=0;
1959   1      
1960   1          maxRGain=maxGGain=maxBGain=0xFFF;
1961   1          minRGain=minGGain=minBGain=0;
1962   1      
1963   1          while (retry--)
1964   1          {
1965   2              rGain=((WORD)maxRGain+minRGain)/2;
1966   2              gGain=((WORD)maxGGain+minGGain)/2;
1967   2              bGain=((WORD)maxBGain+minBGain)/2;
1968   2              drvADC_SetRGBGainCode(rGain, gGain, bGain);
1969   2              Delay1ms(u8VSyncTime);
1970   2              // Wait scaler auto gain is done, SC0_78[1] = 1
1971   2              adcStatus=drvADC_WaitAutoStatusReady(SC0_78, BIT1);
1972   2              //adcStatus=msReadByte(SC0_78);
1973   2      
1974   2              if( adcStatus & BIT7 )
1975   2              {
1976   3                  rGain--;
1977   3                  atgFlags|=DGain_OverFlow_R_ch;
1978   3              }
1979   2              else
1980   2              {
1981   3                  rGain++;
1982   3                  atgFlags|=DGain_NoneOverFlow_R_ch;
1983   3              }
1984   2      
1985   2              if( adcStatus & BIT6 )
1986   2              {
1987   3                  gGain--;
1988   3                  atgFlags|=DGain_OverFlow_G_ch;
1989   3              }
1990   2              else
1991   2              {
1992   3                  gGain++;
1993   3                  atgFlags|=DGain_NoneOverFlow_G_ch;
1994   3              }
1995   2      
1996   2              if( adcStatus & BIT5 )
1997   2              {
1998   3                  bGain--;
1999   3                  atgFlags|=DGain_OverFlow_B_ch;
2000   3              }
2001   2              else
2002   2              {
2003   3                  bGain++;
2004   3                  atgFlags|=DGain_NoneOverFlow_B_ch;
2005   3              }
2006   2      
2007   2              drvADC_SetRGBGainCode(rGain, gGain, bGain);
2008   2              Delay1ms(u8VSyncTime);
2009   2              // Wait scaler auto gain is done, SC0_78[1] = 1
2010   2              adcStatus=drvADC_WaitAutoStatusReady(SC0_78, BIT1);
2011   2              //adcStatus=msReadByte(SC0_78);
2012   2      
2013   2              if( adcStatus & BIT7 )
2014   2              {
2015   3                  maxRGain=rGain+1;
2016   3                  atgFlags|=DGain_OverFlow_R_ch;
2017   3              }
C51 COMPILER V9.01   DRVADC                                                                03/09/2023 15:39:15 PAGE 35  

2018   2              else
2019   2              {
2020   3                  minRGain=rGain-1;
2021   3                  atgFlags|=DGain_NoneOverFlow_R_ch;
2022   3              }
2023   2      
2024   2              if( adcStatus & BIT6 )
2025   2              {
2026   3                  maxGGain=gGain+1;
2027   3                  atgFlags|=DGain_OverFlow_G_ch;
2028   3              }
2029   2              else
2030   2              {
2031   3                  minGGain=gGain-1;
2032   3                  atgFlags|=DGain_NoneOverFlow_G_ch;
2033   3              }
2034   2      
2035   2              if( adcStatus & BIT5 )
2036   2              {
2037   3                  maxBGain=bGain+1;
2038   3                  atgFlags|=DGain_OverFlow_B_ch;
2039   3              }
2040   2              else
2041   2              {
2042   3                  minBGain=bGain-1;
2043   3                  atgFlags|=DGain_NoneOverFlow_B_ch;
2044   3              }
2045   2      
2046   2              if (CheckSyncLoss())
2047   2                  return FALSE;
2048   2          }
2049   1      
2050   1          if ((atgFlags&0xFC)!=0xFC)
2051   1              return FALSE;
2052   1      
2053   1          if (rGain>4000 || gGain>4000 || bGain>4000) //Jison 101029
2054   1              return FALSE;
2055   1      
2056   1      #if 0  //Steven101220
                  UserPrefAdcRedGain = ((DWORD)rGain-1)*(100+ADJ_GAIN_RATIO)/100;
                  UserPrefAdcGreenGain = ((DWORD)gGain-1)*(100+ADJ_GAIN_RATIO)/100;
                  UserPrefAdcBlueGain = ((DWORD)bGain-1)*(100+ADJ_GAIN_RATIO)/100;
              #elif ModelName == MODEL_HS275HFB || ModelName == MODEL_HS225HFB
                  UserPrefAdcRedGain  = rGain+20;
                  UserPrefAdcGreenGain = gGain+20;
                  UserPrefAdcBlueGain = bGain+20;
              #else
2065   1          UserPrefAdcRedGain  = rGain-1;
2066   1          UserPrefAdcGreenGain = gGain-1;
2067   1          UserPrefAdcBlueGain = bGain-1;
2068   1      #endif
2069   1          drvADC_SetRGBGainCode(UserPrefAdcRedGain, UserPrefAdcGreenGain, UserPrefAdcBlueGain);
2070   1      
2071   1          return TRUE;
2072   1      }
2073          
2074          static void drvADC_SetPGAGainCode(BYTE ucAdcPgaGain)  //Steven110329, Solve check PGA gain issue.
2075          {
2076   1          drvADC_Write2BytesMask(REG_ADC_DTOP_55_L, ucAdcPgaGain, 0x03F);
2077   1      }
2078          
2079          //**************************************************************************
C51 COMPILER V9.01   DRVADC                                                                03/09/2023 15:39:15 PAGE 36  

2080          //  [Function Name]:
2081          //                  drvADC_CheckPGAGain()
2082          //  [Description]:
2083          //                  Check input signal is over PGA gain or not
2084          //  [Precondition]:
2085          //                  00: 1.0V, 01: 1.2V, 10: 0.8V, 11: 0.96V  => TSUMF
2086          //                  00: 0.8V, 01: 0.9V, 10: 1.0V, 11: 1.1V
2087          //                  The default PGA gain in Rose is 0.8V. To avoid the input signal is over 0.8V, this fun
             -ction is used to
2088          //                  detect and adjust PGA gain. The maximum PGA gain would be limited in 1.0V
2089          //  [Arguments]:
2090          //                  vsyncTime: frame rate of the current input
2091          //  [Return]:
2092          //                  TRUE: done, FALSE: fail
2093          //**************************************************************************
2094          static BYTE drvADC_CheckPGAGain(BYTE vsyncTime)
2095          {
2096   1          BYTE u8CurPGA, adcStatus;
2097   1      
2098   1      #if (CHIP_ID == CHIP_TSUMF)
                  u8CurPGA = 0x2A;
              #else
2101   1          u8CurPGA = 0x00;
2102   1      #endif //#if (CHIP_ID == CHIP_TSUMF)
2103   1      
2104   1          drvADC_Write2BytesMask(REG_ADC_DTOP_55_L, u8CurPGA, 0x003F);
2105   1          msWriteByteMask(SC0_78, BIT3, BIT3); // output is overflow or underflow result
2106   1          Delay1ms(vsyncTime);
2107   1          // Wait scaler auto gain is done, BK0_78[1] = 1
2108   1          adcStatus=drvADC_WaitAutoStatusReady( SC0_78, BIT1 );
2109   1          ADC_DPRINTF("adcStatus = 0x%x\n", adcStatus);
2110   1          ADC_DPRINTF("--adcStatus = 0x%x\n", msReadByte(REG_ADC_DTOP_55_L) & 0x3F);
2111   1      
2112   1          while( adcStatus & ( BIT5 | BIT6 | BIT7 ) )
2113   1          {
2114   2      #if (CHIP_ID == CHIP_TSUMF)
                      if(u8CurPGA == 0x00) // limited the maxi VPP = 1.0V
                          break;
                      else
                      {
                          u8CurPGA = ((u8CurPGA == 0x3F) ? 0x00 : (u8CurPGA+0x15));
                          drvADC_Write2BytesMask( REG_ADC_DTOP_55_L, u8CurPGA, 0x003F );
                          Delay1ms(vsyncTime);
                          // Wait scaler auto gain is done, SC0_78[1] = 1
                          adcStatus=drvADC_WaitAutoStatusReady( SC0_78, BIT1 );
                          //adcStatus=msReadByte(SC0_78);
                      }
              #else
2127   2              if(u8CurPGA == 0x2A) // limited the maxi VPP = 1.0V
2128   2                  break;
2129   2              else
2130   2              {
2131   3                  u8CurPGA += 0x15;
2132   3                  drvADC_Write2BytesMask( REG_ADC_DTOP_55_L, u8CurPGA, 0x003F );
2133   3                  Delay1ms(vsyncTime);
2134   3                  // Wait scaler auto gain is done, SC0_78[1] = 1
2135   3                  adcStatus=drvADC_WaitAutoStatusReady( SC0_78, BIT1 );
2136   3                  //adcStatus=msReadByte(SC0_78);
2137   3              }
2138   2      #endif // #if (CHIP_ID == CHIP_TSUMF)
2139   2              ADC_DPRINTF("adcStatus = 0x%x\n", adcStatus);
2140   2          }
C51 COMPILER V9.01   DRVADC                                                                03/09/2023 15:39:15 PAGE 37  

2141   1          ADC_DPRINTF("PGA Gain = 0x%x\n", u8CurPGA);
2142   1          msWriteByteMask(SC0_78, 0, BIT3);
2143   1          return u8CurPGA;
2144   1      }
2145          
2146          #if DADCPLLPROTECTION
2147          //**************************************************************************
2148          //  [Function Name]:
2149          //                  drvADC_IsEnableFreeRun()
2150          //  [Description]:
2151          //                  Enable/Disable ADC free run mode
2152          //  [Precondition]:
2153          //                  Use to protect ADC PLL while mode changing
2154          //  [Arguments]:
2155          //                  bflag: TRUE => enable, FALSE => disable
2156          //  [Return]:
2157          //
2158          //**************************************************************************
2159          static void drvADC_IsEnableFreeRun(Bool bflag)
2160          {
2161   1          TAB_Info Tab_info;
2162   1      
2163   1          Tab_info.u8TabCols = REG_ADDR_SIZE+REG_MASK_SIZE+ADC_TABLE_INIT_NUMS*REG_DATA_SIZE;
2164   1          Tab_info.u8TabIdx = 0;
2165   1          if(bflag) // enable
2166   1          {
2167   2              Tab_info.pTable = (void*)MST_ADCFreeRunEn_TBL;
2168   2              Tab_info.u8TabRows = sizeof(MST_ADCFreeRunEn_TBL)/Tab_info.u8TabCols;
2169   2          }
2170   1          else // disable
2171   1          {
2172   2              Tab_info.pTable = (void*)MST_ADCFreeRunDis_TBL;
2173   2              Tab_info.u8TabRows = sizeof(MST_ADCFreeRunDis_TBL)/Tab_info.u8TabCols;
2174   2          }
2175   1          drvADC_LoadTable(&Tab_info);
2176   1      
2177   1      #if ENABLE_XTAL_LESS
                  if(!bflag)
                  {
                      drvADC_Write2BytesMask(REG_ADC_DTOP_02_L, gADCBackupSetting.BWCoef, 0x00FF);
                      drvADC_Write2BytesMask(REG_ADC_DTOP_03_L, gADCBackupSetting.DampCoef, 0x00FF);
                  }
              #endif
2184   1      
2185   1          //ADC_DPRINTF("ADC Tbl:drvADC_IsEnableFreeRun %d\n", bflag);
2186   1      }
2187          
2188          //**************************************************************************
2189          //  [Function Name]:
2190          //                  drvADC_SetAutoProst()
2191          //  [Description]:
2192          //                  Set/Release small loop auto porst
2193          //  [Precondition]:
2194          //                  Use to protect ADC PLL while mode changing
2195          //  [Arguments]:
2196          //                  bflag: TRUE => enable, FALSE => disable
2197          //  [Return]:
2198          //
2199          //**************************************************************************
2200          static void drvADC_SetAutoProst(Bool bflag)
2201          {
2202   1          TAB_Info Tab_info;
C51 COMPILER V9.01   DRVADC                                                                03/09/2023 15:39:15 PAGE 38  

2203   1      
2204   1          Tab_info.u8TabCols = REG_ADDR_SIZE+REG_MASK_SIZE+ADC_TABLE_INIT_NUMS*REG_DATA_SIZE;
2205   1          Tab_info.u8TabIdx = 0;
2206   1          if(bflag) // enable
2207   1          {
2208   2              Tab_info.pTable = (void*)MST_ADCPorstEn_TBL;
2209   2              Tab_info.u8TabRows = sizeof(MST_ADCPorstEn_TBL)/Tab_info.u8TabCols;
2210   2          }
2211   1          else // disable
2212   1          {
2213   2              Tab_info.pTable = (void*)MST_ADCPorstDis_TBL;
2214   2              Tab_info.u8TabRows = sizeof(MST_ADCPorstDis_TBL)/Tab_info.u8TabCols;
2215   2          }
2216   1      
2217   1          drvADC_LoadTable(&Tab_info);
2218   1      
2219   1          //ADC_DPRINTF("ADC Tbl:drvADC_SetAutoProst %d\n", bflag);
2220   1      }
2221          #endif // #ifdef DADCPLLPROTECTION
2222          
2223          
2224          #if _DGAIN_CAL_WITHOUT_INPUT_ //????
2225          #if (DADCNEWGAINCALMETHOD == 0)
              //**************************************************************************
              //  [Function Name]:
              //                  drvADC_EnableScalerPG()
              //  [Description]:
              //                  Enable Scaler pattern generatot to generate Htotal = 256/512/1024/2048 and Vtotal=64(f
             -ixed)
              //  [Precondition]:
              //
              //  [Arguments]:
              //
              //                  ht_sel: 0:256, 1:512, 2:1024, 3:2048
              //  [Return]:
              //
              //**************************************************************************
              static void drvADC_EnableScalerPG(msADCScalerPG_HtotalSel ht_sel)
              {
                  WORD whact;
              
                  //msWriteByteMask(SC0_02, 0x00, 0x80); // disable free-run
                  msWriteByteMask(SC0_01, 0, 0x01); // disable double buffer
                  msWriteByteMask(SC0_02, 0x00|BIT2, 0x07); // [2]:use Hsync only, [1:0]:ISEL = analog1
                  msWrite2Byte(SC0_07, 0x0010); // SPRHST = 0x10
                  whact = 256*(ht_sel+1) - 16;
                  msWrite2ByteMask(SC0_0B, whact,SC_MASK_H); // SPRHDC = htsel - 0x10
                  // Vtotal is 64 lines, Vstart = 0x10, Vactive = 0x30
                  msWrite2Byte(SC0_05, 0x0010); // SPRVST = 0x10
                  msWrite2ByteMask(SC0_09, 0x0030,SC_MASK_V); // SPRVDC = 0x30
              #if (CHIP_ID == CHIP_TSUMU)
                  msWriteByteMask(SC0_63, (ht_sel<<6)|0x30, 0xF0); //[7:6]: Htotal, [5]: Enable PG's Hsync/Vsync/Hde/Vde
             - to IP, [4]: Pattern gen engine enable
              #elif (CHIP_ID == CHIP_TSUMV || CHIP_ID == CHIP_TSUM2 || CHIP_ID==CHIP_TSUMB || CHIP_ID==CHIP_TSUMY) //
                  msWriteByteMask(REG_2E42, ht_sel<<1|0x19, 0x1F); // Rosen: [4]: No input ADC calibration enable, [3]: 
             -Enable PG's Hsync/Vsync/Hde/Vde to IP, [2:1]: Htotal, [0]: Pattern gen engine enable
              #elif ((CHIP_ID == CHIP_TSUMC) || (CHIP_ID == CHIP_TSUMD) || (CHIP_ID == CHIP_TSUM9 )|| (CHIP_ID == CHIP_T
             -SUMF ))
                  msWrite2ByteMask(REG_2E24, whact, 0x1FFF); // reg_hde
                  msWriteByteMask(REG_2E26, 0x05, 0xFF); // reg_hfp_w
                  msWriteByteMask(REG_2E28, 0x06, 0xFF); // reg_hsync_w
                  msWrite2ByteMask(REG_2E2A, 256*(ht_sel+1), 0x1FFF); // reg_htotal
C51 COMPILER V9.01   DRVADC                                                                03/09/2023 15:39:15 PAGE 39  

                  msWrite2ByteMask(REG_2E2C, 0x30, 0x1FFF); // reg_vde
                  msWriteByteMask(REG_2E2E, 0x05, 0x7F); // reg_vfp_w
                  msWriteByteMask(REG_2E30, 0x06, 0x3F); // reg_vsync_w
                  msWrite2ByteMask(REG_2E32, 0x40, 0x1FFF); // reg_vtotal
                  msWrite2ByteMask(REG_2E20, BIT0, BIT0); // Timing gen enable
                  msWriteByteMask(REG_2E42, 0x18, 0x18); // Rosen: [4]: No input ADC calibration enable, [3]: Enable PG'
             -s Hsync/Vsync/Hde/Vde to IP
              #endif
              }
              
              //**************************************************************************
              //  [Function Name]:
              //                  _msADC_MaskExternalSync()
              //  [Description]:
              //                  Mask external sync when connecting with source
              //  [Precondition]:
              //
              //  [Arguments]:
              //                 bflag: TRUE: Mask, FALSE: non-Mask
              //
              //  [Return]:
              //
              //**************************************************************************
              static void _msADC_MaskExternalSync(Bool bflag)
              {
                  if(bflag)
                      drvADC_Write2BytesMask(REG_ADC_ATOP_04_L, BIT14, BIT14); // power down Hsync_Cmp
                  else
                      drvADC_Write2BytesMask(REG_ADC_ATOP_04_L, 0, BIT14); // power on Hsync_Cmp
              }
              #endif
2291          #endif //#if _DGAIN_CAL_WITHOUT_INPUT_
2292          
2293          #if ((_DGAIN_CAL_WITH_INPUT_) || ((_DGAIN_CAL_WITHOUT_INPUT_) && (DADCNEWGAINCALMETHOD == 0)))
              //**************************************************************************
              //  [Function Name]:
              //                  drvADC_BackupScalerSetting()
              //  [Description]:
              //                  Backup scaler settings
              //  [Precondition]:
              //
              //  [Arguments]:
              //
              //  [Return]:
              //
              //**************************************************************************
              static void drvADC_BackupScalerSetting(void)
              {
                  memset(&gScalerBackupSetting, 0, sizeof(gScalerBackupSetting));
                  gScalerBackupSetting.DBuffer = msReadByte(SC0_01);
                  gScalerBackupSetting.ISEL = msReadByte( SC0_02 );
                  gScalerBackupSetting.SPRHST = msRead2Byte( SC0_07 ) & 0x07FF; //???? 0xFFF
                  gScalerBackupSetting.SPRHDC = msRead2Byte( SC0_0B ) & SC_MASK_H;
                  gScalerBackupSetting.SPRVST = msRead2Byte( SC0_05 ) & 0x07FF; //???? 0xFFF
                  gScalerBackupSetting.SPRVDC = msRead2Byte( SC0_09 ) & SC_MASK_V;
              }
              
              //**************************************************************************
              //  [Function Name]:
              //                  drvADC_RecoverScalerSetting()
              //  [Description]:
              //                  Recover scaler settings
C51 COMPILER V9.01   DRVADC                                                                03/09/2023 15:39:15 PAGE 40  

              //  [Precondition]:
              //
              //  [Arguments]:
              //
              //  [Return]:
              //
              //**************************************************************************
              static void drvADC_RecoverScalerSetting(void)
              {
                  msWriteByteMask(SC0_01, gScalerBackupSetting.DBuffer, 0xFF);
                  msWriteByteMask( SC0_02, gScalerBackupSetting.ISEL, 0xFF );
                  msWrite2ByteMask( SC0_07, gScalerBackupSetting.SPRHST, 0x07FF ); //????
                  msWrite2ByteMask( SC0_0B, gScalerBackupSetting.SPRHDC, SC_MASK_H );
                  msWrite2ByteMask( SC0_05, gScalerBackupSetting.SPRVST, 0x07FF );  //????
                  msWrite2ByteMask( SC0_09, gScalerBackupSetting.SPRVDC, SC_MASK_V );
                  //msWriteByteMask(REG_2FC0, 0x00, 0x1F); //[4]: OSD to IP disable, [3]: disable PG's Hsync/Vsync/Hde/V
             -de to IP, [2]: Pattern gen engine disable, [1:0]: Htotal is 256
              #if ( (CHIP_ID==CHIP_TSUMB || CHIP_ID==CHIP_TSUMY) || (CHIP_ID == CHIP_TSUMU) ) //
                  msWriteByteMask( SC0_63, 0, 0xF0 ); //[7:6]: Htotal, [5]: Enable PG's Hsync/Vsync/Hde/Vde to IP, [4]: 
             -Pattern gen engine enable
              #elif (CHIP_ID == CHIP_TSUMV || CHIP_ID == CHIP_TSUM2) //
                  msWriteByteMask(REG_2E42, 0, 0x1F); // Rosen: [4]: No input ADC calibration enable, [3]: Enable PG's H
             -sync/Vsync/Hde/Vde to IP, [2:1]: Htotal, [0]: Pattern gen engine enable
              #elif ((CHIP_ID == CHIP_TSUMC) || (CHIP_ID == CHIP_TSUMD) || (CHIP_ID == CHIP_TSUM9 ) || (CHIP_ID == CHIP_
             -TSUMF))
                  msWrite2ByteMask(REG_2E20, 0, BIT0); // Timing gen enable
                  msWriteByteMask(REG_2E42, 0, 0x18); // Rosen: [4]: No input ADC calibration enable, [3]: Enable PG's H
             -sync/Vsync/Hde/Vde to IP
              #endif
              }
              
              //**************************************************************************
              //  [Function Name]:
              //                  drvADC_SetInternalVcal()
              //  [Description]:
              //                  Enable internal Vcal(0.55V or 1.05V) for gain calibration
              //  [Precondition]:
              //
              //  [Arguments]:
              //                 vcal: 0.55V / 1.05V
              //
              //  [Return]:
              //
              //**************************************************************************
              static void drvADC_SetInternalVcal(msADC_InternalVcal vcal)
              {
                  switch(vcal)
                  {
                      case E_Vcal_0_55V:
                      #if DADCCALBYBANDGAP
                          drvADC_Write2BytesMask(REG_ADC_ATOP_34_L, 0, BIT0); // turn off LDO
                          drvADC_Write2BytesMask(REG_ADC_ATOP_34_L, 0, BIT2); // Bandgap
                          drvADC_Write2BytesMask(REG_ADC_ATOP_54_L, 0, 0x000F); // disable LDO overwrite
                          drvADC_Write2BytesMask(REG_ADC_ATOP_54_L, 0xD800, 0xF800); // [15]:ADC VCAL force enable, [14:
             -11]: set Vcal = 0.55V, 
                      #else
                          drvADC_Write2BytesMask(REG_ADC_ATOP_34_L, BIT0, BIT0); // turn on LDO
                          drvADC_Write2BytesMask(REG_ADC_ATOP_34_L, BIT2, BIT2); // LDO
                          drvADC_Write2BytesMask(REG_ADC_ATOP_54_L, 0x0002, 0x0003); // set Vcal = 0.55V
                          drvADC_Write2BytesMask(REG_ADC_ATOP_54_L, 0x000C, 0x000C); // set Vcal from LDO
                          drvADC_Write2BytesMask(REG_ADC_ATOP_54_L, 0, 0xF800); // disable bandgap overwrite
                      #endif // DADCCALBYBANDGAP
C51 COMPILER V9.01   DRVADC                                                                03/09/2023 15:39:15 PAGE 41  

                          drvADC_Write2BytesMask(REG_ADC_ATOP_54_L, 0x0600, 0x0700); // turn on Gcal pulse
                          break;
              
                      case E_Vcal_1_05V:
                      #if DADCCALBYBANDGAP
                          drvADC_Write2BytesMask(REG_ADC_ATOP_34_L, 0, BIT0); // turn off LDO
                          drvADC_Write2BytesMask(REG_ADC_ATOP_34_L, 0, BIT2); // Bandgap
                          drvADC_Write2BytesMask(REG_ADC_ATOP_54_L, 0x0000, 0x000F); // disable LDO overwrite
                          drvADC_Write2BytesMask(REG_ADC_ATOP_54_L, 0xF800, 0xF800); // [15]:ADC VCAL force enable, [14:
             -11]: set Vcal = 1.05V, 
                      #else
                          drvADC_Write2BytesMask(REG_ADC_ATOP_34_L, BIT0, BIT0); // turn on LDO
                          drvADC_Write2BytesMask(REG_ADC_ATOP_34_L, BIT2, BIT2); // LDO
                          drvADC_Write2BytesMask(REG_ADC_ATOP_54_L, 0x0003, 0x0003); // set Vcal = 1.05V
                          drvADC_Write2BytesMask(REG_ADC_ATOP_54_L, 0x000C, 0x000C); // set Vcal from LDO
                          drvADC_Write2BytesMask(REG_ADC_ATOP_54_L, 0, 0xF800); // disable bandgap overwrite
                      #endif // DADCCALBYBANDGAP
                          drvADC_Write2BytesMask(REG_ADC_ATOP_54_L, 0x0600, 0x0700); // turn on Gcal pulse
                          break;
                      default:
                          break;
                  }
              }
              
              //**************************************************************************
              //  [Function Name]:
              //                  drvADC_IsReadLineBuffer()
              //  [Description]:
              //                  It's used to read scaler line buffer
              //  [Precondition]:
              //
              //  [Arguments]:
              //                 bflag: TRUE: reading, FALSE: recover to the normal state
              //  [Return]:
              //
              //**************************************************************************
              static Bool drvADC_IsReadLineBuffer(Bool bflag)
              {
                  Bool result=TRUE;
                  BYTE retry=5;
              
                  if(bflag)
                  {
                      msWriteByteMask( SC5_32, BIT6, BIT6 ); // latch data in line buffer
                      while(retry--)
                      {
                          ForceDelay1ms( 20 );
                          if( msReadByte( SC5_32 ) & BIT7 ) // Check ready bit for reading line buffer
                          {
                              //ADC_DPUTSTR("Line buffer ready for read\n");
                              break;
                          }
                      }
                      if(!retry)
                      {
                          result = FALSE;
                          ADC_DPUTSTR("Reading Line buffer fail !!\n");
                      }
                  }
                  else
                  {
                      msWriteByteMask( SC5_32, 0, BIT6 ); // disable latch data in line buffer
C51 COMPILER V9.01   DRVADC                                                                03/09/2023 15:39:15 PAGE 42  

                      //ADC_DPUTSTR("Turn off reading Line buffer \n");
                  }
                  return result;
              }
              
              //                  Adjust gain to approach target value 182(8 bits) => 255 * 0.5/0.7 = 182
              //**************************************************************************
              //  [Function Name]:
              //                  drvADC_GetRGBLineBufAverageData()
              //  [Description]:
              //                  Get the average line buffer data for R/G/B gain calibration
              //                  SC5_32[4:0]31[7:0] = 0 ~ 2560(total is 2560), each has two pixels and format is follow
             -ing
              //                  SC5_35[7:0]: R0, SC5_36[7:0]: G0, SC5_37[7:0]: B0
              //                  SC5_38[7:0]: R1, SC5_39[7:0]: G1, SC5_3A[7:0]: B1
              //  [Precondition]:
              //
              //  [Arguments]:
              //                 wLineBufAddress: line buffer address, it should be less than PG Htotal
              //                 LineBuf: choose one line to read, 0 ~ 3
              //                 AvgCnt: average pixel count
              //  [Return]:
              //                 msADCAvgVal: R/G/B average data
              //**************************************************************************
              static msADCAvgVal drvADC_GetRGBLineBufAverageData(WORD wLineBufAddress, BYTE LineBuf, BYTE AvgCnt)
              {
                  BYTE i;
                  WORD wAvgRdata=0, wAvgGdata=0, wAvgBdata=0;
                  msADCAvgVal pAutoAdc;
              
                  memset(&pAutoAdc, 0 , sizeof(pAutoAdc));
              
              #if (CHIP_ID==CHIP_TSUMB || CHIP_ID==CHIP_TSUMY) //
              
                  msWriteByteMask( SC5_33, ( LineBuf & 0x03 ) << 3, 0x18 ); // select to use which line buffer, 0 ~ 3
                  for (i=0; i<AvgCnt; i++)
                  {
                      if (i%2 == 0)
                      {
                          msWrite2ByteMask(SC5_31, wLineBufAddress+(i/2), 0x0FFF); // config line buffer address
                          // B
                          msWriteByteMask(SC5_33, 0, 0x07); // select B0 to read
                          wAvgBdata += msReadByte(SC5_35); //read line buffer data
                          // G
                          msWriteByteMask(SC5_33, 1, 0x07); // select G0 to read
                          wAvgGdata += msReadByte(SC5_35); //read line buffer data
                          // R
                          msWriteByteMask(SC5_33, 2, 0x07); // select R0 to read
                          wAvgRdata += msReadByte(SC5_35); //read line buffer data
                      }
                      else
                      {
                          // B
                          msWriteByteMask(SC5_33, 3, 0x07); // select B1 to read
                          wAvgBdata += msReadByte(SC5_35); //read line buffer data
                          // G
                          msWriteByteMask(SC5_33, 4, 0x07); // select G1 to read
                          wAvgGdata += msReadByte(SC5_35); //read line buffer data
                          // R
                          msWriteByteMask(SC5_33, 5, 0x07); // select R1 to read
                          wAvgRdata += msReadByte(SC5_35); //read line buffer data
                      }
C51 COMPILER V9.01   DRVADC                                                                03/09/2023 15:39:15 PAGE 43  

                  }
              
              #elif (CHIP_ID == CHIP_TSUMU) //
              
                  msWriteByteMask( SC5_33, ( LineBuf & 0x03 ) << 3, 0x18 ); // select to use which line buffer, 0 ~ 3
                  for( i = 0; i < AvgCnt/2; i++ )
                  {
                      msWrite2ByteMask( SC5_31, wLineBufAddress + ( i / 2 ), 0x1FFF ); // config line buffer address
                      wAvgRdata = wAvgRdata + msReadByte( SC5_35 ) + msReadByte( SC5_38 ); //read R0+R1 line buffer data
                      wAvgGdata = wAvgGdata + msReadByte( SC5_36 ) + msReadByte( SC5_39 ); //read G0+G1 line buffer data
                      wAvgBdata = wAvgBdata + msReadByte( SC5_37 ) + msReadByte( SC5_3A ); //read B0+B1 line buffer data
                  }
              
              #elif (CHIP_ID == CHIP_TSUMV || CHIP_ID == CHIP_TSUM2 || CHIP_ID == CHIP_TSUMC || CHIP_ID == CHIP_TSUMD ||
             - CHIP_ID == CHIP_TSUM9|| CHIP_ID == CHIP_TSUMF ) //
              
                  for( i = 0; i < AvgCnt; i++ )
                  {
                      msWrite2ByteMask( SC5_31, LineBuf*1500+wLineBufAddress + ( i / 3 ), 0x7FF ); // config line buffer
             - address
                      msWriteByteMask( SC5_33, i%3, 0x03 ); // [1:0] : LB packed pixel selection, 00: 1st pixel, 01: 2nd
             - pixel, 10: 3rd pixel
                      wAvgRdata += msReadByte( SC5_35 ); //read R0 line buffer data
                      wAvgGdata += msReadByte( SC5_36 ); //read G0 line buffer data
                      wAvgBdata += msReadByte( SC5_37 ); //read B0 line buffer data
                  }
              
              #endif
              
                  pAutoAdc.AVG_Bch = wAvgBdata/AvgCnt;
                  pAutoAdc.AVG_Gch = wAvgGdata/AvgCnt;
                  pAutoAdc.AVG_Rch = wAvgRdata/AvgCnt;
              
                  return pAutoAdc;
              }
              
              //**************************************************************************
              //  [Function Name]:
              //                  drvADC_AutoGainAdjustment()
              //  [Description]:
              //                  Adjust gain to approach target value 182(8 bits) => 255 * 0.5/0.7 = 182
              //  [Precondition]:
              //
              //  [Arguments]:
              //
              //  [Return]:
              //                  status
              //**************************************************************************
              static Bool drvADC_AutoGainAdjustment(void)
              {
                  xdata BYTE retry=11;
                  xdata BYTE CheckFlag=0x00;
                  xdata BYTE Diff;
                  xdata msADCAvgVal pAutoAdc_1_05V;
                  xdata msADCAvgVal pAutoAdc_0_55V;
                  xdata WORD InitADCGainVal = 0x0400;
                  xdata WORD rGain = InitADCGainVal;
                  xdata WORD gGain = InitADCGainVal;
                  xdata WORD bGain = InitADCGainVal;
                  xdata WORD GainOffset_R = InitADCGainVal >> 1;
                  xdata WORD GainOffset_G = InitADCGainVal >> 1;
                  xdata WORD GainOffset_B = InitADCGainVal >> 1;
C51 COMPILER V9.01   DRVADC                                                                03/09/2023 15:39:15 PAGE 44  

                  xdata BYTE Direction_R = 0;
                  xdata BYTE Direction_G = 0;
                  xdata BYTE Direction_B = 0;
              
              
                  // 5. Calibrate ADC R/G/B gain setting value
                  // Set R/G/B gain initial setting value at 0x0400
                  drvADC_Write2BytesMask(REG_ADC_DTOP_45_L, InitADCGainVal, 0x0FFF);
                  drvADC_Write2BytesMask(REG_ADC_DTOP_48_L, InitADCGainVal, 0x0FFF);
                  drvADC_Write2BytesMask(REG_ADC_DTOP_51_L, InitADCGainVal, 0x0FFF);
                  // Set ADC R/G/B Black and offset level to 0.8V(511)
                  drvADC_Write2BytesMask(REG_ADC_DTOP_44_L, 0x01FF, 0x03FF);
                  drvADC_Write2BytesMask(REG_ADC_DTOP_47_L, 0x01FF, 0x03FF);
                  drvADC_Write2BytesMask(REG_ADC_DTOP_50_L, 0x01FF, 0x03FF);
                  drvADC_Write2BytesMask(REG_ADC_DTOP_46_L, 0x01FF, 0x07FF);
                  drvADC_Write2BytesMask(REG_ADC_DTOP_49_L, 0x01FF, 0x07FF);
                  drvADC_Write2BytesMask(REG_ADC_DTOP_52_L, 0x01FF, 0x07FF);
              
                  // 6. Gain calibration target value for RGB color space mode is 182 (8bit data) 255 * 0.5 / 0.7 = 182
                  // 7. Get the ADC digital output with Turn-On LDO and Set VCAL to 1.05v
                  // 8. Get the ADC digital output with VCAL to 0.55v
                  // 9. Calculate the difference between 1.05V and 0.55V of these 3 channels.
                  //    Compare the difference value with target value (182 at RGB color space) to adjust R/G/B channel 
             -gain register
                  //_msADC_MaskExternalSync(TRUE);
              
                  while (retry--)
                  {
                      // Vcal = 1.05V
                      drvADC_SetInternalVcal(E_Vcal_1_05V);
                      ForceDelay1ms(16);
                      drvADC_IsReadLineBuffer(TRUE);
                      pAutoAdc_1_05V = drvADC_GetRGBLineBufAverageData(0x40, 0, 32); // (2*line buffer address + average
             - data) < SPRHDC: (2*64+32) < 240
                      drvADC_IsReadLineBuffer(FALSE);
                      // Vcal = 0.55V
                      drvADC_SetInternalVcal(E_Vcal_0_55V);
                      ForceDelay1ms(16);
                      drvADC_IsReadLineBuffer(TRUE);
                      pAutoAdc_0_55V = drvADC_GetRGBLineBufAverageData(0x40, 0, 32); // (2*line buffer address + average
             - data) < SPRHDC: (2*64+32) < 240
                      drvADC_IsReadLineBuffer(FALSE);
              
                      if ( (CheckFlag & BIT0) == 0 ) // Check Rch gain is approached target value or not
                      {
                          Diff = pAutoAdc_1_05V.AVG_Rch - pAutoAdc_0_55V.AVG_Rch;
                          //ADC_DPRINTF("R gain Diff value=%d\n", Diff);
                          if( (Diff >= AUTO_GAIN_RGB_MINVAL) && (Diff <= AUTO_GAIN_RGB_MAXVAL) )
                          {
                              CheckFlag|=BIT0; // Rch is calibrated completely
                              //ADC_DPUTSTR("Rch auto gain complete!!\n");
                          }
                          else
                          {
                              if (Diff < AUTO_GAIN_RGB_MINVAL )
                              {
                                  rGain += GainOffset_R;
                                  if ( retry == 2)
                                  {
                                      Direction_R = 1; //DownToUp
                                  }
                              }
C51 COMPILER V9.01   DRVADC                                                                03/09/2023 15:39:15 PAGE 45  

                              else   //(u16Diff>AUTO_GAIN_MAX )
                              {
                                  rGain-=GainOffset_R;
                                  if ( retry == 2)
                                  {
                                      Direction_R = 2; //DownToUp
                                  }
                              }
                              GainOffset_R=GainOffset_R>>1;
                          }
                      }
                      if ( (CheckFlag & BIT1) == 0x00 ) // Check Gch gain is approached target value or not
                      {
                          Diff = pAutoAdc_1_05V.AVG_Gch - pAutoAdc_0_55V.AVG_Gch;
                          //ADC_DPRINTF("G gain Diff value=%d\n", Diff);
                          if( (Diff >= AUTO_GAIN_RGB_MINVAL) && (Diff <= AUTO_GAIN_RGB_MAXVAL) )
                          {
                              CheckFlag|=BIT1;
                              //ADC_DPUTSTR("Gch auto gain complete !!\n");
                          }
                          else
                          {
                              if (Diff< AUTO_GAIN_RGB_MINVAL )
                              {
                                  gGain+=GainOffset_G;
                                  if ( retry == 2)
                                  {
                                      Direction_G = 1; //DownToUp
                                  }
                              }
                              else   //(u16Diff>AUTO_GAIN_MAX )
                              {
                                 gGain-=GainOffset_G;
                                 if ( retry == 2)
                                 {
                                     Direction_G = 2; //DownToUp
                                 }
                              }
                              GainOffset_G=GainOffset_G>>1;
                          }
                      }
                      if ( (CheckFlag & BIT2) == 0x00 )
                      {
                          Diff = pAutoAdc_1_05V.AVG_Bch - pAutoAdc_0_55V.AVG_Bch;
                          //ADC_DPRINTF("B gain Diff value=%d\n", Diff);
                          if( (Diff >= AUTO_GAIN_RGB_MINVAL) && (Diff <= AUTO_GAIN_RGB_MAXVAL) )
                          {
                              CheckFlag|=BIT2;
                              //ADC_DPUTSTR("Bch auto gain complete !!\n");
                          }
                          else
                          {
                              if (Diff< AUTO_GAIN_RGB_MINVAL )
                              {
                                  bGain+=GainOffset_B;
                                  if ( retry == 2)
                                  {
                                      Direction_B = 1; //DownToUp
                                  }
                              }
                              else   //(u16Diff>AUTO_GAIN_MAX )
                              {
C51 COMPILER V9.01   DRVADC                                                                03/09/2023 15:39:15 PAGE 46  

                                  bGain-=GainOffset_B;
                                  if ( retry == 2)
                                  {
                                      Direction_B = 2; //DownToUp
                                  }
                              }
                              GainOffset_B=GainOffset_B>>1;
                          }
                      }
                      if(retry==1)
                      {
                          if (Direction_R == 1)
                          {
                              rGain-=1;
                          }
                          else if (Direction_R == 2)
                          {
                              rGain+=1;
                          }
                          if (Direction_G == 1)
                          {
                              gGain-=1;
                          }
                          else if (Direction_G == 2)
                          {
                              gGain+=1;
                          }
                          if (Direction_B == 1)
                          {
                              bGain-=1;
                          }
                          else if (Direction_B == 2)
                          {
                              bGain+=1;
                          }
                          drvADC_Write2BytesMask(REG_ADC_DTOP_45_L, rGain, 0x0FFF);
                          drvADC_Write2BytesMask(REG_ADC_DTOP_48_L, gGain, 0x0FFF);
                          drvADC_Write2BytesMask(REG_ADC_DTOP_51_L, bGain, 0x0FFF);
                      }
                      else
                      {
                          drvADC_Write2BytesMask(REG_ADC_DTOP_45_L, rGain, 0x0FFF);
                          drvADC_Write2BytesMask(REG_ADC_DTOP_48_L, gGain, 0x0FFF);
                          drvADC_Write2BytesMask(REG_ADC_DTOP_51_L, bGain, 0x0FFF);
                      }
                      if((CheckFlag&0x07)==0x07)
                          break;
                  }
              
                  if ((CheckFlag&0x07)==0x07)
                  {
                      ADC_DPUTSTR("Auto gain OK");
                      UserPrefAdcRedGain = rGain;
                      UserPrefAdcGreenGain = gGain;
                      UserPrefAdcBlueGain = bGain;
                      ADC_DPRINTF("Rgain = 0x%x", rGain);
                      ADC_DPRINTF("Ggain = 0x%x", gGain);
                      ADC_DPRINTF("Bgain = 0x%x", bGain);
                      return TRUE;
                  }
                  else
                  {
C51 COMPILER V9.01   DRVADC                                                                03/09/2023 15:39:15 PAGE 47  

                      ADC_DPUTSTR("Auto gain fail !!\n");
                      ADC_DPRINTF("Rgain = 0x%x", rGain);
                      ADC_DPRINTF("Ggain = 0x%x", gGain);
                      ADC_DPRINTF("Bgain = 0x%x", bGain);
                      return FALSE;
                  }
              }
              #endif //#if ((_DGAIN_CAL_WITH_INPUT_) || (_DGAIN_CAL_WITHOUT_INPUT_))
2750          #if _DGAIN_CAL_WITH_INPUT_
              //**************************************************************************
              //  [Function Name]:
              //                  drvADC_FindWhiteRegion()
              //  [Description]:
              //                  Find the white region in line buffer
              //  [Precondition]:
              //
              //  [Arguments]:
              //                 LineBuf: choose one line to read, 0 ~ 3
              //                 Step: comparsion step
              //  [Return]:
              //                  status
              //**************************************************************************
              static WORD drvADC_FindWhiteRegion(BYTE LineBuf, BYTE Step)
              {
                  BYTE i, eqcount=0;
                  msADCAvgVal pAutoAdc_val, pAutoAdc_preval;
                  WORD wStartAdd_White = 0;
              
                  pAutoAdc_preval.AVG_Rch = pAutoAdc_preval.AVG_Gch = pAutoAdc_preval.AVG_Bch = 0;
              
                  drvADC_IsReadLineBuffer(TRUE);
                  for(i=0;i<255;i++)
                  {
                      pAutoAdc_val = drvADC_GetRGBLineBufAverageData(wStartAdd_White+(i*Step), LineBuf, 1); // (2*line b
             -uffer address + average data) < SPRHDC: (2*64+32) < 240
                      if(pAutoAdc_preval.AVG_Gch > (pAutoAdc_val.AVG_Gch + 5))
                      {
                          pAutoAdc_val = drvADC_GetRGBLineBufAverageData(wStartAdd_White+(i*Step)+2, LineBuf, 1);
                          if(pAutoAdc_preval.AVG_Gch > (pAutoAdc_val.AVG_Gch + 5))
                          {
                              pAutoAdc_val = drvADC_GetRGBLineBufAverageData(wStartAdd_White+(i*Step)+4, LineBuf, 1);   
             -       
                              if(pAutoAdc_preval.AVG_Gch > (pAutoAdc_val.AVG_Gch + 5))
                              {               
                                  if(eqcount>=1)
                                      i -= (eqcount > 1 ? (eqcount/2) : 1);
                                  wStartAdd_White += ((i-1)*Step);
                                  ADC_DPRINTF("@@ pre_val = %d", pAutoAdc_val.AVG_Gch);
                                  break;
                              }
                          }
                          eqcount = 0;
                          pAutoAdc_preval.AVG_Rch = pAutoAdc_val.AVG_Rch;
                          pAutoAdc_preval.AVG_Gch = pAutoAdc_val.AVG_Gch;
                          pAutoAdc_preval.AVG_Bch = pAutoAdc_val.AVG_Bch;
                      }
                      else if( (abs(pAutoAdc_preval.AVG_Rch -pAutoAdc_val.AVG_Rch) <=2) && (abs(pAutoAdc_preval.AVG_Gch 
             --pAutoAdc_val.AVG_Gch) <=2) &&
                                      (abs(pAutoAdc_preval.AVG_Bch -pAutoAdc_val.AVG_Bch) <=2) )
                      {
                          eqcount++;
                      }
C51 COMPILER V9.01   DRVADC                                                                03/09/2023 15:39:15 PAGE 48  

                      else
                      {
                          eqcount = 0;
                          pAutoAdc_preval.AVG_Rch = pAutoAdc_val.AVG_Rch;
                          pAutoAdc_preval.AVG_Gch = pAutoAdc_val.AVG_Gch;
                          pAutoAdc_preval.AVG_Bch = pAutoAdc_val.AVG_Bch;
                          if((i%5) == 0)
                              ADC_DPRINTF("@@ R_val = %d", pAutoAdc_preval.AVG_Gch);
                      }
                  }
                      
                  if( (wStartAdd_White == 0) && (eqcount > 0) )
                  {
                      i -= (eqcount > 1 ? (eqcount/2) : 1);
                      wStartAdd_White = ((i-1)*Step);
                  }
              
                  drvADC_IsReadLineBuffer(FALSE);
                  {
                      ADC_DPRINTF("@@EQCount = %d\r\n", eqcount);
                      ADC_DPRINTF("@@EQVal_R = %d\r\n", pAutoAdc_preval.AVG_Rch);
                      ADC_DPRINTF("@@EQVal_G = %d\r\n", pAutoAdc_preval.AVG_Gch);
                      ADC_DPRINTF("@@EQVal_B = %d\r\n", pAutoAdc_preval.AVG_Bch);
                  }
                  ADC_DPRINTF("@@Line Buffer Start Address = %d\r\n", wStartAdd_White);
                  return wStartAdd_White;
              }
              
              
              //**************************************************************************
              //  [Function Name]:
              //                  _msADC_AutoGainAdjustment()
              //  [Description]:
              //                  Adjust gain to approach target value 182(8 bits) => 255 * 0.5/0.7 = 182
              //  [Precondition]:
              //
              //  [Arguments]:
              //                 wLineBufAddress: line buffer address, it should be less than PG Htotal
              //                 LineBuf: choose one line to read, 0 ~ 3
              //                 AvgCnt: average pixel count
              //  [Return]:
              //                  status
              //**************************************************************************
              static Bool drvADC_AutoGainAdjustment_WithInput(WORD wLineBufAddress, BYTE LineBuf, BYTE AvgCnt)
              {
                  msADCAvgVal pAutoAdc_val;
                  WORD rGain, gGain, bGain;
                  WORD maxRGain, maxGGain, maxBGain;
                  WORD minRGain, minGGain, minBGain;
                  BYTE retry=12;
                  BYTE atgFlags=0;
              
                  maxRGain=maxGGain=maxBGain=0xFFF;
                  minRGain=minGGain=minBGain=0;
              
                  while (retry--)
                  {
                      rGain=((WORD)maxRGain+minRGain)/2;
                      gGain=((WORD)maxGGain+minGGain)/2;
                      bGain=((WORD)maxBGain+minBGain)/2;
                      drvADC_SetRGBGainCode(rGain, gGain, bGain);
                      Delay1ms(20);
C51 COMPILER V9.01   DRVADC                                                                03/09/2023 15:39:15 PAGE 49  

                      drvADC_IsReadLineBuffer(TRUE);
                      pAutoAdc_val = drvADC_GetRGBLineBufAverageData(wLineBufAddress, LineBuf, AvgCnt); // (2*line buffe
             -r address + average data) < SPRHDC: (2*64+32) < 240
                      drvADC_IsReadLineBuffer(FALSE);
              
                      if (pAutoAdc_val.AVG_Rch >= 255)
                      {
                          rGain--;
                          atgFlags |= DGain_OverFlow_R_ch;
                      }
                      else
                      {
                          rGain++;
                          atgFlags |= DGain_NoneOverFlow_R_ch;
                      }
              
                      if (pAutoAdc_val.AVG_Gch >= 255)
                      {
                          gGain--;
                          atgFlags |= DGain_OverFlow_G_ch;
                      }
                      else
                      {
                          gGain++;
                          atgFlags |= DGain_NoneOverFlow_G_ch;
                      }
              
                      if (pAutoAdc_val.AVG_Bch >= 255)
                      {
                          bGain--;
                          atgFlags |= DGain_OverFlow_B_ch;
                      }
                      else
                      {
                          bGain++;
                          atgFlags |= DGain_NoneOverFlow_B_ch;
                      }
              
                      drvADC_SetRGBGainCode(rGain, gGain, bGain);
                      Delay1ms(20);
                      drvADC_IsReadLineBuffer(TRUE);
                      pAutoAdc_val = drvADC_GetRGBLineBufAverageData(wLineBufAddress, LineBuf, AvgCnt); // (2*line buffe
             -r address + average data) < SPRHDC: (2*64+32) < 240
                      drvADC_IsReadLineBuffer(FALSE);
              
                      if (pAutoAdc_val.AVG_Rch >= 255)
                      {
                          maxRGain=rGain+1;
                          atgFlags |= DGain_OverFlow_R_ch;
                      }
                      else
                      {
                          minRGain=rGain-1;
                          atgFlags |= DGain_NoneOverFlow_R_ch;
                      }
              
                      if (pAutoAdc_val.AVG_Gch >= 255)
                      {
                          maxGGain=gGain+1;
                          atgFlags |= DGain_OverFlow_G_ch;
                      }
                      else
C51 COMPILER V9.01   DRVADC                                                                03/09/2023 15:39:15 PAGE 50  

                      {
                          minGGain=gGain-1;
                          atgFlags |= DGain_NoneOverFlow_G_ch;
                      }
              
                      if (pAutoAdc_val.AVG_Bch >= 255)
                      {
                          maxBGain=bGain+1;
                          atgFlags |= DGain_OverFlow_B_ch;
                      }
                      else
                      {
                          minBGain=bGain-1;
                          atgFlags |= DGain_NoneOverFlow_B_ch;
                      }
                              if (CheckSyncLoss())//||CheckPowerKeyStatus())                          
                      //if (_msADC_CheckSyncLoss())
                          return FALSE;
                  }
              
              
              
                  UserPrefAdcRedGain=rGain-1;
                  UserPrefAdcGreenGain=gGain-1;
                  UserPrefAdcBlueGain=bGain-1;
                  drvADC_SetRGBGainCode(UserPrefAdcRedGain, UserPrefAdcGreenGain, UserPrefAdcBlueGain);
                      
                  if ((atgFlags&0xFC)!=0xFC)
                  {
                      ADC_DPUTSTR("Auto gain fail !!\n");
                      ADC_DPRINTF("Rgain = 0x%x", rGain);
                      ADC_DPRINTF("Ggain = 0x%x", gGain);
                      ADC_DPRINTF("Bgain = 0x%x", bGain);
                      return FALSE;
                  }
                  else
                  {
                      ADC_DPUTSTR("Auto gain OK");
                      ADC_DPRINTF("Rgain = 0x%x", rGain);
                      ADC_DPRINTF("Ggain = 0x%x", gGain);
                      ADC_DPRINTF("Bgain = 0x%x", bGain);
                      return TRUE;
                  }
              }
              
              #endif //#ifdef(_DGAIN_CAL_WITH_INPUT_)
2969          void drvADC_SetHsyncRefLevel(ADC_HSYNCLVL_T level)
2970          {
2971   1          msWriteByteMask(REG_ADC_ATOP_20_L, level, 0x07);
2972   1      }
2973          
2974          #if 0
              
              void drvADC_Test_Funct(BYTE tb1, BYTE tb2)
              {
                  BYTE uncallvalue = tb2;
              
                  switch(tb1)
                  {
                      case 0: // mismatch calibration
                          drvADC_ADCOffsetGainMismatchCal();
                          break;
C51 COMPILER V9.01   DRVADC                                                                03/09/2023 15:39:15 PAGE 51  

              #if 0
                      case 1: // auto gain with input
                          msADC_ADCAutoGainCalwithInput();
                          break;
                      case 2: // auto gain without input
                          switch(tb2)
                          {
                              case 0:
                                  // 1. backup ADC and Scaler related settings
                                  _msADC_BackupADCSetting();
                                  _msADC_BackupScalerSetting();
              
                                  // 2. Set free run clock at 720p
                                  _msADC_SetFreeRunClock();
                                  break;
                              case 1:
                                  // 3. Enable scaler pattern generator to generate Hsync and Vsync for line buffer
                                  _msADC_EnableScalerPG( E_PG_Htotal_256 );
                                  break;
                              case 2:
                                  // 4. Set ADC input LPF to lowest bandwidth
                                  _msADC_Write2BytesMask( REG_ADC_ATOP_23_L, 0xFFFF, 0xFFFF );
                                  _msADC_Write2BytesMask( REG_ADC_ATOP_24_L, 0x00FF, 0x00FF );
                                  break;
                              case 3:
                                  // 5. Calibrate ADC R/G/B gain setting value
                                  // Set R/G/B gain initial setting value at 0x0400
                                  // 6. Gain calibration target value for RGB color space mode is 182 (8bit data) 255 * 
             -0.5 / 0.7 = 182
                                  // 7. Get the ADC digital output with Turn-On LDO and Set VCAL to 1.05v
                                  // 8. Get the ADC digital output with VCAL to 0.55v
                                  // 9. Calculate the difference between 1.05V and 0.55V of these 3 channels.
                                  //    Compare the difference value with target value (182 at RGB color space) to adjus
             -t R/G/B channel gain register
                                  _msADC_AutoGainAdjustment();
                                  break;
                              case 4:
                                  // 10. recover ADC and scaler related settings & turn off free run clock & turn off in
             -ternal Vcal
                                  _msADC_RecoverADCSetting();
                                  _msADC_RecoverScalerSetting();
                                  break;
              
                              case 5:
                                  msADC_ADCAutoGainCalwithoutInput();
                                  break;
                          }
                          break;
              #endif
                      case 3:
                          drvADC_AutoAdcColor(20);
                          break;
                      case 4:
                          break;
              #if _DGAIN_CAL_WITHOUT_INPUT_
                      case 5:
                              drvADC_AutoGainAdjustment();
                          break;
              
                      case 6:
                          drvADC_ADCAutoGainCalwithoutInput();
                          break;
C51 COMPILER V9.01   DRVADC                                                                03/09/2023 15:39:15 PAGE 52  

                          
                      case 7:
                          ADC_DPUTSTR("LDO:");
                          //drvADC_ADCAutoGainCalwithoutInput();
                          //_msADC_SetInternalVcal(E_Vcal_1_05V);
                          {
                          msADCAvgVal ptmp;
                          msADCAvgVal pAutoAdc_val;
              
                          // 1. backup ADC and Scaler related settings
                          drvADC_BackupADCSetting();
                          drvADC_BackupScalerSetting();
                          
                          // 2. Set free run clock at 720p
                          drvADC_SetFreeRunClock();
                          _msADC_MaskExternalSync(TRUE);            
                          
                          // 3. Enable scaler pattern generator to generate Hsync and Vsync for line buffer
                          drvADC_EnableScalerPG(E_PG_Htotal_256);
                          
                          // 4. Set ADC input LPF to lowest bandwidth
                          drvADC_Write2BytesMask(REG_ADC_ATOP_23_L, 0xFFFF, 0xFFFF);
                          drvADC_Write2BytesMask(REG_ADC_ATOP_24_L, 0x00FF, 0x00FF);
              
                          msWrite2ByteMask(REG_ADC_ATOP_34_L, BIT0, BIT0); // turn on LDO
                          msWrite2ByteMask(REG_ADC_ATOP_54_L, 0, 0xF800); // disable bandgap overwrite
                          msWrite2ByteMask(REG_ADC_ATOP_34_L, BIT2, BIT2); // LDO, Aaron test
                          msWrite2ByteMask(REG_ADC_ATOP_54_L, 0x0003, 0x0003); // set Vcal = 1.05V
                          msWrite2ByteMask(REG_ADC_ATOP_54_L, 0x000C, 0x000C); // set Vcal from LDO
                          msWrite2ByteMask(REG_ADC_ATOP_54_L, 0x0600, 0x0700); // turn on Gcal pulse
              
                          Delay1ms(1500);
                          drvADC_IsReadLineBuffer(TRUE);
                          ptmp = drvADC_GetRGBLineBufAverageData(0x40, 0, 32); // (2*line buffer address + average data)
             - < SPRHDC: (2*64+32) < 240
                          drvADC_IsReadLineBuffer(FALSE);
                          
                          msWrite2ByteMask(REG_ADC_ATOP_34_L, BIT0, BIT0); // turn on LDO
                          msWrite2ByteMask(REG_ADC_ATOP_34_L, BIT2, BIT2); // LDO, Aaron test
                          msWrite2ByteMask(REG_ADC_ATOP_54_L, 0x0002, 0x0003); // set Vcal = 0.55V
                          msWrite2ByteMask(REG_ADC_ATOP_54_L, 0x000C, 0x000C); // set Vcal from LDO
                          msWrite2ByteMask(REG_ADC_ATOP_54_L, 0x0600, 0x0700); // turn on Gcal pulse
              
                          Delay1ms(1500);
                          drvADC_IsReadLineBuffer(TRUE);
                          pAutoAdc_val = drvADC_GetRGBLineBufAverageData(0x40, 0, 32); // (2*line buffer address + avera
             -ge data) < SPRHDC: (2*64+32) < 240
                          drvADC_IsReadLineBuffer(FALSE);
              
                          // 10. recover ADC and scaler related settings & turn off free run clock & turn off internal V
             -cal
                          _msADC_MaskExternalSync(FALSE);
                          drvADC_RecoverADCSetting();
                          drvADC_RecoverScalerSetting();
                          
                          ADC_DPRINTF("AVG_R_1.05V= 0x%x", ptmp.AVG_Rch);
                          ADC_DPRINTF("AVG_G_1.05V = 0x%x", ptmp.AVG_Gch);
                          ADC_DPRINTF("AVG_B_1.05V = 0x%x", ptmp.AVG_Bch);
                          ADC_DPRINTF("AVG_R_0.55V = 0x%x", pAutoAdc_val.AVG_Rch);
                          ADC_DPRINTF("AVG_G_0.55V = 0x%x", pAutoAdc_val.AVG_Gch);
                          ADC_DPRINTF("AVG_B_0.55V = 0x%x", pAutoAdc_val.AVG_Bch);    
                          ADC_DPRINTF("AVG_R_diff = 0x%x", ptmp.AVG_Rch - pAutoAdc_val.AVG_Rch);
C51 COMPILER V9.01   DRVADC                                                                03/09/2023 15:39:15 PAGE 53  

                          ADC_DPRINTF("AVG_G_diff = 0x%x", ptmp.AVG_Gch - pAutoAdc_val.AVG_Gch);
                          ADC_DPRINTF("AVG_B_diff = 0x%x", ptmp.AVG_Bch - pAutoAdc_val.AVG_Bch);  
                          }
                          break;
                      case 8:
                          ADC_DPUTSTR("Get:");
                          //drvADC_ADCAutoGainCalwithoutInput();
                          //_msADC_SetInternalVcal(E_Vcal_1_05V);
                          {
                          msADCAvgVal ptmp;
              
                          drvADC_IsReadLineBuffer(TRUE);
                          ptmp = drvADC_GetRGBLineBufAverageData(0x40, 0, 32); // (2*line buffer address + average data)
             - < SPRHDC: (2*64+32) < 240
                          drvADC_IsReadLineBuffer(FALSE);
                          
                          ADC_DPRINTF("AVG_R = 0x%x", ptmp.AVG_Rch);
                          ADC_DPRINTF("AVG_G = 0x%x", ptmp.AVG_Gch);
                          ADC_DPRINTF("AVG_B = 0x%x", ptmp.AVG_Bch);
                          }
                          break;
              #endif
                  }
              }
              #endif // #if DEBUG_EN
3127          
3128          
3129          #else
              
              #if DUMMY_CODE_4_LINK_FILE
              BYTE code DrvADCDummy[]={0xFF};
              #endif
              
              #endif //ENABLE_VGA_INPUT
3136          //Jison 110314
3137          void drvADC_PowerCtrl(BYTE u8State)
3138          {
3139   1          if(u8State==ADC_POWER_ON)
3140   1          {
3141   2              msWrite2Byte( REG_ADC_ATOP_04_L, 0x0000 );  // set power-on default value to power down ADC
3142   2              msWriteByteMask(REG_ADC_ATOP_06_L, 0, 0xFF); // ADC clock power on
3143   2              msWriteByteMask(REG_ADC_ATOP_30_L, 0, BIT0); // on-line SOG MUX power on
3144   2      #if _NEW_SOG_DET_ //(SC0_ED[5]==0 while power saving)
                      msWrite2Byte( REG_ADC_ATOP_78_L, 0x0002 );  // set power-on default value to power down ADC
                      msWrite2Byte(REG_ADC_ATOP_79_L, 0x00C8); // ADC clock power down
                      msWriteByteMask(REG_ADC_ATOP_7A_L, BIT2, BIT2|BIT1); // on-line SOG MUX power on
              #endif
3149   2              Delay1ms(10);
3150   2              msWrite2ByteMask(REG_ADC_ATOP_11_L, BIT8, BIT8); // ADC phase alignment trigger
3151   2              msWrite2ByteMask(REG_ADC_ATOP_11_L, 0, BIT8);    // ADC phase alignment trigger
3152   2          }
3153   1          else if(u8State==ADC_POWER_STANDBY)
3154   1          {
3155   2            #if !MS_PM //seperate only
                      msWrite2Byte( REG_ADC_ATOP_04_L, 0x3FFF );  // set power-on default value to power down ADC
                      msWriteByteMask(REG_ADC_ATOP_06_L, 0xFF, 0xFF); // ADC clock power on
                      msWriteByteMask(REG_ADC_ATOP_30_L, BIT0, BIT0); // on-line SOG MUX power down
                    #else //saperate & SOG support
3160   2              #if _NEW_SOG_DET_ //(SC0_ED[5]==0 while power saving)
                      msWrite2Byte( REG_ADC_ATOP_78_L, 0x0002 );  // set power-on default value to power down ADC
                      msWrite2Byte(REG_ADC_ATOP_79_L, 0x00C8); // ADC clock power down
                      msWriteByteMask(REG_ADC_ATOP_7A_L, BIT2, BIT2|BIT1); // on-line SOG MUX power on
C51 COMPILER V9.01   DRVADC                                                                03/09/2023 15:39:15 PAGE 54  

                      #endif
3165   2              msWrite2Byte( REG_ADC_ATOP_04_L, 0x79F9 );  // set power-on default value to power down ADC
3166   2              msWriteByteMask(REG_ADC_ATOP_06_L, 0, 0xFF); // ADC clock power on
3167   2              msWriteByteMask(REG_ADC_ATOP_30_L, 0, BIT0); // on-line SOG MUX power on
3168   2      
3169   2            #endif
3170   2          }
3171   1          else //ADC_POWER_DOWN
3172   1          {
3173   2      #if ((CHIP_ID == CHIP_TSUMC) || (CHIP_ID == CHIP_TSUMD) || (CHIP_ID == CHIP_TSUM9 )|| (CHIP_ID == CHIP_TSU
             -MF ))
3174   2              msWrite2Byte( REG_ADC_ATOP_04_L, 0xFFFF );  //  power down ADC
3175   2      #else
                      msWrite2Byte( REG_ADC_ATOP_04_L, 0x7FFF );  //  power down ADC
              #endif
3178   2              
3179   2      #if _NEW_SOG_DET_ //(SC0_ED[5]==0 while power saving)
                      msWrite2Byte( REG_ADC_ATOP_78_L, 0x0000 );  // set power-on default value to power down ADC
                      msWrite2Byte(REG_ADC_ATOP_79_L, 0x0000); // ADC clock power down
                      msWriteByteMask(REG_ADC_ATOP_7A_L, 0, BIT2|BIT1); // on-line SOG MUX power on
              #endif
3184   2              msWriteByteMask(REG_ADC_ATOP_06_L, 0xFF, 0xFF); // ADC clock power down
3185   2              msWriteByteMask(REG_ADC_ATOP_30_L, BIT0, BIT0); // on-line SOG MUX power down
3186   2          }
3187   1      }
3188          
3189          #endif // _DRVADC_C_


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   6301    ----
   CONSTANT SIZE    =   2092    ----
   XDATA SIZE       =     57      93
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      80
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

C51 COMPILER V9.01   MSOSDFUNCTION                                                         03/09/2023 15:39:11 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE MSOSDFUNCTION
OBJECT MODULE PLACED IN .\obj\msOSDFunction.obj
COMPILER INVOKED BY: D:\Keil4\C51\BIN\C51.EXE ..\..\UI\HkcOsd\msOSDFunction.c OPTIMIZE(SIZE) BROWSE INCDIR(..\..\DRIVER\
                    -INC;..\..\KERNEL\SCALER\INC;..\..\KERNEL\SYSTEM\INC;..\..\LIB\INC;..\..\PANEL\INC;..\..\BOARD;..\..\DRIVER\INC;..\..\KER
                    -NEL\SYSTEM\INC\AOC2011;..\..\DRIVER\extDEVICE\INC;..\..\MODEL;..\..\CONFIG;..\..\PANEL;..\..\UI\F_LOGO\INC;..\..\UI\HkcO
                    -sd\INC) DEFINE(ModelName=JRY_TESTBOARD_C_BOARD) DEBUG OBJECTEXTEND PRINT(.\list\msOSDFunction.lst) OBJECT(.\obj\msOSDFun
                    -ction.obj)

line level    source

   1          #include "global.h"
   2          #include "msosd.h"
   3          #include "drvosd.h"
   4          #include "adjust.h"
   5          // setup osd window size
   6          /*
   7          
   8          #define WAIT_V_OUTPUT_BLANKING_START()   { if(!SyncLossState()&&PanelOnFlag){SetTimOutConter(30);while(((m
             -sReadByte(SC0_E0)&BIT0)==0)&&bTimeOutCounterFlag);\
   9                                                  SetTimOutConter(30);while(((msReadByte(SC0_E0)&BIT0)!=0)&&bTimeOut
             -CounterFlag);}}//20130227 modify for DC OFF issue
  10          */
  11          void Osd_SetWindowSize(BYTE width, BYTE height)
  12          {
  13   1          OsdWindowWidth = width;
  14   1          OsdWindowHeight = height;
  15   1      
  16   1      #if CHIP_ID>=CHIP_TSUMV
  17   1              //bReset=bReset;
  18   1              drvOSD_SetWndLineOffset(OSD_MAIN_WND,OsdWindowWidth); //for OSD_MAIN_WND only
  19   1        #if 0//ENABLE_OSD_ROTATION //reset CABase addr after line offset was set
                      if (MENU_ROTATION_FLAG)
                              drvOSD_SetWndCABaseAddr(OSD_MAIN_WND, GET_CABASE_0_90(OSD_MAIN_WND_CA_BASE, OsdWindowWidth));
                      else
                              drvOSD_SetWndCABaseAddr(OSD_MAIN_WND, OSD_MAIN_WND_CA_BASE);
                #endif
  25   1      #else
                  msWriteByte(OSD1_06, OsdWindowWidth-1);
                  msWriteByte(OSD1_07, OsdWindowHeight-1);
                  //if(bReset)
                  {
                      //msWriteByte(OSD2_A0, 0xDE); // clear osd content
                      //ForceDelay1ms(3);
                  }
                  msWriteByte(OSD2_A0, 0xBE);
              #endif
  35   1      }
  36          
  37          #if CHIP_ID>=CHIP_TSUMV
  38          // setup osd parence
  39          void Osd_SetTransparence(BYTE value)
  40          {
  41   1         if(value==0)
  42   1          {
  43   2              msWriteByte(OSD2_2C, 0x3F);
  44   2              msWriteByte(OSD2_6C, 0x3F);
  45   2          }
  46   1         else if(value==1)
  47   1          {
  48   2              msWriteByte(OSD2_2C, 0x32);
  49   2              msWriteByte(OSD2_6C, 0x32);
C51 COMPILER V9.01   MSOSDFUNCTION                                                         03/09/2023 15:39:11 PAGE 2   

  50   2          }
  51   1         else if(value==2)
  52   1          {
  53   2              msWriteByte(OSD2_2C, 0x28);
  54   2      
  55   2              msWriteByte(OSD2_6C, 0x28);
  56   2          }
  57   1         else if(value==3)
  58   1          {
  59   2              msWriteByte(OSD2_2C, 0x21);
  60   2              msWriteByte(OSD2_6C, 0x21);
  61   2          }
  62   1         else if(value==4)
  63   1          {
  64   2              msWriteByte(OSD2_2C, 0x1A);
  65   2              msWriteByte(OSD2_6C, 0x1A);
  66   2          }
  67   1      
  68   1          //msWriteByte(BLENDL, value);
  69   1      }
  70          #elif CHIP_ID==CHIP_TSUMB
              void Osd_SetTransparence(BYTE value)
              {
                  if(value>0)
                       value=value+1;
                  
                      if(value==2)
                          msWriteByte(OSD2_4A, 0x40 );
                      else if(value==3)
                          msWriteByte(OSD2_4A, 0x60 );
                      else if(value==4)
                          msWriteByte(OSD2_4A, 0x80 );
                      else if(value==5)
                          msWriteByte(OSD2_4A, 0xA0);
                      else 
                          msWriteByte(OSD2_4A, 0x00 );
              }
              
              #else
              void Osd_SetTransparence(BYTE value)
              {
                  if(value>0)
                       value=value+1;
                      msWriteByte(REG_2F4C, (0x00|value) );
              }
              
              #endif
  97          
  98          // setup
  99          #define MainMenuOSD_Height      21
 100          #define OSD_TRANSPARENT_SHIFT   7
 101          #if CHIP_ID>=CHIP_TSUMV
 102          #define OSD_WINDOW(Addr)    ((OSD_MAIN_WND<<5)+Addr)
 103          void Osd_SetPosition( BYTE xPos, BYTE yPos )
 104          {
 105   1      #if 0//ENABLE_MENULOAD  //111223 Modify
                              WORD  HposValue, VposValue;
              
                              if(PanelWidth<(( WORD )OsdWindowWidth*12))      //120115 Modify
                                      HposValue = 0;
                              else
                                      HposValue = (( DWORD )xPos * ( PanelWidth - ( WORD )OsdWindowWidth * 12 ) ) / 100;
C51 COMPILER V9.01   MSOSDFUNCTION                                                         03/09/2023 15:39:11 PAGE 3   

                      
                              yPos = 100 - yPos;
                              VposValue = (( DWORD )yPos * ( PanelHeight - ( WORD )OsdWindowHeight * 18 ) ) / 100;
                              if( yPos == 100 && OsdWindowHeight == MainMenuOSD_Height )
                                      VposValue += OSD_TRANSPARENT_SHIFT;
                              
                              if (ucOSDMenuMoveType)
                              {
                                      WORD wTemp = VposValue+( WORD )OsdWindowHeight * 18;
                                      
                                      mStar_WaitForDataBlanking(); 
                                      if (ucOSDMenuMoveType == OSDMoveType_Setting)
                                      {
                                              //drvOSD_SetWndVPosition(OSD_MAIN_WND, wTemp, VposValue+( WORD )OsdWindowHeight * 18);
                                              msML_WaitReady();
                                              msML_WriteByte(ML_MODE_NORMAL ,OSD_WINDOW(OSD2_04), HposValue);
                                              msML_WriteByte(ML_MODE_NORMAL ,OSD_WINDOW(OSD2_05), HposValue>>8);
                                              if(PanelWidth<(( WORD )OsdWindowWidth*12))      //120115 Modify
                                              {
                                                      msML_WriteByte(ML_MODE_NORMAL ,OSD_WINDOW(OSD2_08), (HposValue+PanelWidth));
                                                      msML_WriteByte(ML_MODE_NORMAL ,OSD_WINDOW(OSD2_09), (HposValue+PanelWidth)>>8);
                                              }
                                              else
                                              {
                                                      msML_WriteByte(ML_MODE_NORMAL ,OSD_WINDOW(OSD2_08), (HposValue+( WORD )OsdWindowWidth * 12));
                                                      msML_WriteByte(ML_MODE_NORMAL ,OSD_WINDOW(OSD2_09), (HposValue+( WORD )OsdWindowWidth * 12)>>8);
                                              }
                                              msML_WriteByte(ML_MODE_NORMAL ,OSD_WINDOW(OSD2_06), wTemp);
                                              msML_WriteByte(ML_MODE_NORMAL ,OSD_WINDOW(OSD2_07), wTemp>>8);
                                              msML_WriteByte(ML_MODE_NORMAL ,OSD_WINDOW(OSD2_0A), (VposValue+( WORD )OsdWindowHeight * 18));
                                              msML_WriteByte(ML_MODE_NORMAL ,OSD_WINDOW(OSD2_0B), (VposValue+( WORD )OsdWindowHeight * 18)>>8);
                                              msML_Trigger(ML_TRIG_OUT_VDE_END);// Vde-end-OP
                                      }
                                      else if (ucOSDMenuMoveType == OSDMoveType_Main)
                                      {       
                                              do {
                                                              wTemp--;
                                                              Delay1ms(OSDMoveSpeed);
                                                              //drvOSD_SetWndVPosition(OSD_MAIN_WND, wTemp, posValue+( WORD )OsdWindowHeight * 18);
                                                              //msML_WaitReady();
                                                              msML_WriteByte(ML_MODE_NORMAL ,OSD_WINDOW(OSD2_04), HposValue);
                                                              msML_WriteByte(ML_MODE_NORMAL ,OSD_WINDOW(OSD2_05), HposValue>>8);
                                                              if(PanelWidth<(( WORD )OsdWindowWidth*12))      //120115 Modify
                                                              {
                                                                      msML_WriteByte(ML_MODE_NORMAL ,OSD_WINDOW(OSD2_08), (HposValue+PanelWidth));
                                                                      msML_WriteByte(ML_MODE_NORMAL ,OSD_WINDOW(OSD2_09), (HposValue+PanelWidth)>>8);
                                                              }
                                                              else
                                                              {
                                                                      msML_WriteByte(ML_MODE_NORMAL ,OSD_WINDOW(OSD2_08), (HposValue+( WORD )OsdWindowWidth * 12));
                                                                      msML_WriteByte(ML_MODE_NORMAL ,OSD_WINDOW(OSD2_09), (HposValue+( WORD )OsdWindowWidth * 12)>>8);
                                                              }
                                                              msML_WriteByte(ML_MODE_NORMAL ,OSD_WINDOW(OSD2_06), wTemp);
                                                              msML_WriteByte(ML_MODE_NORMAL ,OSD_WINDOW(OSD2_07), wTemp>>8);
                                                              msML_WriteByte(ML_MODE_NORMAL ,OSD_WINDOW(OSD2_0A), (VposValue+( WORD )OsdWindowHeight * 18));
                                                              msML_WriteByte(ML_MODE_NORMAL ,OSD_WINDOW(OSD2_0B), (VposValue+( WORD )OsdWindowHeight * 18)>>8);
                                                              msML_Trigger(ML_TRIG_OUT_VDE_END);// Vde-end-OP                                 
                                                 }while(wTemp!=VposValue);
                                      }
                                      else if (ucOSDMenuMoveType == OSDMoveType_Root)
                                      {       
                                              do {
C51 COMPILER V9.01   MSOSDFUNCTION                                                         03/09/2023 15:39:11 PAGE 4   

                                                              VposValue++;
                                                              Delay1ms(OSDMoveSpeed);
                                                              //drvOSD_SetWndVPosition(OSD_MAIN_WND, posValue, wTemp);
                                                              //msML_WaitReady();
                                                              msML_WriteByte(ML_MODE_NORMAL ,OSD_WINDOW(OSD2_04), HposValue);
                                                              msML_WriteByte(ML_MODE_NORMAL ,OSD_WINDOW(OSD2_05), HposValue>>8);
                                                              if(PanelWidth<(( WORD )OsdWindowWidth*12))      //120115 Modify
                                                              {
                                                                      msML_WriteByte(ML_MODE_NORMAL ,OSD_WINDOW(OSD2_08), (HposValue+PanelWidth));
                                                                      msML_WriteByte(ML_MODE_NORMAL ,OSD_WINDOW(OSD2_09), (HposValue+PanelWidth)>>8);
                                                              }
                                                              else
                                                              {
                                                                      msML_WriteByte(ML_MODE_NORMAL ,OSD_WINDOW(OSD2_08), (HposValue+( WORD )OsdWindowWidth * 12));
                                                                      msML_WriteByte(ML_MODE_NORMAL ,OSD_WINDOW(OSD2_09), (HposValue+( WORD )OsdWindowWidth * 12)>>8);
                                                              }
                                                              msML_WriteByte(ML_MODE_NORMAL ,OSD_WINDOW(OSD2_06), VposValue);
                                                              msML_WriteByte(ML_MODE_NORMAL ,OSD_WINDOW(OSD2_07), VposValue>>8);
                                                              msML_WriteByte(ML_MODE_NORMAL ,OSD_WINDOW(OSD2_0A), wTemp);
                                                              msML_WriteByte(ML_MODE_NORMAL ,OSD_WINDOW(OSD2_0B), wTemp>>8);
                                                              msML_Trigger(ML_TRIG_OUT_VDE_END);// Vde-end-OP                                 
                                                      
                                                 }while(wTemp!=VposValue);
                                      }
                              }
                              else
                              {
                              
              #if CHIP_ID==CHIP_TSUMV
                                  mStar_WaitForDataBlanking();
              #endif
                                      msML_WaitReady();
                                      msML_WriteByte(ML_MODE_NORMAL ,OSD_WINDOW(OSD2_04), HposValue);
                                      msML_WriteByte(ML_MODE_NORMAL ,OSD_WINDOW(OSD2_05), HposValue>>8);
                                      if(PanelWidth<(( WORD )OsdWindowWidth*12))      //120115 Modify
                                      {
                                              msML_WriteByte(ML_MODE_NORMAL ,OSD_WINDOW(OSD2_08), (HposValue+PanelWidth));
                                              msML_WriteByte(ML_MODE_NORMAL ,OSD_WINDOW(OSD2_09), (HposValue+PanelWidth)>>8);
                                      }
                                      else
                                      {
                                              msML_WriteByte(ML_MODE_NORMAL ,OSD_WINDOW(OSD2_08), (HposValue+( WORD )OsdWindowWidth * 12));
                                              msML_WriteByte(ML_MODE_NORMAL ,OSD_WINDOW(OSD2_09), (HposValue+( WORD )OsdWindowWidth * 12)>>8);
                                      }
                                      msML_WriteByte(ML_MODE_NORMAL ,OSD_WINDOW(OSD2_06), VposValue);
                                      msML_WriteByte(ML_MODE_NORMAL ,OSD_WINDOW(OSD2_07), VposValue>>8);
                                      {
                                      msML_WriteByte(ML_MODE_NORMAL ,OSD_WINDOW(OSD2_0A), (VposValue+( WORD )OsdWindowHeight * 18));
                                      msML_WriteByte(ML_MODE_NORMAL ,OSD_WINDOW(OSD2_0B), (VposValue+( WORD )OsdWindowHeight * 18)>>8);
                                      }
                                      msML_Trigger(ML_TRIG_OUT_VDE_END);// Vde-end-OP
                              }
                              mStar_WaitForDataBlanking();   // 20111226 Nick for input select Item OSD issue 
              
              #elif ENABLE_SW_DOUBLE_BUFFER
 229   1                  WORD HposValue, VposValue;
 230   1      
 231   1                  if(PanelWidth<(( WORD )OsdWindowWidth*12))  //120115 Modify
 232   1                      HposValue = 0;
 233   1                  else
 234   1                      HposValue = (( DWORD )xPos * ( PanelWidth - ( WORD )OsdWindowWidth * 12 ) ) / 100;
 235   1      
C51 COMPILER V9.01   MSOSDFUNCTION                                                         03/09/2023 15:39:11 PAGE 5   

 236   1                  yPos = 100 - yPos;
 237   1                  VposValue = (( DWORD )yPos * ( PanelHeight - ( WORD )OsdWindowHeight * 18 ) ) / 100;
 238   1                              
 239   1                  if( yPos == 100 && OsdWindowHeight == MainMenuOSD_Height )
 240   1                      VposValue += OSD_TRANSPARENT_SHIFT;
 241   1      
 242   1                  {
 243   2                      //msSWDBWaitForRdy();
 244   2                      DB_Mode(eDB_NORMAL_MODE);
 245   2                      DB_WB(OSD_WINDOW(OSD2_04), HposValue);
 246   2                      DB_WB(OSD_WINDOW(OSD2_05), HposValue>>8);
 247   2                      
 248   2                      if(PanelWidth<(( WORD )OsdWindowWidth*12))  //120115 Modify
 249   2                      {
 250   3                          DB_WB(OSD_WINDOW(OSD2_08), (HposValue+PanelWidth));
 251   3                          DB_WB(OSD_WINDOW(OSD2_09), (HposValue+PanelWidth)>>8);
 252   3                      }
 253   2                      else
 254   2                      {
 255   3                          DB_WB(OSD_WINDOW(OSD2_08), (HposValue+( WORD )OsdWindowWidth * 12));
 256   3                          DB_WB(OSD_WINDOW(OSD2_09), (HposValue+( WORD )OsdWindowWidth * 12)>>8);
 257   3                      }
 258   2                      DB_WB(OSD_WINDOW(OSD2_06), VposValue);
 259   2                      DB_WB(OSD_WINDOW(OSD2_07), VposValue>>8);
 260   2                      DB_WB(OSD_WINDOW(OSD2_0A), (VposValue+( WORD )OsdWindowHeight * 18));
 261   2                      DB_WB(OSD_WINDOW(OSD2_0B), (VposValue+( WORD )OsdWindowHeight * 18)>>8);
 262   2                      #if CHIP_ID==CHIP_TSUMF // TSUMF no VDE end trig source, instead by OSD_VDE_End sw polling
             - & trigger
                              msSWDBWriteToRegisterByOsdEnd();
                              #else
 265   2                      msSWDBWriteToRegister();
 266   2                      #endif
 267   2                      msSWDBWaitForRdy();
 268   2                   }
 269   1                  //mStar_WaitForDataBlanking();   // 20111226 Nick for input select Item OSD issue 
 270   1      
 271   1      #else
                  WORD posValue;
              
                      if(PanelWidth<(( WORD )OsdWindowWidth*12))      //120115 Modify
                              posValue = 0;
                      else
                      posValue = (( DWORD )xPos * ( PanelWidth - ( WORD )OsdWindowWidth * 12 ) ) / 100;
                  //mStar_WaitForDataBlanking();                //110901 Rick add for avoid the garbage while change osd
             - position
                      if(PanelWidth<(( WORD )OsdWindowWidth*12))      //120115 Modify
                      drvOSD_SetWndHPosition(OSD_MAIN_WND, posValue, posValue+ PanelWidth );
                      else
                      drvOSD_SetWndHPosition(OSD_MAIN_WND, posValue, posValue+( WORD )OsdWindowWidth * 12);
                  
                  yPos = 100 - yPos;
                  posValue = (( DWORD )yPos * ( PanelHeight - ( WORD )OsdWindowHeight * 18 ) ) / 100;
              
                  // 100811 coding addition for main menu osd
                  if( yPos == 100 && OsdWindowHeight == MainMenuOSD_Height )
                      posValue += OSD_TRANSPARENT_SHIFT;
                  
                  //mStar_WaitForDataBlanking();                //110901 Rick add for avoid the garbage while change osd
             - position
                  if (ucOSDMenuMoveType)
                  {
                      WORD wTemp = posValue+( WORD )OsdWindowHeight * 18;
C51 COMPILER V9.01   MSOSDFUNCTION                                                         03/09/2023 15:39:11 PAGE 6   

                      
                      mStar_WaitForDataBlanking(); 
                      if (ucOSDMenuMoveType == OSDMoveType_Setting)
                      {
                          drvOSD_SetWndVPosition(OSD_MAIN_WND, wTemp, posValue+( WORD )OsdWindowHeight * 18);
                      }
                      else if (ucOSDMenuMoveType == OSDMoveType_Main)
                      {   
                          do {
                                  wTemp--;
                                  Delay1ms(OSDMoveSpeed);
                                  drvOSD_SetWndVPosition(OSD_MAIN_WND, wTemp, posValue+( WORD )OsdWindowHeight * 18);
                              
                             }while(wTemp!=posValue);
                      }
                      else if (ucOSDMenuMoveType == OSDMoveType_Root)
                      {   
                          do {
                                  posValue++;
                                  Delay1ms(OSDMoveSpeed);
                                  drvOSD_SetWndVPosition(OSD_MAIN_WND, posValue, wTemp);
                              
                             }while(wTemp!=posValue);
                      }
                  }
                  else
                      drvOSD_SetWndVPosition(OSD_MAIN_WND, posValue, posValue+( WORD )OsdWindowHeight * 18);
              #endif
 323   1      }
 324          #else
              #define ScalingDown_PIPESHIFT    10
              WORD drvOsdGetPipeDelay( void )
                  {
                      WORD  xdata OPBackPorch;
                      BYTE  xdata PIPESHIFT;
                      PIPESHIFT =msReadByte( OSD1_4B );
                      OPBackPorch=msRead2Byte(SC0_12);
                      //if(g_SetupPathInfo.bScalingUpV)
              #if CHIP_ID == CHIP_TSUMY      //111005 Rick modified OSD Position formula - A041
                      OPBackPorch=(PIPESHIFT-OPBackPorch-23);//*2;
              #elif CHIP_ID == CHIP_TSUMB 
                  #if ENABLE_RTE           //120417 Rick modified pipedelay value while enable OSD2_4B[7]
                         OPBackPorch=(PIPESHIFT-OPBackPorch-35-50);//*2;
                  #else
                         OPBackPorch=(PIPESHIFT-OPBackPorch-35);//*2;
                  #endif
              #else
                      OPBackPorch=(PIPESHIFT-OPBackPorch-38)*2;
              #endif
                      //else
                          //OPBackPorch=(PIPESHIFT-OPBackPorch-38+ScalingDown_PIPESHIFT)*2;
                      return OPBackPorch;
                  }
              
              #define OSDFlyPos       11*18   //120830 Modify
              void Osd_SetPosition( BYTE xPos, BYTE yPos )
              {
                  WORD  xdata posValue;
                  BYTE xdata wOSDFlyPos = 0;  //120830 Modify
              
              #if DoubleXSize
                  posValue = (( DWORD )xPos * ( PanelWidth - ( WORD )OsdWindowWidth * 12 * 2 ) ) / 100 + ( ( PanelHStart
C51 COMPILER V9.01   MSOSDFUNCTION                                                         03/09/2023 15:39:11 PAGE 7   

             -/PANEL_H_DIV ) - 48 );
              #else
                   posValue = (( DWORD )xPos * ( PanelWidth - ( WORD )OsdWindowWidth * 12 ) ) / 100 - drvOsdGetPipeDelay
             -(); //);
              #endif
              
                  msWriteByte( OSD1_02, posValue & 0xFF );
                  msWriteByte( OSD1_03, posValue >> 8 );
              
                  posValue = ( PanelWidth - ( WORD )OsdWindowWidth * 12 ) - 4;
                  msWriteByte( OSD2_0A, posValue & 0xFF );
                  msWriteByte( OSD2_0B, (msReadByte(OSD2_0B)&0x80) |(posValue >> 8) );
              
                  yPos = 100 - yPos;
                  
              #if DoubleYSize
                  posValue = (( DWORD )yPos * ( PanelHeight - ( WORD )OsdWindowHeight * 18 * 2 ) ) / 100;
              #else
                  posValue = (( DWORD )yPos * ( PanelHeight - ( WORD )OsdWindowHeight * 18 ) ) / 100;
              #endif
              
                  // 100811 coding addition for main menu osd
                  if( yPos == 100 && OsdWindowHeight == MainMenuOSD_Height )
                      posValue += OSD_TRANSPARENT_SHIFT;
                      
                      //120830 Modify
                  if ((ucOSDMenuMoveType == OSDMoveType_Main)
                              ||(ucOSDMenuMoveType == OSDMoveType_Root))
                  {
                      wOSDFlyPos = OSDFlyPos;
                  }
                      
              
                  if (wOSDFlyPos)
                  {
                      //BYTE ucTemp= msReadByte(OSD1_01);
                      WORD wTemp;
               
                      while(wOSDFlyPos)
                      {
                          //msWriteByte( OSD1_01, 0x01 );
                          //printData("-- wOSDFlyPos[0x%x]", wOSDFlyPos);
                          //if (wOSDFlyPos%18 == 1)
                          //    mStar_WaitForDataBlanking();
                          //Delay1ms(OSDMoveSpeed);
                          if (wOSDFlyPos%18 == 1)
                          {
                              Delay1ms(OSDMoveSpeed);
                              #if CHIP_ID == CHIP_TSUMY
                              WAIT_V_OUTPUT_BLANKING_START();
                              #else
                              mStar_WaitForDataBlanking();
                              #endif
                          }
                          if (ucOSDMenuMoveType == OSDMoveType_Root)
                          {
                              wTemp = ( posValue + (OSDFlyPos-wOSDFlyPos));
                              // 0x0FF-->0x100
                                              msWriteByte( OSD1_04, wTemp & 0xFF );
                                              msWriteByte( OSD1_05, wTemp >> 8 );
                              if (wOSDFlyPos < 0x12)
                              {
C51 COMPILER V9.01   MSOSDFUNCTION                                                         03/09/2023 15:39:11 PAGE 8   

                                  msWriteByte( OSD1_07, 0x01 );               //110317 Modify for the garbage on the bottom
                              }
                              else if (wOSDFlyPos < 0x24)
                              {
                                  msWriteByte( OSD1_07, 0x02 );               //110317 Modify for the garbage on the bottom
                              }
                              else if (wOSDFlyPos < 0x36)
                              {
                                  msWriteByte( OSD1_07, 0x03 );               //110317 Modify for the garbage on the bottom
                              }
                              else if (wOSDFlyPos < 0x48)
                              {
                                  msWriteByte( OSD1_07, 0x04 );               //110317 Modify for the garbage on the bottom
                              }
                              else if (wOSDFlyPos < 0x5A)
                              {
                                  msWriteByte( OSD1_07, 0x05 );               //110317 Modify for the garbage on the bottom
                              }
                              else if (wOSDFlyPos < 0x6C)
                              {
                                  msWriteByte( OSD1_07, 0x06 );               //110317 Modify for the garbage on the bottom
                              }
                              else if (wOSDFlyPos < 0x7E)
                              {
                                  msWriteByte( OSD1_07, 0x07 );               //110317 Modify for the garbage on the bottom
                              }
                              else if (wOSDFlyPos < 0x90)
                              {
                                  msWriteByte( OSD1_07, 0x08 );               //110317 Modify for the garbage on the bottom
                              }
                              else if (wOSDFlyPos < 0xA2)
                              {
                                  msWriteByte( OSD1_07, 0x09 );               //110317 Modify for the garbage on the bottom
                              }
                              else if (wOSDFlyPos < 0xB4)
                              {
                                  msWriteByte( OSD1_07, 0x0A );               //110317 Modify for the garbage on the bottom
                              }
                              else if (wOSDFlyPos <= 0xC6)
                              {
                                  msWriteByte( OSD1_07, 0x0B );               //110317 Modify for the garbage on the bottom
                              }
                          }
                          else if (ucOSDMenuMoveType == OSDMoveType_Main)
                          {
                              wTemp = ( posValue + wOSDFlyPos);
                              // 0x100-->0x0FF
                                              msWriteByte( OSD1_04, wTemp & 0xFF );
                                              msWriteByte( OSD1_05, wTemp >> 8 );
                              if (wOSDFlyPos == 0x01)
                              {
                                  msWriteByte( OSD1_07, 0x0B );               //110317 Modify for the garbage on the bottom
                              }
                              else if (wOSDFlyPos < 0x12)
                              {
                                  msWriteByte( OSD1_07, 0x0B );               //110317 Modify for the garbage on the bottom
                              }
                              else if (wOSDFlyPos < 0x24)
                              {
                                  msWriteByte( OSD1_07, 0x0A );               //110317 Modify for the garbage on the bottom
                              }
                              else if (wOSDFlyPos < 0x36)
C51 COMPILER V9.01   MSOSDFUNCTION                                                         03/09/2023 15:39:11 PAGE 9   

                              {
                                  msWriteByte( OSD1_07, 0x09 );               //110317 Modify for the garbage on the bottom
                              }
                              else if (wOSDFlyPos < 0x48)
                              {
                                  msWriteByte( OSD1_07, 0x08 );               //110317 Modify for the garbage on the bottom
                              }
                              else if (wOSDFlyPos < 0x5A)
                              {
                                  msWriteByte( OSD1_07, 0x07 );               //110317 Modify for the garbage on the bottom
                              }
                              else if (wOSDFlyPos < 0x6C)
                              {
                                  msWriteByte( OSD1_07, 0x06 );               //110317 Modify for the garbage on the bottom
                              }
                              else if (wOSDFlyPos < 0x7E)
                              {
                                  msWriteByte( OSD1_07, 0x05 );               //110317 Modify for the garbage on the bottom
                              }
                              else if (wOSDFlyPos < 0x90)
                              {
                                  msWriteByte( OSD1_07, 0x04 );               //110317 Modify for the garbage on the bottom
                              }
                              else if (wOSDFlyPos < 0xA2)
                              {
                                  msWriteByte( OSD1_07, 0x03 );               //110317 Modify for the garbage on the bottom
                              }
                              else if (wOSDFlyPos < 0xB4)
                              {
                                  msWriteByte( OSD1_07, 0x02 );               //110317 Modify for the garbage on the bottom
                              }
                              else if (wOSDFlyPos <= 0xC6)
                              {
                                  msWriteByte( OSD1_07, 0x01 );               //110317 Modify for the garbage on the bottom
                              }
                          }
               
                          wOSDFlyPos--;
                          //msWriteByte( OSD1_01, 0x03 );
                      }
               
                      //msWriteByte( OSD1_01, 0x01 );
                          // 0x100-->0x0FF
                     // if ( (posValue == 0x0FF || posValue == 0x1FF || posValue == 0x2FF)
                          // 0x0FF-->0x100
                    //     ||(posValue == 0x100 || posValue == 0x200 || posValue == 0x300))
                      {
                         // mStar_WaitForDataBlanking();
                      }
                          msWriteByte( OSD1_04, wTemp & 0xFF );
                          msWriteByte( OSD1_05, wTemp >> 8 );
                      //msWriteByte( OSD1_01, ucTemp );
                      ucOSDMenuMoveType = OSDMoveType_Ini;
                  }
                  else
                  {
                          msWriteByte( OSD1_04, posValue & 0xFF );
                          msWriteByte( OSD1_05, posValue >> 8 );
                  }
              
              }
              
C51 COMPILER V9.01   MSOSDFUNCTION                                                         03/09/2023 15:39:11 PAGE 10  

              #endif
 542          
 543          void Osd_Show(void)
 544          {
 545   1      
 546   1      #if CHIP_ID>=CHIP_TSUMV
 547   1          Delay1ms(20);       //111223 Modify
 548   1              drvOSD_SetWndOn(OSD_MAIN_WND, TRUE);
 549   1              
 550   1              #if HotInputSelect 
 551   1              if(MenuPageIndex == HotInputSelectMenu)// 20130523 miff only for hotinputselectMenu garbage & show gradat
             -ionally.
 552   1              drvOSD_SetWndOn(OSD_CURSOR_WND, TRUE);
 553   1              #endif
 554   1                      
 555   1      #else
              
                      BYTE u8RegByte;
                      u8RegByte=(DoubleXSize<<4)|(DoubleYSize<<6)|MWIN_B;//|0x8
              #if 0//ENABLE_OSD_ROTATION
                      if (MENU_ROTATION_FLAG
              #if ENABLE_COLOR_DEMO_MODE
                              && g_u8MenuPageIndex!=MENU_ROOT
              #endif
                              )
                              u8RegByte|=BIT1; //rotation bit
              #endif
                      msWriteByte(OSD1_0C, u8RegByte);
              
              #endif
 570   1              #if defined(DCRClearBacklight)
 571   1              if((MenuPageIndex == AutoMenu||MenuPageIndex == MainMenu)&&UserPrefDcrMode)
 572   1              {
 573   2                      if(!BackLightActiveFlag)
 574   2                      hw_SetBlacklit();
 575   2              }
 576   1              #endif
 577   1      
 578   1      }
 579          
 580          void Osd_Hide(void)
 581          {
 582   1      #if CHIP_ID>=CHIP_TSUMV
 583   1              drvOSD_SetWndOn(OSD_MAIN_WND, FALSE);
 584   1          drvOSD_SetWndOn(OSD_CURSOR_WND,FALSE);
 585   1      #else
              #if DEBUG_OSD
                      msWriteByte( IOSDC1, ( DoubleXSize << 4 ) | ( DoubleYSize << 6 ) | MWIN_B );
              #else
                      msWriteByte( IOSDC1, 0x00 );
              #endif
              #endif
 592   1      }
 593          
 594          #if 1
 595          extern xdata BYTE OsdFontColor  ;
 596          extern BYTE  xdata MenuPageIndex ;
 597          
 598          
 599          #if 0
              #define OSD_WINDOW_ADDR(OsdWND,Addr)    ((OsdWND<<5)+Addr)
              void SetOSDWindosw(BYTE ucSubWin,BYTE u8HStart,BYTE u8HEnd ,BYTE u8VStart, BYTE u8VEnd,BYTE u8Color)
C51 COMPILER V9.01   MSOSDFUNCTION                                                         03/09/2023 15:39:11 PAGE 11  

              {
              #if CHIP_ID>=CHIP_TSUMV
                 // WAIT_V_OUTPUT_BLANKING_START(); //Jison wait 1 frame to avoid the last text garbage
                  //drvOSD_SetWndOn(ucSubWin, FALSE);
                  {
                      WORD xdata u16MainHStart=drvOSD_GetWndInfo(OSD_MAIN_WND,OSD_WND_INFO_H_START);
                      WORD xdata u16MainVStart=drvOSD_GetWndInfo(OSD_MAIN_WND,OSD_WND_INFO_V_START);
                      if (bMoveCURSORFlag)
                      {
                          drvOSD_SetWndCABaseAddr(ucSubWin, 0x046);//clear
                          WAIT_V_OUTPUT_BLANKING_START();
                      }
                      else
                          drvOSD_SetWndCABaseAddr(ucSubWin, drvOSD_GetWndInfo(OSD_MAIN_WND,OSD_WND_INFO_CABASE)+
                          (WORD)u8VStart*drvOSD_GetWndInfo(OSD_MAIN_WND,OSD_WND_INFO_LINE_OFFSET)+u8HStart);
                              #if ENABLE_MENULOAD     //111223 Modify
                                      msML_WriteByte(ML_MODE_NORMAL ,OSD_WINDOW_ADDR(ucSubWin,OSD2_04), (u16MainHStart+(WORD)u8HStart*
             -12));
                                      msML_WriteByte(ML_MODE_NORMAL ,OSD_WINDOW_ADDR(ucSubWin,OSD2_05), (u16MainHStart+(WORD)u8HStart*
             -12)>>8);
                                      msML_WriteByte(ML_MODE_NORMAL ,OSD_WINDOW_ADDR(ucSubWin,OSD2_08), (u16MainHStart+((WORD)u8HEnd+1
             -)*12));
                                      msML_WriteByte(ML_MODE_NORMAL ,OSD_WINDOW_ADDR(ucSubWin,OSD2_09), (u16MainHStart+((WORD)u8HEnd+1
             -)*12)>>8);
                                      msML_WriteByte(ML_MODE_NORMAL ,OSD_WINDOW_ADDR(ucSubWin,OSD2_06), (u16MainVStart+(WORD)u8VStart*
             -18));
                                      msML_WriteByte(ML_MODE_NORMAL ,OSD_WINDOW_ADDR(ucSubWin,OSD2_07), (u16MainVStart+(WORD)u8VStart*
             -18)>>8);
                                      msML_WriteByte(ML_MODE_NORMAL ,OSD_WINDOW_ADDR(ucSubWin,OSD2_0A), (u16MainVStart+((WORD)u8VEnd+1
             -)*18));
                                      msML_WriteByte(ML_MODE_NORMAL ,OSD_WINDOW_ADDR(ucSubWin,OSD2_0B), (u16MainVStart+((WORD)u8VEnd+1
             -)*18)>>8);
                                      msML_Trigger(ML_TRIG_SW);// Vde-end-OP  
                              
                              #elif ENABLE_SW_DOUBLE_BUFFER
                                //msSWDBWaitForRdy();
                                   DB_Mode(ML_MODE_NORMAL);
                                      DB_WB(OSD_WINDOW_ADDR(ucSubWin,OSD2_04), (u16MainHStart+(WORD)u8HStart*12));
                                      DB_WB(OSD_WINDOW_ADDR(ucSubWin,OSD2_05), (u16MainHStart+(WORD)u8HStart*12)>>8);
                                      DB_WB(OSD_WINDOW_ADDR(ucSubWin,OSD2_08), (u16MainHStart+((WORD)u8HEnd+1)*12));
                                      DB_WB(OSD_WINDOW_ADDR(ucSubWin,OSD2_09), (u16MainHStart+((WORD)u8HEnd+1)*12)>>8);
                                      DB_WB(OSD_WINDOW_ADDR(ucSubWin,OSD2_06), (u16MainVStart+(WORD)u8VStart*18));
                                      DB_WB(OSD_WINDOW_ADDR(ucSubWin,OSD2_07), (u16MainVStart+(WORD)u8VStart*18)>>8);
                                      DB_WB(OSD_WINDOW_ADDR(ucSubWin,OSD2_0A), (u16MainVStart+((WORD)u8VEnd+1)*18));
                                      DB_WB(OSD_WINDOW_ADDR(ucSubWin,OSD2_0B), (u16MainVStart+((WORD)u8VEnd+1)*18)>>8);
                                   msSWDBWriteToRegister();
                                   msSWDBWaitForRdy();
                              #else
                                  drvOSD_SetWndHPosition(ucSubWin, u16MainHStart+(WORD)u8HStart*12, u16MainHStart+((WORD
             -)u8HEnd+1)*12);
                                  drvOSD_SetWndVPosition(ucSubWin, u16MainVStart+(WORD)u8VStart*18, u16MainVStart+((WORD
             -)u8VEnd+1)*18);
                              #endif
                  }
                  drvOSD_SetWndFixAttr(ucSubWin,_ENABLE,u8Color);
                  //WAIT_V_OUTPUT_BLANKING_START(); //Jison wait 1 frame to avoid the last text garbage
                  #if HotInputSelect 
                  if(MenuPageIndex != HotInputSelectMenu)// 20130523 miff only for hotinputselectMenu garbage & show gra
             -dationally.
                  #endif
                      WAIT_V_OUTPUT_BLANKING_START();//fay 20131218
                      drvOSD_SetWndOn(ucSubWin, TRUE);
C51 COMPILER V9.01   MSOSDFUNCTION                                                         03/09/2023 15:39:11 PAGE 12  

                
              #else    // Wind as 0 ~3
                  if (OSD_CURSOR_WND == ucSubWin)
                      ucSubWin = SUB_WIN_00;
              
                  ucSubWin=SUBW0C+ucSubWin*6;
              
                  mStar_WriteOSDByte(ucSubWin+1, u8HStart);
                  mStar_WriteOSDByte(ucSubWin+2, u8HEnd);
                  mStar_WriteOSDByte(ucSubWin+3, u8VStart);
                  mStar_WriteOSDByte(ucSubWin+4, u8VEnd);
                  mStar_WriteOSDByte(ucSubWin+5, u8Color);
              
                  if ((ucSubWin|BKMASKOSD1) == SUBW1C)
                      mStar_WriteOSDByte(ucSubWin+0, 0x03);
                  else
                      mStar_WriteOSDByte(ucSubWin+0, 0x01);
              #endif
              }
              
              void ClrOSDWindosw(BYTE ucSubWin)
              {
              #if CHIP_ID>=CHIP_TSUMV
                  drvOSD_SetWndOn(ucSubWin, FALSE);
              #else
                  // Wind as 0 ~3
                  if (OSD_CURSOR_WND == ucSubWin)
                      ucSubWin = SUB_WIN_00;
                  
                  ucSubWin=SUBW0C+ucSubWin*6;
                  mStar_WriteOSDByte(ucSubWin+0, 0x00);
                  mStar_WriteOSDByte(ucSubWin+1, 0x00);
                  mStar_WriteOSDByte(ucSubWin+2, 0x00);
                  mStar_WriteOSDByte(ucSubWin+3, 0x00);
                  mStar_WriteOSDByte(ucSubWin+4, 0x00);
                  mStar_WriteOSDByte(ucSubWin+5, 0x00);
              #endif
              }
              #endif
 692          BYTE Osd_DoubleBuffer(Bool u8Enable)
 693          {
 694   1        #if CHIP_ID>=CHIP_TSUMV
 695   1          u8Enable=0;
 696   1          return u8Enable;
 697   1        #else
                  BYTE u8Org=msReadByte(OSD1_01);
                  msWriteByte(OSD1_01,(u8Enable?0x05:0));
                  return (u8Org);
                #endif
 702   1      }
 703          
 704          #if 1
 705          void Osd_SetTextMonoColor(BYTE foreColor, BYTE backColor)
 706          {
 707   1          OsdFontColor = (foreColor &0xF) << 4 | (backColor &0xF);
 708   1      }
 709          void Osd_SetTextColor(BYTE foreColor, BYTE backColor)
 710          {
 711   1          // OsdFontColor=(foreColor&0xF)<<4|(backColor&0xF);
 712   1          OsdFontColor = (foreColor &0x0) | (backColor &0xFF);
 713   1      }
 714          void Osd_Set256TextColor(BYTE foreColor, BYTE backColor)
C51 COMPILER V9.01   MSOSDFUNCTION                                                         03/09/2023 15:39:11 PAGE 13  

 715          {
 716   1         if(backColor==Color_2)
 717   1            OsdFontColor=foreColor;
 718   1         else if(backColor==Color_2G)
 719   1          {
 720   2      #if CHIP_ID>=CHIP_TSUMV
 721   2            OsdFontColor=(foreColor&0xF0)|0x01;
 722   2      #else
                    OsdFontColor=foreColor;
              #endif
 725   2          }
 726   1         else if(backColor==Color_4)
 727   1            OsdFontColor=foreColor<<2;
 728   1         else if(backColor==Color_8)
 729   1            OsdFontColor=foreColor<<3;
 730   1         else if(backColor==Color_8G)
 731   1            OsdFontColor=(foreColor<<3)|BIT1;
 732   1         else if(backColor==Color_2T)
 733   1            OsdFontColor=foreColor|0x00;
 734   1         else if(backColor==Color_4T)
 735   1            OsdFontColor=foreColor<<2|0x01;
 736   1         else// (backColor==Color_8T)
 737   1            OsdFontColor=foreColor<<3|0x01;
 738   1      }
 739          #endif
 740          
 741          #if 0//CHIP_ID<CHIP_TSUMV
              void SetOsdGraduallyBackGround( BYTE Win_Num, BYTE GDRValue, BYTE GDGValue, BYTE GDBValue, BYTE GDDelta , 
             -BYTE GDDERange, BYTE GDControl, BYTE GDRInit , BYTE GDGInit, BYTE GDBInit)
              {
                  if (Win_Num>4) return;
                  switch (Win_Num)
                  {
                    case SUB_WIN_00:
                         Win_Num = OSD_GD00;
                         break;
                    case SUB_WIN_01:
                         Win_Num = OSD_GD01;
                         break;
                    case SUB_WIN_02:
                         Win_Num = OSD_GD02;
                         break;
                    case SUB_WIN_03:
                         Win_Num = OSD_GD03;
                         break;
                  }
                  mStar_WriteOSDByte( Win_Num + 0, GDRValue);
                  mStar_WriteOSDByte( Win_Num + 1, GDGValue );
                  mStar_WriteOSDByte( Win_Num + 2, GDBValue );
              
                  mStar_WriteOSDByte( Win_Num + 3, GDDelta );
                  mStar_WriteOSDByte( Win_Num + 4, GDDelta );
              
                  mStar_WriteOSDByte( Win_Num + 5, GDDERange );
                  mStar_WriteOSDByte( Win_Num + 6, GDDERange );
                  mStar_WriteOSDByte( Win_Num + 7, GDDERange );
                  mStar_WriteOSDByte( Win_Num + 8, GDDERange );
              
                  mStar_WriteOSDByte( Win_Num + 9, GDControl );
              
                  mStar_WriteOSDByte( Win_Num + 10, GDRInit );
                  mStar_WriteOSDByte( Win_Num + 11, GDGInit );
C51 COMPILER V9.01   MSOSDFUNCTION                                                         03/09/2023 15:39:11 PAGE 14  

                  mStar_WriteOSDByte( Win_Num + 12, GDBInit );
              }
              #endif
 779          
 780          
 781          #endif
 782          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    610    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       7
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

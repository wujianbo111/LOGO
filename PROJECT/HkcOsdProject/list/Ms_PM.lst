C51 COMPILER V9.01   MS_PM                                                                 03/09/2023 15:39:11 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE MS_PM
OBJECT MODULE PLACED IN .\obj\Ms_PM.obj
COMPILER INVOKED BY: D:\Keil4\C51\BIN\C51.EXE ..\..\KERNEL\SCALER\Ms_PM.c OPTIMIZE(SIZE) BROWSE INCDIR(..\..\DRIVER\INC;
                    -..\..\KERNEL\SCALER\INC;..\..\KERNEL\SYSTEM\INC;..\..\LIB\INC;..\..\PANEL\INC;..\..\BOARD;..\..\DRIVER\INC;..\..\KERNEL\
                    -SYSTEM\INC\AOC2011;..\..\DRIVER\extDEVICE\INC;..\..\MODEL;..\..\CONFIG;..\..\PANEL;..\..\UI\F_LOGO\INC;..\..\UI\HkcOsd\I
                    -NC) DEFINE(ModelName=JRY_TESTBOARD_C_BOARD) DEBUG OBJECTEXTEND PRINT(.\list\Ms_PM.lst) OBJECT(.\obj\Ms_PM.obj)

line level    source

   1          ///////////////////////////////////////////////////////////////////////////////////////////////////
   2          ///
   3          /// file    Ms_PM.c
   4          /// @author MStar Semiconductor Inc.
   5          /// @brief  PM Function
   6          ///////////////////////////////////////////////////////////////////////////////////////////////////
   7          
   8          //-------------------------------------------------------------------------------------------------
   9          //  Include Files
  10          //-------------------------------------------------------------------------------------------------
  11          #define _MS_PM_C_
  12          #include "board.h"
  13          #include <math.h>
  14          #include <string.h>
  15          #include "types.h"
  16          //#include "mode.h"
  17          #include "common.h"
  18          #include "UserPrefDef.h"
  19          #include "global.h"
  20          #include "Misc.h"
  21          #include "ms_reg.h"
  22          #include "ms_rwreg.h"
  23          #include "Debug.h"
  24          #include "menu.h"
  25          #include "userpref.h"
  26          #include "Power.h"
  27          #include "DDC2Bi.h"
  28          #include "Ms_PM.h"
  29          #include "MenuDef.h"
  30          #include "MenuFunc.h"
  31          #include "Mcu.h"
  32          #include "Mstar.h"
  33          #include "Detect.h"
  34          #include "Keypad.h"     // Provides: Key_GetKeypadStatus()
  35          #include "KeypadDef.h"  // Provides: KeypadMask
  36          #include "GPIO_Def.h"
  37          #if ENABLE_DP_INPUT
              #include "drvDPRxApp.h"
              #endif
  40          #if ENABLE_DisplayPortTX
              #include "drvDPTxApp.h"
              #endif
  43          #if ENABLE_ANDROID_IR   //131008 Modify
              #include "drv_ir.h"
              #endif
  46          
  47          #if     (MS_PM)
  48          #if (FRAME_BFF_SEL == FRAME_BUFFER) || ENABLE_RTE
              extern  Bool msMemoryBist(void);
              #endif
  51          extern void msDVISetMux( InputPortType inport );
  52          extern void msPM_ClearStatus(Bool bResetPM);
C51 COMPILER V9.01   MS_PM                                                                 03/09/2023 15:39:11 PAGE 2   

  53          
  54          extern BYTE Key_GetKeypadStatus( void );
  55          
  56          extern Bool ExecuteKeyEvent(MenuItemActionType menuAction);
  57          extern void Main_SlowTimerHandler(void);
  58          
  59          #if Enable_CheckVcc5V
              extern Bool CheckVCC5V ( void );
              #endif
  62          
  63          #if  ENABLE_DP_INPUT
              #if  DPENABLEMCCS
              extern void DDC2BI_DP(void);
              #if ((CHIP_ID == CHIP_TSUMC)||(CHIP_ID == CHIP_TSUMD)||(CHIP_ID == CHIP_TSUM9)||(CHIP_ID == CHIP_TSUMF))
              #if D2B_XShared_DDCBuffer
              extern BYTE *DDCBuffer;
              #else
              extern BYTE xdata DDCBuffer[DDC_BUFFER_LENGTH];
              #endif
              #else
              extern BYTE xdata DDCBuffer[DDC_BUFFER_LENGTH];
              #endif
              #endif
              #endif
  77          
  78          
  79          extern void mdrv_mhl_RtermControlHWMode(Bool bFlag);//130703 nick
  80          //-------------------------------------------------------------------------------------------------
  81          //  Local Defines
  82          //-------------------------------------------------------------------------------------------------
  83          #define PM_DEBUG    0
  84          #if ENABLE_DEBUG&&PM_DEBUG
                  #define PM_printData(str, value)   printData(str, value)
                  #define PM_printMsg(str)           printMsg(str)
              #else
  88              #define PM_printData(str, value)
  89              #define PM_printMsg(str)
  90          #endif
  91          
  92          #define XBYTE             ((unsigned char volatile xdata *) 0)
  93          
  94          
  95          //--------PM Option----------------
  96          /*Choice MCU clock when enter into PM_MODE*/
  97          extern BYTE xdata MenuPageIndex ;
  98          
  99          extern BYTE xdata MenuItemIndex ;
 100          
 101          
 102          //---------------------------------
 103          #define VCP_SET             0x03
 104          #define VCP_DPMS            0xD6
 105          #define VCP_DPMS_ON         0x01
 106          //-------------------------------------------------------------------------------------------------
 107          #define IS_SOURCE_AUTOSWITCH() (TRUE)
 108          #define IS_SOURCE_VGA()        (FALSE) //(UserPreference.InputSync == ANALOG)
 109          #define IS_SOURCE_DVI0()       (FALSE) //(UserPreference.InputSync == DIGITAL)
 110          #define IS_SOURCE_DVI1()       (FALSE) //(UserPreference.InputSync == DIGITAL2)
 111          
 112          //-------------------------------------------------------------------------------------------------
 113          //  Local Structures
 114          //-------------------------------------------------------------------------------------------------
C51 COMPILER V9.01   MS_PM                                                                 03/09/2023 15:39:11 PAGE 3   

 115          
 116          typedef enum
 117          {
 118              ePM_POWERON,
 119              ePM_STANDBY,
 120              ePM_POWEROFF,
 121          
 122              ePM_INVAILD
 123          }ePM_Mode;
 124          
 125          
 126          typedef enum
 127          {
 128              ePMDVI_DVI0,
 129              ePMDVI_DVI1,
 130              ePMDVI_DVI0_DVI1,
 131          
 132              ePMDVI_INVALID
 133          }ePM_DVI;
 134          
 135          typedef enum
 136          {
 137              ePMGPIO04_DectDVI5V,
 138              ePMGPIO02_DectDVI5V,
 139              ePMGPIO01_DectDVI5V,
 140              ePMGPIO00_DectDVI5V,
 141              ePMDVI5V_INVALID
 142          } ePM_DVI5V;
 143          
 144          typedef enum
 145          {
 146              ePMSAR_SAR0 = BIT0,
 147              ePMSAR_SAR1 = BIT1,
 148              ePMSAR_SAR2 = BIT2,
 149              ePMSAR_SAR3 = BIT3,
 150              ePMSAR_SAR12 = BIT1|BIT2, 
 151              ePMSAR_SAR123 = BIT1|BIT2|BIT3,
 152              ePMSAR_SAR01 = BIT0|BIT1,
 153              ePMSAR_SAR012 = BIT0|BIT1|BIT2,
 154              ePMSAR_INVALID
 155          }ePM_SAR;
 156          
 157          #if 0//_OLD_PM_FLOW
              typedef enum
              {
                  ePM_ENTER_PM,
                  ePM_IDLE,
                  ePM_EXIT_PM,
                  ePM_WAIT_EVENT,
              }ePM_State;
              
              typedef struct
              {
                  BYTE bSpecialEvent_1:1;
                  BYTE bSpecialEvent_2:1;
              
              }sPM_WakeUp_Check;
              #endif
 173          
 174          typedef enum
 175          {
 176              ePM_CLK_RCOSC,
C51 COMPILER V9.01   MS_PM                                                                 03/09/2023 15:39:11 PAGE 4   

 177              ePM_CLK_XTAL,
 178          
 179              ePMCLK_INVALID
 180          }ePM_CLK;
 181          
 182          typedef struct
 183          {
 184              BYTE bHVSync_enable:1;
 185              BYTE bSOG_enable:1;
 186              BYTE bGPIO_enable:1;
 187              BYTE bSAR_enable:1;
 188              BYTE bMCCS_enable:1;
 189              BYTE bEDID_enable:1;
 190          #if( PM_SUPPORT_WAKEUP_DVI )
 191              BYTE bDVI_enable:1;
 192          #endif  // end of #if( PM_SUPPORT_WAKEUP_DVI )
 193          #if( PM_SUPPORT_WAKEUP_DP )&&(ENABLE_DP_INPUT)
                  BYTE bDP_enable:1;
              #endif  // end of #if( PM_SUPPORT_WAKEUP_DP )
 196          #if( PM_SUPPORT_AC2DC )
                  BYTE bACtoDC_enable:1;
              #endif  // end of #if( PM_SUPPORT_AC2DC )
 199              BYTE bMCUSleep:1;
 200              ePM_DVI ePMDVImode;
 201          
 202              ePM_SAR ePMSARmode;
 203             
 204          }sPM_Config;
 205          
 206          typedef struct
 207          {
 208              WORD wPMGPIOWakeupSta;
 209          
 210          } sPM_WakeUp_Check;
 211          typedef struct
 212          {
 213              BYTE ucPMMode;
 214              ePM_State ePMState;
 215              sPM_Config  sPMConfig;
 216              sPM_WakeUp_Check sPMWakeUpCheck;
 217              #if CABLE_DETECT_VGA_USE_SAR||CABLE_DETECT_VGA_USE_SAR      
                   BYTE bCABLE_SAR_VALUE;
                      #endif
 220          }sPM_Info;
 221           
 222          XDATA sPM_Info  sPMInfo;
 223          XDATA ePMStatus ucWakeupStatus;
 224          
 225          //-------------------------------------------------------------------------------------------------
 226          //  External Variables
 227          //-------------------------------------------------------------------------------------------------
 228          #if !ENABLE_DEBUG
 229          extern BYTE xdata rxIndex;
 230          #if (CHIP_ID==CHIP_TSUMC) || CHIP_ID==CHIP_TSUMD||CHIP_ID == CHIP_TSUM9||CHIP_ID == CHIP_TSUMF
 231          #if D2B_XShared_DDCBuffer
              extern BYTE *DDCBuffer;
              #else
 234          extern BYTE xdata DDCBuffer[];
 235          #endif
 236          #else
              extern BYTE xdata DDCBuffer[];
              #endif
C51 COMPILER V9.01   MS_PM                                                                 03/09/2023 15:39:11 PAGE 5   

 239          #endif
 240          
 241          #ifndef PM_SUPPORT_ADC_TIME_SHARE
              #define PM_SUPPORT_ADC_TIME_SHARE  0
              #endif
 244          
 245          Bool msPM_IsState_IDLE(void)
 246          {
 247   1          if(sPMInfo.ePMState == ePM_IDLE)
 248   1              return TRUE;
 249   1          return FALSE;
 250   1      }
 251          
 252          //**************************************************************************
 253          //  [Function Name]:
 254          //                  msPM_Init()
 255          //  [Description]
 256          //                  msPM_Init
 257          //  [Arguments]:
 258          //
 259          //  [Return]:
 260          //
 261          //**************************************************************************
 262          void  msPM_Init(void)
 263          {
 264   1          sPMInfo.sPMConfig.bHVSync_enable =0;
 265   1      #if( PM_SUPPORT_WAKEUP_DVI )
 266   1          sPMInfo.sPMConfig.bDVI_enable =0;
 267   1      #endif  // end of #if( PM_SUPPORT_WAKEUP_DVI )
 268   1      #if( PM_SUPPORT_WAKEUP_DP && ENABLE_DP_INPUT)
                      sPMInfo.sPMConfig.bDP_enable=0;
              #endif  
 271   1          sPMInfo.sPMConfig.bSOG_enable =0;
 272   1          sPMInfo.sPMConfig.bSAR_enable =0;
 273   1          sPMInfo.sPMConfig.bGPIO_enable =0;
 274   1          sPMInfo.sPMConfig.bMCCS_enable =0;
 275   1      #if( PM_SUPPORT_AC2DC )
                  sPMInfo.sPMConfig.bACtoDC_enable=0;
              #endif  // end of #if( PM_SUPPORT_AC2DC )
 278   1          sPMInfo.sPMConfig.bMCUSleep=0;
 279   1      
 280   1          sPMInfo.ucPMMode = ePM_POWERON;
 281   1          sPMInfo.ePMState = ePM_IDLE;
 282   1          sPMInfo.sPMWakeUpCheck.wPMGPIOWakeupSta = msRead2Byte(REG_PM_64)&EN_GPIO_DET_MASK;
 283   1      }
 284          //**************************************************************************
 285          //  [Function Name]:
 286          //                  msPM_SetPMSandby()
 287          //  [Description]
 288          //                  msPM_SetPMSandby_ForceDVI0
 289          //  [Arguments]:
 290          //
 291          //  [Return]:
 292          //
 293          //**************************************************************************
 294          void msPM_SetFlag_Standby(void)
 295          {
 296   1      
 297   1      #if TMDS_SYNC_RECHECK
                  if(TMDS_INPUT_WITHOUT_HV_SYNC())
                  {
                      return;
C51 COMPILER V9.01   MS_PM                                                                 03/09/2023 15:39:11 PAGE 6   

                  }
              #endif
 303   1      
 304   1      #if (CHIP_ID==CHIP_TSUMC || CHIP_ID==CHIP_TSUMD||CHIP_ID == CHIP_TSUM9||CHIP_ID == CHIP_TSUMF)//130607 nic
             -k
 305   1              ComboInputControl(COMBO_INPUT_POWERSAVING);
 306   1      #endif
 307   1      
 308   1          //PM_printMsg(" msPM_SetFlag_Standby");
 309   1          #if (INPUT_TYPE != INPUT_2H) && (INPUT_TYPE != INPUT_1H)&&(INPUT_TYPE != INPUT_1D1H1DP)
 310   1              sPMInfo.sPMConfig.bHVSync_enable =1;
 311   1           #else
                      sPMInfo.sPMConfig.bHVSync_enable =0;
                   #endif
 314   1      #if( PM_SUPPORT_WAKEUP_DVI )
 315   1      #if Dual
 316   1                      sPMInfo.sPMConfig.bDVI_enable =1;
 317   1      #else
                      #if (INPUT_TYPE == INPUT_1A)
                              sPMInfo.sPMConfig.bDVI_enable =0;
                      #else
                              sPMInfo.sPMConfig.bDVI_enable =1;
                      #endif
              #endif
 324   1      #endif  // end of #if( PM_SUPPORT_WAKEUP_DVI )
 325   1      #if( PM_SUPPORT_WAKEUP_DP && ENABLE_DP_INPUT)
                  sPMInfo.sPMConfig.bDP_enable=1;
              #endif  // end of #if( PM_SUPPORT_WAKEUP_DP )
 328   1              sPMInfo.sPMConfig.bSOG_enable =PM_POWERSAVING_WAKEUP_SOG;
 329   1              sPMInfo.sPMConfig.bSAR_enable =PM_POWERSAVING_WAKEUP_SAR;
 330   1              sPMInfo.sPMConfig.bGPIO_enable =PM_POWERSAVING_WAKEUP_GPIO;
 331   1              sPMInfo.sPMConfig.bMCCS_enable =PM_POWERSAVING_WAKEUP_MCCS;
 332   1      #if( PM_SUPPORT_AC2DC )
                  sPMInfo.sPMConfig.bACtoDC_enable=0;
              #endif  // end of #if( PM_SUPPORT_AC2DC )
 335   1          sPMInfo.sPMConfig.bMCUSleep=0;
 336   1      #if ((CHIP_ID == CHIP_TSUM9||CHIP_ID == CHIP_TSUMF)&&ENABLE_CABLE_5V_EDID)
                  sPMInfo.sPMConfig.bEDID_enable = 1;
              #else
 339   1          sPMInfo.sPMConfig.bEDID_enable = 0;
 340   1      #endif
 341   1              sPMInfo.sPMConfig.ePMDVImode = ePMDVI_DVI0;
 342   1              sPMInfo.sPMConfig.ePMSARmode = ePMSAR_SAR0;
 343   1          sPMInfo.ucPMMode = ePM_STANDBY;//PM_POWERSAVING_SARmode;
 344   1              sPMInfo.ePMState = ePM_ENTER_PM;
 345   1      //    PM_printData("\r\n==>sPMInfo.ePMState STD %d", sPMInfo.bCABLE_SAR_VALUE);
 346   1      }
 347          
 348          
 349          //**************************************************************************
 350          //  [Function Name]:
 351          //                  msPM_SetPMDCoff()
 352          //  [Description]
 353          //                  msPM_SetPMDCoff
 354          //  [Arguments]:
 355          //
 356          //  [Return]:
 357          //
 358          //**************************************************************************
 359          void  msPM_SetFlag_PMDCoff(void)
 360          {
 361   1      
C51 COMPILER V9.01   MS_PM                                                                 03/09/2023 15:39:11 PAGE 7   

 362   1           #if (CHIP_ID==CHIP_TSUMC || CHIP_ID==CHIP_TSUMD||CHIP_ID == CHIP_TSUM9||CHIP_ID == CHIP_TSUMF)//13060
             -7 nick
 363   1              ComboInputControl(COMBO_INPUT_OFF);
 364   1           #endif
 365   1      
 366   1              PM_printMsg(" msPM_SetFlag_PMDCoff");
 367   1              sPMInfo.sPMConfig.bHVSync_enable =0;
 368   1      #if( PM_SUPPORT_WAKEUP_DVI )
 369   1              sPMInfo.sPMConfig.bDVI_enable =0;
 370   1      #endif  // end of #if( PM_SUPPORT_WAKEUP_DVI )
 371   1      #if( PM_SUPPORT_WAKEUP_DP && ENABLE_DP_INPUT)
                      sPMInfo.sPMConfig.bDP_enable=0;
              #endif  // end of #if( PM_SUPPORT_WAKEUP_DP )
 374   1              sPMInfo.sPMConfig.bSOG_enable =PM_POWEROFF_WAKEUP_SOG;
 375   1              sPMInfo.sPMConfig.bSAR_enable =PM_POWEROFF_WAKEUP_SAR;
 376   1              sPMInfo.sPMConfig.bGPIO_enable =PM_POWEROFF_WAKEUP_GPIO;
 377   1              sPMInfo.sPMConfig.bMCCS_enable =PM_POWEROFF_WAKEUP_MCCS;
 378   1      #if( PM_SUPPORT_AC2DC )
                      sPMInfo.sPMConfig.bACtoDC_enable=0;
              #endif  // end of #if( PM_SUPPORT_AC2DC )
 381   1              sPMInfo.sPMConfig.bMCUSleep=0;
 382   1      #if ((CHIP_ID == CHIP_TSUM9||CHIP_ID == CHIP_TSUMF)&&ENABLE_CABLE_5V_EDID)
                  sPMInfo.sPMConfig.bEDID_enable = 1;
              #else
 385   1              sPMInfo.sPMConfig.bEDID_enable = 0;
 386   1      #endif
 387   1          sPMInfo.sPMConfig.ePMDVImode = ePMDVI_DVI0;
 388   1              sPMInfo.sPMConfig.ePMSARmode = PM_POWEROFF_SARmode;
 389   1              sPMInfo.ucPMMode = ePM_POWEROFF;
 390   1              sPMInfo.ePMState = ePM_ENTER_PM;
 391   1      
 392   1      #if ENABLE_ANDROID_IR   //131008 Modify
                      if(SOURCE_INPUT_IS_ANDROID())//20131022 Modify for IR only support Yun OS.
                      {
                              IR_Init();
                              hw_ClrIRSwitch();
                      }
              #endif
 399   1              PM_printData("\r\n sPMInfo.ePMState DCOFF %d", sPMInfo.ePMState);
 400   1      
 401   1      }
 402          //**************************************************************************
 403          //  [Function Name]:
 404          //                  msPM_EnableHVSyncDetect(BOOL bEnable)
 405          //  [Description]
 406          //                  msPM_EnableSyncDetect
 407          //  [Arguments]:
 408          //
 409          //  [Return]:
 410          //
 411          //**************************************************************************
 412          void
 413          msPM_EnableHVSyncDetect(BOOL bEnable)
 414          {
 415   1          if(bEnable)
 416   1          {
 417   2              msWriteByteMask(REG_PM_8E, 0x00, 0xF0);         // Sync clock not gating
 418   2              msWriteByteMask(REG_SYNC_DET, EN_SYNC_DET_SET, EN_SYNC_DET_MASK);
 419   2          }
 420   1          else
 421   1          {
 422   2              msWriteByteMask(REG_PM_8E, 0xB0, 0xF0);         // Sync clock gating
C51 COMPILER V9.01   MS_PM                                                                 03/09/2023 15:39:11 PAGE 8   

 423   2              msWriteByteMask(REG_SYNC_DET, 0, EN_SYNC_DET_MASK);
 424   2          }
 425   1      }
 426          
 427          
 428          //**************************************************************************
 429          //  [Function Name]:
 430          //                  msPM_EnableSOGDetect(BOOL bEnable)
 431          //  [Description]
 432          //                  Enable SOG Detect: need power ADC VREF & BANGAP
 433          //  [Arguments]:
 434          //
 435          //  [Return]:
 436          //
 437          //**************************************************************************
 438          void
 439          msPM_EnableSOGDetect(BOOL bEnable)
 440          {
 441   1          if(bEnable)
 442   1          {
 443   2      #if( !PM_SUPPORT_SOG_TIME_SHARE )
 444   2              msWriteBit(REG_PM_E9, FALSE, _BIT7);   // disable SoG time sharing option of VREF/BGAP to save pow
             -er of SoG wakeup
 445   2      #else
                      msWriteBit(REG_PM_E9, TRUE, _BIT7);   // enable SoG time sharing option of VREF/BGAP to save power
             - of SoG wakeup
                      msPM_EnableDVIClockAmp( TRUE );       // enable DVI clock amplifier control, because SoG time shar
             -ing requires DVI clock amplifier control.
              
              #endif
 450   2              msWriteByteMask(REG_ADC_ATOP_04_L, 0, (_BIT1|_BIT0)); // power on ADC BGAP and VREF
 451   2              msWriteByteMask(REG_ADC_ATOP_04_H, 0, (_BIT2|_BIT1)); // power on online SOG DAC and main
 452   2      
 453   2              msWriteByteMask(REG_SYNC_DET, EN_SOG_DET, EN_SOG_DET);
 454   2          }
 455   1          else
 456   1          {
 457   2              msWriteBit(REG_PM_E9, FALSE, _BIT7);   // disable SoG time sharing option of VREF/BGAP to save pow
             -er of SoG wakeup
 458   2              msWriteByteMask(REG_ADC_ATOP_04_L, (_BIT1|_BIT0), (_BIT1|_BIT0)); // power down ADC BGAP and VREF
 459   2              msWriteByteMask(REG_ADC_ATOP_04_H, (_BIT2|_BIT1), (_BIT2|_BIT1)); // power down online SOG DAC and
             - main
 460   2      
 461   2              msWriteByteMask(REG_SYNC_DET, 0, EN_SOG_DET);
 462   2          }
 463   1      }
 464          
 465          
 466          //**************************************************************************
 467          //  [Function Name]:
 468          //                  msPM_PassWord(BOOL bEnable)
 469          //  [Description]
 470          //                  input  the password for entering pm or turn off XTAL
 471          //  [Arguments]:
 472          //
 473          //  [Return]:
 474          //
 475          //**************************************************************************
 476          void
 477          msPM_PassWord(BOOL bEnable)
 478          {
 479   1          if(bEnable)
C51 COMPILER V9.01   MS_PM                                                                 03/09/2023 15:39:11 PAGE 9   

 480   1          {
 481   2              msWriteByte(REG_PM_87,0x55);
 482   2              msWriteByte(REG_PM_88,0xAA);
 483   2          }
 484   1          else
 485   1          {
 486   2              msWriteByte(REG_PM_87,0x00);
 487   2              msWriteByte(REG_PM_88,0x00);
 488   2          }
 489   1      }
 490          
 491          //**************************************************************************
 492          //  [Function Name]:
 493          //                  msPM_PassWord(BOOL bEnable)
 494          //  [Description]
 495          //                  input  the password for entering pm or turn off XTAL
 496          //  [Arguments]:
 497          //
 498          //  [Return]:
 499          //
 500          //**************************************************************************
 501          #if 0//CHIP_ID == CHIP_TSUMD
              void msPM0W_Mode_PassWord(BOOL bEnable)
              {
                  if(bEnable)
                  {
                      msWriteByte(REG_PM_8B,0xA5);
                      msWriteByte(REG_PM_8B,0x5E);
                  }
                  else
                  {
              
                      
                  }
              }
              #endif
 516          #if( PM_SUPPORT_WAKEUP_DVI )
 517          
 518          //**************************************************************************
 519          //  [Function Name]:
 520          //                  msPM_EnableDVIClockAmp(BOOL bEnable)
 521          //  [Description]
 522          //                  Enable DVI clock amplifier control
 523          //  [Arguments]:
 524          //
 525          //  [Return]:
 526          //
 527          //**************************************************************************
 528          void
 529          msPM_EnableDVIClockAmp(Bool bEnable)
 530          {
 531   1          if(!bEnable)
 532   1          {
 533   2              msWriteByteMask(REG_PM_A8, BIT3, BIT3);  // DVI Controller Clock gating
 534   2              msWriteByteMask(REG_DVI_CTRL, 0x00, EN_DVI_CTRL_MASK ); // disable DVI clock amplifier
 535   2          }
 536   1          else
 537   1          {
 538   2              msWriteByteMask(REG_PM_A8, 0x00, 0x0F);  // DVI Controller Clock Not gating
 539   2              msWriteByteMask(REG_DVI_CTRL, EN_DVI_CTRL_SET, EN_DVI_CTRL_MASK ); // enable DVI clock amplifier
 540   2          }
 541   1      }
C51 COMPILER V9.01   MS_PM                                                                 03/09/2023 15:39:11 PAGE 10  

 542          
 543          
 544          //**************************************************************************
 545          //  [Function Name]:
 546          void msPM_EnableRterm(BOOL bEnable)
 547          {
 548   1      #if CHIP_ID >= CHIP_TSUMC
 549   1          if(bEnable)
 550   1          {
 551   2              msWriteByteMask(REG_PM_8E, 0x00, 0x0F); // DVI clock not pass
 552   2              drvDVI_PowerCtrl(DVI_POWER_STANDBY);
 553   2              ComboInputControl(COMBO_INPUT_POWERSAVING);//130604 Modify
 554   2      
 555   2              #if 0//MainBoardType==MainBoard_6124_M0A
                          if((UserPrefInputSelectType!=INPUT_PRIORITY_AUTO)&&(UserPrefInputSelectType!=INPUT_PRIORITY_DP
             -))
                              msWriteByteMask(REG_01C2, 0, BIT7);   // Turn off Port 2 Port Mux
                           else
                              msWriteByteMask(REG_01C2, BIT7, BIT7);   // Turn off Port 2 Port Mux
                      #endif
 561   2              
 562   2              #if HDMI_PRETEST
                      msWrite2ByteMask(REG_01C4,0x0000,0x0EEE);
                      #endif
 565   2              #if CHIP_ID == CHIP_TSUMJ
                      drvDVI_PortMuxControl(DVI_INPUT_PORT0);
                      #endif
 568   2          }
 569   1          else
 570   1          {
 571   2              msWriteByteMask(REG_PM_8E, 0x0B, 0x0F);// DVI clock gating
 572   2              drvDVI_PowerCtrl(DVI_POWER_DOWN);
 573   2              ComboInputControl(COMBO_INPUT_OFF);//130604 Modify
 574   2              #if CHIP_ID == CHIP_TSUMJ
                      drvDVI_PortMuxControl(DVI_INPUT_NONE);
                      #endif
 577   2          }
 578   1      // 111004 coding check with Shadow
 579   1      #else
              #if CHIP_ID == CHIP_TSUMV || CHIP_ID == CHIP_TSUM2 // 120522 coding, check 2
                  msWriteByteMask(REG_PM_B2, BIT3, BIT3);//Power down DVI PLL band-gap first can reduce 0.4mA
                  msWriteByteMask(REG_PM_B2, 0x00, BIT3);//power on DVI PLL band-gap
              #endif
              
                  if(bEnable)
                  {
                      msWriteByteMask(REG_PM_8E, 0x00, 0x0F); // DVI clock not pass
              #if DVI_PORT
                #if DVI_PORT==TMDS_PORT_A || DVI_PORT==TMDS_PORT_B
                  #if DVI_PORT==TMDS_PORT_A
                      msWriteByteMask(REG_PM_B3, BIT4, BIT4);//Switch to(A)[4]
                      msWriteByteMask(REG_PM_B2, 0x00, BIT0);//Not power down RCK(A)[0]
                  #else
                      msWriteByteMask(REG_PM_B3, BIT5, BIT5);//Switch to(B)[5]
                      msWriteByteMask(REG_PM_B2, 0x00, BIT1);//Not power down RCK(B)[1]
                  #endif
                      msWriteByteMask(REG_PM_B2, 0x00, BIT2);//Not power down CLKIN(A/B)[2]
                      msWriteByteMask(REG_PM_8F, 0x00, 0x0F);// DVI RAW clock (A/B) pass
                #else
                      msWriteByteMask(REG_PM_B3, 0x00, BIT0);//Not power down RCK(B)[1]
                      msWriteByteMask(REG_PM_B3, 0x00, BIT2);//Not power down CLKIN(C)[2]
                      msWriteByteMask(REG_PM_8C, 0x00, 0x0F);// DVI RAW clock (C) pass
C51 COMPILER V9.01   MS_PM                                                                 03/09/2023 15:39:11 PAGE 11  

                #endif
              #endif
              
              #if HDMI_PORT
                #if HDMI_PORT==TMDS_PORT_A || HDMI_PORT==TMDS_PORT_B
                  #if HDMI_PORT==TMDS_PORT_A
                      msWriteByteMask(REG_PM_B3, BIT4, BIT4);//Switch to(A)[4]
                      msWriteByteMask(REG_PM_B2, 0x00, BIT0);//Not power down RCK(A)[0]
                  #else
                      msWriteByteMask(REG_PM_B3, BIT5, BIT5);//Switch to(B)[5]
                      msWriteByteMask(REG_PM_B2, 0x00, BIT1);//Not power down RCK(B)[1]
                  #endif
                      msWriteByteMask(REG_PM_B2, 0x00, BIT2);//Not power down CLKIN(A/B)[2]
                      msWriteByteMask(REG_PM_8F, 0x00, 0x0F);// DVI RAW clock (A/B) pass
                      
                #elif (HDMI_PORT==(TMDS_PORT_B|TMDS_PORT_C))
                        msWriteByteMask(REG_PM_B3, 0, BIT4);//Switch to(B)[5]
                      msWriteByteMask(REG_PM_B3, BIT5, BIT5);//Switch to(B)[5]
                      msWriteByteMask(REG_PM_B2, 0x00, BIT1);//Not power down RCK(B)[1]
                      msWriteByteMask(REG_PM_B2, 0x00, BIT2);//Not power down CLKIN(A/B)[2]
                      msWriteByteMask(REG_PM_8F, 0x00, 0x0F);// DVI RAW clock (A/B) pass
                      msWriteByteMask(REG_PM_8C, 0x00, 0x0F);// DVI RAW clock (C)pass  Ñ¡ÔñC prot clock  20180822 ÅíÒ¢
                #else
                      msWriteByteMask(REG_PM_B3, 0x00, BIT0);//Not power down RCK(B)[1]
                      msWriteByteMask(REG_PM_B3, 0x00, BIT2);//Not power down CLKIN(C)[2]
                      msWriteByteMask(REG_PM_8C, 0x00, 0x0F);// DVI RAW clock (C)pass
                #endif
              #endif
                  }
                  else
                  {
                      msWriteByteMask(REG_PM_8E, 0x0B, 0x0F);// DVI clock gating
                      msWriteByteMask(REG_PM_B2, BIT2|BIT1|BIT0, BIT2|BIT1|BIT0);// power down DVI(A/B) [0][1]:RCK,[2]:C
             -LK
                      msWriteByteMask(REG_PM_8F, 0x0B, 0x0F);// DVI RAW clock(A/B)gating
                  #if DVI_PORT==TMDS_PORT_C || HDMI_PORT==TMDS_PORT_C
                      msWriteByteMask(REG_PM_B3, BIT2|BIT0, BIT2|BIT0);// power down DVI(C) [0]:RCK,[2]:CLKIN
                      msWriteByteMask(REG_PM_8C, 0x0B, 0x0F);// DVI RAW clock(C)gating
                  #endif
                  }
              #endif
 643   1      }
 644          
 645          //**************************************************************************
 646          //  [Function Name]:
 647          
 648          //                  msPM_EnableDVIDetect(BOOL bEnable)
 649          //  [Description]
 650          //                  Enable DVI Clock Detect -using DVI control clock
 651          //  [Arguments]:
 652          //
 653          //  [Return]:
 654          //
 655          //**************************************************************************
 656          void
 657          msPM_EnableDVIDetect(BOOL bEnable)
 658          {
 659   1          if( bEnable)
 660   1          {
 661   2              //PM_DVIRAW1_CLK_GATE_EN(FALSE);//msWriteByteMask(REG_PM_8C, 0x00, 0x0F);   // DVI RAW clock (C)no
             -t gating
 662   2              msWriteByteMask(REG_PM_8F, 0x00, 0x0F);   // DVI RAW clock (A/B)not gating
C51 COMPILER V9.01   MS_PM                                                                 03/09/2023 15:39:11 PAGE 12  

 663   2              //msWriteByteMask(REG_PM_8E, 0x00, 0x0F);   // DVI clock not gating
 664   2              msPM_EnableRterm(TRUE);
 665   2       #if 0       
              #if (CHIP_ID == CHIP_TSUMV) // 110901 coding, check it again   
                      msWriteByteMask(REG_PM_B2, 0x00, BIT3|BIT2|BIT1|BIT0); // NOT power down DVI(A/B) CKIN and RCK
              #else
                      msWriteByteMask(REG_PM_B2, 0x00, BIT2|BIT1|BIT0); // NOT power down DVI(A/B) CKIN and RCK
              #endif
                      msWriteByteMask(REG_PM_B3, 0x00, BIT2|BIT0);      // NOT power down DVI( C) CLKIN and RCK
                      msWriteByteMask(REG_PM_B3, BIT4, BIT5|BIT4);  
              #endif  
 674   2                      #if CHIP_ID == CHIP_TSUMU &&(/* INPUT_TYPE == INPUT_1A1D1H1DP||*/INPUT_TYPE == INPUT_1A2H1DP)
                              if(UserPrefInputSelectType == INPUT_PRIORITY_HDMI)
                              {
                                      #if DVI_PORT == TMDS_PORT_C
                                      msWriteByteMask(REG_DVI_DET, EN_DVI_DET_C, EN_DVI_DET_MASK); // Detection channel selection
                                      #else
                                      msWriteByteMask(REG_DVI_DET, EN_DVI_DET_AB, EN_DVI_DET_MASK); // Detection channel selection
                                      #endif
                              }
                              else if(UserPrefInputSelectType == INPUT_PRIORITY_HDMI2ND)
                              {
                                      #if HDMI_PORT == TMDS_PORT_C
                                      msWriteByteMask(REG_DVI_DET, EN_DVI_DET_C, EN_DVI_DET_MASK); // Detection channel selection
                                      #else
                                      msWriteByteMask(REG_DVI_DET, EN_DVI_DET_AB, EN_DVI_DET_MASK); // Detection channel selection
                                      #endif
                              }
                              else
                                      msWriteByteMask(REG_DVI_DET, EN_DVI_DET_SET, EN_DVI_DET_MASK); // Detection channel selection
                              #elif (CHIP_ID == CHIP_TSUMU &&(INPUT_TYPE == INPUT_1D1H1DP))
                                      msWriteByteMask(REG_DVI_DET, EN_DVI_DET_SET, EN_DVI_DET_MASK); // Detection channel selection
                               //msWriteByteMask(REG_DVI_DET, EN_DVI_DET_SET, EN_DVI_DET_MASK); // Detection channel selection
                              #else
 697   2              msWriteByteMask(REG_DVI_DET, EN_DVI_DET_SET, EN_DVI_DET_MASK); // Detection channel selection
 698   2              #endif
 699   2      #if !PM_SUPPORT_DVI_TIME_SHARE
 700   2              msPM_EnableDVIClockAmp(FALSE);
 701   2      #if (CHIP_ID == CHIP_TSUMC || CHIP_ID == CHIP_TSUMD||CHIP_ID == CHIP_TSUM9||CHIP_ID == CHIP_TSUMF)
 702   2              msWriteByteMask(REG_PM_CC, 0x00, 0x0F);  // Not Controlled by amplifier
 703   2      #else
                      msWriteByteMask(REG_PM_AD, 0x00, 0x0F);  // Not Controlled by amplifier
              #endif
 706   2      #else
                      msPM_EnableDVIClockAmp(TRUE);
              #if (CHIP_ID == CHIP_TSUMC || CHIP_ID == CHIP_TSUMD||CHIP_ID == CHIP_TSUM9||CHIP_ID == CHIP_TSUMF)
                      msWriteByteMask(REG_PM_CC, 0x0F, 0x0F);  // Not Controlled by amplifier
              #else
                      msWriteByteMask(REG_PM_AD, 0x0F, 0x0F);  // Controlled by amplifier
              #endif
                      switch(sPMInfo.sPMConfig.ePMDVImode)
                      {
                      case ePMDVI_DVI0:
                          msWriteByteMask(REG_DVI_CHEN, BIT0, EN_DVI_CHEN_MASK);
                          break;
                      case ePMDVI_DVI1:
                          msWriteByteMask(REG_DVI_CHEN, BIT1, EN_DVI_CHEN_MASK);
                          break;
                      case ePMDVI_DVI0_DVI1:
                          msWriteByteMask(REG_DVI_CHEN, BIT1|BIT0, EN_DVI_CHEN_MASK);
                          break;
                      default: ;
C51 COMPILER V9.01   MS_PM                                                                 03/09/2023 15:39:11 PAGE 13  

                      }
              #endif       
 727   2          }
 728   1          else
 729   1          {
 730   2             msWriteByteMask(REG_DVI_DET, 0, EN_DVI_DET_MASK);
 731   2          #if HDMI_PRETEST
                      #if CHIP_ID >= CHIP_TSUMC
                          msPM_EnableRterm(FALSE);
                      #else
                           msPM_EnableRterm(TRUE);
                      #endif
                  #else
 738   2              msPM_EnableRterm(FALSE);
 739   2          #endif
 740   2          }
 741   1      }
 742          #endif  // end of #if( PM_SUPPORT_WAKEUP_DVI )
 743          
 744          
 745          //**************************************************************************
 746          //  [Function Name]:
 747          //                  msPM_EnableSARDetect(BOOL bEnable)
 748          //  [Description]
 749          //                  msPM_EnableSARDetect
 750          //  [Arguments]:
 751          //
 752          //  [Return]:
 753          //
 754          //**************************************************************************
 755          void
 756          msPM_EnableSARDetect(BOOL bEnable)
 757          {
 758   1          if (bEnable)
 759   1          {
 760   2              switch(sPMInfo.sPMConfig.ePMSARmode)
 761   2              {
 762   3              case ePMSAR_SAR0:
 763   3                      msWriteByteMask(REG_SINGLE_KEY, EN_SAR_SINGLE_SET, EN_SAR_SINGLE_MASK);
 764   3                      msWriteByteMask(REG_SAR_CMP, EN_SAR_14V, EN_SAR_CMP_MASK);
 765   3                      msWriteByteMask(REG_SAR_ANYKEY, 0, EN_SAR_ANYKEY_MASK);
 766   3                      break;
 767   3              case ePMSAR_SAR1:
 768   3                      msWriteByteMask(REG_SINGLE_KEY, 0x11, EN_SAR_SINGLE_MASK);
 769   3                      msWriteByteMask(REG_SAR_CMP, EN_SAR_05V, EN_SAR_CMP_MASK);
 770   3                      msWriteByteMask(REG_SAR_ANYKEY, 0, EN_SAR_ANYKEY_MASK);
 771   3                      break;
 772   3              case ePMSAR_SAR2:
 773   3                      msWriteByteMask(REG_SINGLE_KEY, 0x12, EN_SAR_SINGLE_MASK);
 774   3                      msWriteByteMask(REG_SAR_CMP, EN_SAR_05V, EN_SAR_CMP_MASK);
 775   3                      msWriteByteMask(REG_SAR_ANYKEY, 0, EN_SAR_ANYKEY_MASK);
 776   3                      break;
 777   3              case ePMSAR_SAR3:
 778   3                      msWriteByteMask(REG_SINGLE_KEY, 0x13, EN_SAR_SINGLE_MASK);
 779   3                  msWriteByteMask(REG_SAR_CMP, EN_SAR_05V, EN_SAR_CMP_MASK);
 780   3                      msWriteByteMask(REG_SAR_ANYKEY, 0, EN_SAR_ANYKEY_MASK);
 781   3                  break;
 782   3              case ePMSAR_SAR12:
 783   3                      msWriteByteMask(REG_SINGLE_KEY, 0, EN_SAR_SINGLE_MASK);
 784   3                      msWriteByteMask(REG_SAR_CMP, EN_SAR_14V, EN_SAR_CMP_MASK);
 785   3                      msWriteByteMask(REG_SAR_ANYKEY, EN_SAR_2CH_SET, EN_SAR_ANYKEY_MASK);
 786   3                      msWriteByteMask(REG_3A64,0,BIT2);
C51 COMPILER V9.01   MS_PM                                                                 03/09/2023 15:39:11 PAGE 14  

 787   3                      break;
 788   3              case ePMSAR_SAR123:
 789   3                      msWriteByteMask(REG_SINGLE_KEY, 0, EN_SAR_SINGLE_MASK);
 790   3                      msWriteByteMask(REG_SAR_CMP, EN_SAR_14V, EN_SAR_CMP_MASK);
 791   3                      msWriteByteMask(REG_SAR_ANYKEY, EN_SAR_3CH_SET, EN_SAR_ANYKEY_MASK);
 792   3                      msWriteByteMask(REG_3A64,0,BIT2);
 793   3                      break;
 794   3                  case ePMSAR_SAR01:
 795   3                      msWriteByteMask(REG_SINGLE_KEY, 0, EN_SAR_SINGLE_MASK);
 796   3                      msWriteByteMask(REG_SAR_CMP, EN_SAR_05V, EN_SAR_CMP_MASK);
 797   3                      msWriteByteMask(REG_SAR_ANYKEY, EN_SAR_2CH_SET, EN_SAR_ANYKEY_MASK);
 798   3                      msWriteByteMask(REG_3A64,BIT2,BIT2);
 799   3                      break;
 800   3                  case ePMSAR_SAR012:
 801   3                      msWriteByteMask(REG_SINGLE_KEY, 0, EN_SAR_SINGLE_MASK);
 802   3                      msWriteByteMask(REG_SAR_CMP, EN_SAR_05V, EN_SAR_CMP_MASK);
 803   3                      msWriteByteMask(REG_SAR_ANYKEY, EN_SAR_3CH_SET, EN_SAR_ANYKEY_MASK);
 804   3                      msWriteByteMask(REG_3A64,BIT2,BIT2);
 805   3                  break;
 806   3              }
 807   2              msWriteByteMask(REG_3A62,sPMInfo.sPMConfig.ePMSARmode,0x0F);
 808   2              msWriteByteMask(REG_SAR_GPIO, EN_SAR_DET_SET, EN_SAR_DET_MASK);
 809   2             
 810   2          }
 811   1          else
 812   1          {
 813   2              msWriteByteMask(REG_SINGLE_KEY, 0, EN_SAR_SINGLE_MASK);
 814   2              msWriteByteMask(REG_SAR_GPIO, 0, EN_SAR_DET_MASK);
 815   2              msWriteByteMask(REG_SAR_ANYKEY, 0, EN_SAR_ANYKEY_MASK);
 816   2          }
 817   1      }
 818          
 819          #if PM_CABLEDETECT_USE_GPIO
              //**************************************************************************
              //  [Function Name]:
              //                  msPM_EnableGPIODetect(BOOL bEnable)
              //  [Description]
              //                  msPM_EnableGPIODetect
              //  [Arguments]:
              //
              //  [Return]:
                      
              //**************************************************************************
              void
              msPM_CableDetectStates()
              
              {
              
                         WORD INV_GPIO_POL_SET_Temp=INV_GPIO_POL_SET;
              #if !(CABLE_DETECT_VGA_USE_SAR)
                         if(hwDSUBCable_Pin)
              
                                   INV_GPIO_POL_SET_Temp=(INV_GPIO_POL_SET_Temp)&~PM_VGACBL_DET;             
              #endif  
              #if !(CABLE_DETECT_VGA_USE_SAR)
                         if(hwDVICable_Pin)
              
                                   INV_GPIO_POL_SET_Temp=(INV_GPIO_POL_SET_Temp)&~PM_DVICBL_DET;
                      #endif             
              #if ENABLE_DP_INPUT
                      //if(!(DP_CABLE_NODET))
                      if(!hwDPCable_Pin)
C51 COMPILER V9.01   MS_PM                                                                 03/09/2023 15:39:11 PAGE 15  

                              INV_GPIO_POL_SET_Temp=(INV_GPIO_POL_SET_Temp)&~PM_DPCBL_DET;
              #endif
              #if 0
                         if(DET_HDMIA)     
              
                                   INV_GPIO_POL_SET_Temp=(INV_GPIO_POL_SET_Temp)&~PM_HDMIACBL_DET;                      
             -       
              
                         if(DET_HDMIB)    
              
                                   INV_GPIO_POL_SET_Temp=(INV_GPIO_POL_SET_Temp)&~PM_HDMIBCBL_DET;                      
             -       
              
                         if(DET_HDMIC)
              
                                   INV_GPIO_POL_SET_Temp=(INV_GPIO_POL_SET_Temp)&~PM_HDMICCBL_DET;
              #endif
                         
              
                         msWrite2ByteMask(REG_PM_62,INV_GPIO_POL_SET_Temp, INV_GPIO_POL_MASK);                     
              
              }
              #endif
 870          void
 871          msPM_EnableGPIODetect(BOOL bEnable)
 872          {
 873   1          if(bEnable)
 874   1          {       
 875   2              msWrite2ByteMask(REG_PM_60 , EN_GPIO_DET_SET , EN_GPIO_DET_MASK);
 876   2              msWrite2ByteMask(REG_PM_62, INV_GPIO_POL_SET, INV_GPIO_POL_MASK);
 877   2              #if  PM_CABLEDETECT_USE_GPIO
                      msPM_CableDetectStates();
                      #endif
 880   2          }
 881   1          else
 882   1          {
 883   2              msWrite2ByteMask(REG_PM_60 , 0x00, EN_GPIO_DET_MASK);
 884   2              msWrite2ByteMask(REG_PM_62, 0x00, INV_GPIO_POL_MASK);
 885   2          }
 886   1      }
 887          
 888          
 889          //**************************************************************************
 890          //  [Function Name]:
 891          //                  msPM_EnableMCCSDetect(BOOL bEnable)
 892          //  [Description]
 893          //                  msPM_EnableMCCSDetect
 894          //  [Arguments]:
 895          //
 896          //  [Return]:
 897          //
 898          //**************************************************************************
 899          void
 900          msPM_EnableMCCSDetect(BOOL bEnable)
 901          {
 902   1          if(bEnable)
 903   1          {
 904   2               msWriteByte(REG_3E0A, 0xB7);  // enable DDC2Bi for A0
 905   2              #if (DVI_DDC_PORT==TMDS_PORT_A) || (HDMI_DDC_PORT==TMDS_PORT_A) //121130 Modify
 906   2              msWriteByte(REG_3E0C, 0xB7);  // enable DDC2Bi for D0
 907   2              #endif
 908   2              msWriteByte(REG_3E0D, 0xB7);  // enable DDC2Bi for D1
C51 COMPILER V9.01   MS_PM                                                                 03/09/2023 15:39:11 PAGE 16  

 909   2              msWriteByte(REG_3E52, 0xB7);  // enable DDC2Bi for D2
 910   2              msWriteByteMask(REG_3E09, 0, (BIT1|BIT0)); //disable No ACK ,Hold CLK
 911   2              
 912   2            #if CHIP_ID == CHIP_TSUMV
                              msWriteByteMask(REG_3EC1, BIT6, BIT6);//Enable MCCS wake up function for ADC (D6 01 04 05)
                              msWriteByteMask(REG_3EC0, BIT6|BIT4|BIT2, BIT6|BIT4|BIT2);//[6]:clear REG_3EC2[2], [4]:clear REG_0186[7]
             -, [2]:clear ADC wake up command value
                              msWriteByteMask(REG_3EC1, BIT7, BIT7);//Enable MCCS wake up function for DVI (D6 01 04 05)
                              msWriteByteMask(REG_3EC0, BIT7|BIT5|BIT3, BIT7|BIT5|BIT3);//[7]:clear REG_3EC2[3], [5]:clear REG_0186[7]
             -, [3]:clear DVI wake up command value
                    #elif (CHIP_ID == CHIP_TSUMC || CHIP_ID == CHIP_TSUMD || CHIP_ID == CHIP_TSUM9||CHIP_ID == CHIP_TSUM
             -F)
 918   2              msWriteByteMask(REG_3EC1, BIT7|BIT6, BIT7|BIT6); // enable A0, D0
 919   2              msWriteByteMask(REG_3EEF, BIT7|BIT6, BIT7|BIT6); // enable D1, D2
 920   2            #else
                      msWriteByteMask(REG_3EC1, (BIT4|BIT3|BIT2), (BIT4|BIT3|BIT2)); // enable MCCS wakeup by power key 
             -04, 05
                    #endif
 923   2          }
 924   1          else
 925   1          {
 926   2            
 927   2              msWriteBit(REG_3E0A, 0, BIT7);  // disable DDC2Bi for A0
 928   2              msWriteBit(REG_3E0C, 0, BIT7);  // disable DDC2Bi for D0
 929   2              msWriteBit(REG_3E0D, 0, BIT7);  // disable DDC2Bi for D1
 930   2              msWriteBit(REG_3E52, 0, BIT7);  // disable DDC2Bi for D2
 931   2              
 932   2            #if CHIP_ID == CHIP_TSUMV
                              msWriteByteMask(REG_3EC0, BIT6|BIT4|BIT2, BIT6|BIT4|BIT2);//[6]:clear REG_3EC2[2], [4]:clear REG_0186[7]
             -, [2]:clear ADC wake up command value
                              msWriteByteMask(REG_3EC1, 0, BIT6);//0->Bit6//Disable MCCS wake up function for ADC (D6 01 04 05)
                              msWriteByteMask(REG_3EC0, BIT7|BIT5|BIT3, BIT7|BIT5|BIT3);//[7]:clear REG_3EC2[3], [5]:clear REG_0186[7]
             -, [3]:clear DVI wake up command value
                              msWriteByteMask(REG_3EC1, 0, BIT7);//Disable MCCS wake up function for DVI (D6 01 04 05)
                    #elif (CHIP_ID == CHIP_TSUMC || CHIP_ID == CHIP_TSUMD || CHIP_ID == CHIP_TSUM9||CHIP_ID == CHIP_TSUM
             -F)
 938   2              msWriteByteMask(REG_3EC1, 0, BIT7|BIT6); // disable A0, D0
 939   2              msWriteByteMask(REG_3EEF, 0, BIT7|BIT6); // disable D1, D2
 940   2            #else
                      msWriteByteMask(REG_3EC1, 0, (BIT4|BIT3|BIT2) ); // disable MCCS wakeup by power key 04, 05
                    #endif
 943   2          }
 944   1      }
 945          
 946          
 947          //**************************************************************************
 948          //  [Function Name]:
 949          //                  msPM_EDID_READ()
 950          //  [Description]
 951          //                  msPM_EDID_READ
 952          //  [Arguments]:
 953          //
 954          //  [Return]:
 955          //
 956          //**************************************************************************
 957          void
 958          msPM_Enable_EDID_READ(BOOL bEnable)
 959          {
 960   1          if(bEnable)
 961   1          {
 962   2              //msWriteByteMask(REG_3E45, BIT7, BIT7);  // enable DDC function for DVI_0
 963   2              //msWriteByteMask(REG_3E4D, BIT7, BIT7);  // enable DDC function for DVI_1
C51 COMPILER V9.01   MS_PM                                                                 03/09/2023 15:39:11 PAGE 17  

 964   2            //  msWriteByteMask(REG_3E49, BIT7, BIT7);  // enable DDC function for ADC_0
 965   2      #if(CHIP_ID == CHIP_TSUM9||CHIP_ID == CHIP_TSUMF)
                     // msWriteByteMask(REG_3E60, BIT7, BIT7);//reply ACK while source accesses A0_EDID with address is 
             -over 128
              #endif  
 968   2      #if (CHIP_ID == CHIP_TSUMC || CHIP_ID == CHIP_TSUMD)
 969   2            //  msWriteByteMask(REG_3E58, BIT7, BIT7);  // enable DDC function for DVI_2
 970   2            #endif
 971   2          }
 972   1          else
 973   1          {
 974   2             // msWriteByteMask(REG_3E45, 0x00, BIT7);  // disable DDC function for DVI_0
 975   2             // msWriteByteMask(REG_3E4D, 0x00, BIT7);  // disable DDC function for DVI_1
 976   2              //msWriteByteMask(REG_3E49, 0x00, BIT7);  // disable DDC function for ADC_0
 977   2      #if (CHIP_ID == CHIP_TSUMC || CHIP_ID == CHIP_TSUMD)
 978   2             // msWriteByteMask(REG_3E58, 0x00, BIT7);  // disable DDC function for DVI_2
 979   2            #endif
 980   2          }
 981   1      }
 982          
 983          //**************************************************************************
 984          //  [Function Name]:
 985          //                  msPM_OutputTriState()
 986          //  [Description]
 987          //                  msPM_OutputTriState
 988          //  [Arguments]:
 989          //
 990          //  [Return]:
 991          //
 992          //**************************************************************************
 993          void
 994          msPM_OutputTriState(void)
 995          {
 996   1      
 997   1      
 998   1      }
 999          
1000          
1001          //**************************************************************************
1002          //  [Function Name]:
1003          //                  msPM_PowerDownMacro()
1004          //  [Description]
1005          //                  msPM_PowerDownMacro
1006          //  [Arguments]:
1007          //
1008          //  [Return]:
1009          //
1010          //**************************************************************************
1011          void  msPM_PowerDownMacro(void)
1012          {   
1013   1          msPM_InterruptEnable(FALSE);
1014   1      
1015   1      #if (CHIP_ID == CHIP_TSUMB || ENABLE_RTE)
                  msWriteByteMask( REG_1207, BIT4, BIT4 ); // Ãö³¬°ÊºA¬Ù¹q¼Ò¦¡
                  msWriteByteMask( REG_1200, 0, BIT1 );   //Bank12: reg_cke =1
                  msWriteByteMask( REG_1203, 0, BIT4 );   //reg_cke_oenz=0
                  msWriteByteMask( REG_1203, BIT5, BIT5 ); //reg_dq_eonz=1
                  msWriteByteMask( REG_1203, BIT6, BIT6 ); //reg_adr_oenz=1
                  msWriteByteMask( REG_1203, BIT7, BIT7 ); //reg_cko_oenz=1
                  msWriteByteMask( REG_1100, BIT4, BIT4 ); //Gpio mode³]¬°1
                  msWriteByteMask( REG_1133, BIT5, BIT5 ); //Reg_ddrpll_reset³]¬°1
                  msWriteByteMask( REG_1133, BIT7, BIT7 ); //Reg_ddrpll_pd ³]¬°1
C51 COMPILER V9.01   MS_PM                                                                 03/09/2023 15:39:11 PAGE 18  

                  msWriteByteMask( REG_121E, BIT0, BIT0 ); //Reset ³]¬°1
                  msWriteByteMask( REG_1205, BIT2, BIT2 ); //Reg_mcp_en³]¬°0
                  msWriteByteMask( REG_1203, BIT4, BIT4 ); //reg_cke_oenz=0
              #endif
1029   1      
1030   1      #if CHIP_ID==CHIP_TSUMU         
              #if PM_SUPPORT_SOG_TIME_SHARE
                      msWriteByteMask(REG_2509, 0xFF, ~BIT7);
                  msWriteByte(REG_2508, 0xFF);    //Power down ADC_vref /vref/adc_rgb/phase_digitizer/adc_pll/dpl_bg
              #else
                      msWriteByteMask(REG_2509, 0xFF, ~(BIT7|BIT2|BIT1)); //dont power down SOG main/DAC
                      msWriteByteMask(REG_2508, 0xFF, ~BIT1);             //dont power down band gap
              #endif
              
               if( sPMInfo.sPMConfig.bHVSync_enable || sPMInfo.sPMConfig.bSOG_enable )
                      msWriteByteMask(REG_2508, 0x00, BIT1);
               if( !sPMInfo.sPMConfig.bSOG_enable )
                      msWriteByteMask(REG_2560, BIT0, BIT0);
               else
               {
                      msWriteByteMask(REG_2560, 0x00, BIT0);
                      msWriteByteMask(REG_2509, 0x00, BIT1|BIT2);
               }
                  //DVI
                      msWriteByteMask(REG_29C0, 0xFF, ~BIT3); // 121011 coding test
              #if HDMI_PRETEST
                      //msWriteByteMask(REG_29C0, 0x00, ~BIT3);
                      msWriteByteMask(REG_29C1, 0x00, ~(BIT5|BIT6));
              #else
                  //msWriteByteMask(REG_29C0, 0xFF, ~BIT3);
                  msWriteByteMask(REG_29C1, 0xFF, ~(BIT5|BIT6));
              #endif
                      
                  msWriteByteMask(REG_29D2, 0xFF, ~BIT3);
                  msWriteByteMask(REG_29D3, 0xFF, ~(BIT4|BIT5|BIT6));
              
                  //MOD ATOP
              
                  msWriteByte(REG_3200, 0x00); // sub bank 0
                  msWriteByteMask(REG_3265, 0x00, BIT2|BIT6);
                  msWriteByteMask(REG_3250, 0xFF, 0x1F);
                  msWriteByteMask(REG_3264, 0x00, 0x1F);
                  msWriteByteMask(REG_3250, 0xFF, 0x3F);
                  msWrite2Byte(REG_3220, 0x0000); // TTL
                  msWrite2Byte(REG_3222, 0x0000);
                  msWrite2Byte(REG_3224, 0x0000);
                  msWrite2Byte(REG_3230, 0x0000);
                  msWrite2Byte(REG_3232, 0x0000);
                  msWrite2Byte(REG_3234, 0x0000);
                  msWrite2Byte(REG_3236, 0x0000);
                  msWrite2Byte(REG_3238, 0x0000);
                  msWrite2Byte(REG_323A, 0x0000);
                  msWrite2Byte(REG_3228, 0xFFFF);
                  msWrite2Byte(REG_322A, 0xFFFF);
                  msWrite2Byte(REG_322C, 0xFFFF);
                  msWriteByteMask(REG_3265, 0xFF, BIT2|BIT6);
              
              
                  //DPRX
                      {
                              msWriteByte(REG_356C, 0x0F);    
                              msWrite2Byte(REG_37E8, 0xFFFF);
C51 COMPILER V9.01   MS_PM                                                                 03/09/2023 15:39:11 PAGE 19  

                              msWrite2Byte(REG_37EA, 0xFFFF);
                  #if ENABLE_DP_INPUT
                              msWriteByteMask(REG_356D, BIT0, BIT0);
                            //20120629  Xm, ASUSPB278Q_1Chip,   Cxxx
                             if ( PowerOnFlag )
                            {
                               msWriteByte( REG_1FE0, msReadByte( REG_1FE0 ) & 0xEF );          //[4]:Enable AUX IRQ
                               #if DP_SQUELCH_IRQ
                               msWriteByte( REG_1FE3, msReadByte( REG_1FE3 ) & 0x7F );          //[8]:Enable SQUELCH IRQ
                               #endif
                              }
                              else
                              {
                               msWriteByte( REG_1FE0, msReadByte( REG_1FE0 ) | 0x10 );            //[4]:Disable AUX IRQ
                               #if DP_SQUELCH_IRQ
                               msWriteByte( REG_1FE3, msReadByte( REG_1FE3 ) | 0x80 );           //[8]:Disable SQUELCH I
             -RQ
                               #endif
                              }
                              //20120629  Xm, ASUSPB278Q_1Chip,   Cxxx
                  #else
                              msWriteByteMask(REG_356D, BIT1|BIT0, BIT1|BIT0);   //Mark Bit 1 , when Turn off Bit, we have wake up iss
             -ue.
                  #endif    
                      }
                  msWriteByte(REG_3580, 0x1E);
              
                  //Audio
                  msWrite2Byte(REG_2C60, 0x2727);
                  msWrite2Byte(REG_2C62, 0x2F06);
                  msWrite2Byte(REG_2C64, 0x1800);
                  msWrite2Byte(REG_2C66, 0x0000);
                  msWrite2Byte(REG_2C68, 0x2003);
                  msWrite2Byte(REG_2C6A, 0x0850);
                  msWrite2Byte(REG_2C6C, 0x0800);
                 
                  //HDMI PLL
                  msWriteByteMask(REG_05B9, BIT0, BIT0);
                  //AU PLL
                  msWriteByteMask(REG_05F0, BIT3, BIT3);
                  //dprx Video AUPLL   
                  msWriteByteMask(REG_35D1, BIT0, BIT0);
                  //dprx Audio AUPLL
                  msWriteByteMask(REG_35B3, BIT0, BIT0);
                  //MOD LPLL
                  msWriteByteMask(REG_3881, BIT0, BIT0);
                 
                  //SCALAR LPLL
                  msWriteByteMask(REG_38A3, BIT7, BIT7);
                  //MPLL
                  //msWriteByteMask(REG_1ED1, BIT0, BIT0);
                  msWriteByteMask(REG_1EDC, BIT4|BIT5, BIT4|BIT5);
              
                  //DDR ATOP
                  msWriteByteMask(REG_1100, 0xFF, BIT5|BIT4|BIT3);
                  msWriteByteMask(REG_1108, 0x00, 0x3F);
                  msWriteByteMask(REG_110E, 0x00, BIT0);
                  msWriteByteMask(REG_1154, BIT4, BIT4);
                  msWriteByteMask(REG_1160, BIT1, BIT1);
                  msWriteByteMask(REG_1133, BIT7, BIT7);
                  //SDR
                  msWriteByteMask(REG_1205, 0x00, BIT2);
C51 COMPILER V9.01   MS_PM                                                                 03/09/2023 15:39:11 PAGE 20  

                  //ClK Gen
                  msWriteByteMask(REG_1E24, BIT0, BIT0);
                 #if(MainBoardType==MainBoard_MST9570S_DEMO)
                  msWriteByteMask(REG_1E25, 0x00, 0x00);
                  #else
                  msWriteByteMask(REG_1E25, BIT2, BIT2);
                  #endif
                  msWriteByteMask(REG_1E26, BIT4|BIT0, BIT4|BIT0);
                  msWriteByteMask(REG_1E27, BIT4, BIT4);
                  msWriteByteMask(REG_1E28, BIT0, BIT0);
                  msWriteByteMask(REG_1E29, BIT0, BIT0);
                  msWriteByteMask(REG_1E2A, BIT0, BIT0);
                  msWriteByteMask(REG_1E2B, BIT0, BIT0);
                  msWriteByteMask(REG_1E2C, BIT0, BIT0);
                  msWriteByteMask(REG_1E35, BIT0, BIT0);
                  msWriteByteMask(REG_1E36, BIT0, BIT0);
                  msWriteByteMask(REG_1E37, BIT0, BIT0);
                  msWriteByteMask(REG_1E3B, BIT6, BIT6);
                  msWriteByteMask(REG_1E3E, BIT0, BIT0);
                  msWriteByteMask(REG_1E3F, BIT0, BIT0);
                  msWriteByteMask(REG_1E40, BIT4|BIT0, BIT4|BIT0);
                  msWriteByteMask(REG_1E41, BIT0, BIT0);
                  msWriteByteMask(REG_1E44, BIT0, BIT0);
                  msWriteByteMask(REG_1E45, BIT6, BIT6);
                  msWriteByteMask(REG_1E46, BIT4|BIT0, BIT4|BIT0);
                  msWriteByteMask(REG_1E47, BIT4|BIT0, BIT4|BIT0);
                  //dont remove this setting , Garstin need setting  !!
                  //crc collection of all the PM enable setting , if crc wrong , auto reset MCU w/o event trigger!!
                  msWriteBit(REG_0381, TRUE, _BIT7);   //crc function disable
              #elif (CHIP_ID == CHIP_TSUMC || CHIP_ID == CHIP_TSUMD)
1177   1          //Audio
1178   1          
1179   1              //HPLL power on
1180   1              msWriteByteMask( REG_1707, BIT0, BIT0 );
1181   1              msWriteByteMask( REG_1783, BIT0, BIT0 );
1182   1              //LPLL
1183   1              msWriteByteMask( REG_3806, BIT5, BIT5);
1184   1              //MPLL
1185   1              msWriteByteMask(REG_1EDC, BIT4|BIT5, BIT4|BIT5);
1186   1              //DPLL
1187   1          
1188   1              //DDR ATOP
1189   1              msWrite2Byte(REG_1206,0x3420); //cke always on
1190   1              msWrite2Byte(REG_1246,0xFFFE);
1191   1              ForceDelay1ms(1);
1192   1              msWrite2Byte(REG_1218,0x0400);
1193   1              msWrite2Byte(REG_1200,0x002F);//off auto refresh
1194   1              msWrite2Byte(REG_1200,0x052E);//triggle precharge all
1195   1              msWrite2Byte(REG_1200,0x002E);
1196   1              msWrite2Byte(REG_1200,0x032E);//triggle refresh
1197   1              msWrite2Byte(REG_1200,0x002E);//cke always on
1198   1              ForceDelay1ms(1);
1199   1              msWrite2Byte(REG_1246,0xFFFF);
1200   1              msWrite2Byte(REG_1200,0x202E);//self refresh on
1201   1              msWriteByteMask(REG_1100, BIT5|BIT4|BIT3, BIT5|BIT4|BIT3);
1202   1          #if CHIP_ID == CHIP_TSUMD
                      msWriteByteMask(REG_1101, BIT7, BIT7);
                      msWriteByteMask(REG_1108, 0, 0x3F);
                      msWriteByteMask(REG_110E, 0, BIT0);
                  #endif
1207   1              msWriteByteMask(REG_1133, BIT7, BIT7);
1208   1          
C51 COMPILER V9.01   MS_PM                                                                 03/09/2023 15:39:11 PAGE 21  

1209   1          #if CHIP_ID == CHIP_TSUMD
                      //ldo ddr
                      msWriteByteMask(REG_1E02, 0, BIT3);
                  #endif
1213   1              //ClK Gen
1214   1              msWriteByteMask(REG_1E24, BIT4|BIT0, BIT4|BIT0);
1215   1              msWriteByteMask(REG_1E25, BIT2, BIT2);
1216   1          #if CHIP_ID == CHIP_TSUMC
1217   1              msWriteByteMask(REG_1E26, BIT4|BIT0, BIT4|BIT0);
1218   1          #endif
1219   1              msWriteByteMask(REG_1E28, BIT0, BIT0);
1220   1          #if CHIP_ID == CHIP_TSUMD
                      msWriteByteMask(REG_1E2A, BIT0, BIT0);
                  #endif
1223   1              msWriteByteMask(REG_1E35, BIT0, BIT0);
1224   1              msWriteByteMask(REG_1E37, BIT2|BIT0, BIT2|BIT0);
1225   1              msWriteByteMask(REG_1E3E, BIT0, BIT0);
1226   1              msWriteByteMask(REG_1E40, BIT4|BIT0, BIT4|BIT0);
1227   1              msWriteByteMask(REG_1E46, BIT0, BIT0);
1228   1              msWriteByteMask(REG_1E47, BIT0, BIT0);
1229   1              //audio CLK Gen
1230   1              msWriteByteMask(REG_2C07, 0x00, 0xFF);
1231   1                      
1232   1          #if (CHIP_ID == CHIP_TSUMC)
1233   1              msWriteByteMask(REG_01BB,0x0000,0x0030); //20171113
1234   1          #endif
1235   1              
1236   1          #elif (CHIP_ID == CHIP_TSUMJ || CHIP_ID == CHIP_TSUM9||CHIP_ID == CHIP_TSUMF)
              
              
              
                      //>>>ADC---------------------------------------------------------------------------------
                      if( sPMInfo.sPMConfig.bHVSync_enable || sPMInfo.sPMConfig.bSOG_enable )
                      {
                          msWriteByteMask(REG_2509, 0xFF&(~(BIT7|BIT2|BIT1))  , 0xFF);
                          msWriteByteMask(REG_2508, 0xFF&(~(BIT2|BIT1))                       , 0xFF);
                          msWriteByteMask(REG_2560, 0x00                                              , BIT0);
                          msWriteByteMask(REG_250C, 0xFF                                              , 0xFF);
                          msWriteByteMask(REG_250D, 0xFF                                              , 0xFF);
                          msWrite2ByteMask(REG_25F0, 0x0002                                   , 0xFFFF);
                          msWrite2ByteMask(REG_25F2, 0x00C8                                   , 0xFFFF);
                          msWriteByteMask(REG_25F4, 0x04                                              , 0x0E);
                      }
                      else
                      {
                          msWriteByteMask(REG_2509, 0xFF      , 0xFF);
                          msWriteByteMask(REG_2508, 0xFF      , 0xFF);
                          msWriteByteMask(REG_2560, BIT0      , BIT0);
                          msWriteByteMask(REG_250C, 0xFF      , 0xFF);
                          msWriteByteMask(REG_250D, 0xFF      , 0xFF);
                          msWrite2ByteMask(REG_25F0, 0x000    , 0xFFFF);
                          msWrite2ByteMask(REG_25F2, 0x000    , 0xFFFF);
                          msWriteByteMask(REG_25F4, 0x00      , 0x0E);
                      }
                      //<<<ADC---------------------------------------------------------------------------------
              /*      //>>>DVI ATOP---------------------------------------------------------------------------------
                      //confirming with RD Ocasi
                      #if( PM_SUPPORT_WAKEUP_DVI )
                      if( sPMInfo.sPMConfig.bDVI_enable)
                      {
                          msWriteByteMask(REG_01C2,BIT5 ,BIT6|BIT5);
                          msWriteByteMask(REG_01C3,0x00 ,BIT7|BIT5|BIT4);
C51 COMPILER V9.01   MS_PM                                                                 03/09/2023 15:39:11 PAGE 22  

                          msWriteByteMask(REG_01CD,0x00 ,BIT0);
                          msWriteByteMask(REG_01CC,0x00 ,BIT2|BIT1|BIT0);
                          msWriteByteMask(REG_01CE, BIT3 ,BIT3|BIT2|BIT1|BIT0);        //diff
                          msWriteByteMask(REG_17BE, BIT0 ,BIT0);
                          msWriteByteMask(REG_17C0, 0xA7 ,BIT7|BIT5|BIT2|BIT1|BIT0);   //diff
                          msWriteByteMask(REG_17C1, 0x3F ,BIT5|BIT4|BIT3|BIT2|BIT1|BIT0);
                      }
                      else
                      #endif
                      {
                          msWriteByteMask(REG_01C2,0x00 ,BIT6|BIT5);
                          msWriteByteMask(REG_01C3,0x0B ,BIT7|BIT5|BIT4);
                          msWriteByteMask(REG_01CD,0x00 ,BIT0);
                          msWriteByteMask(REG_01CC,0x00 ,BIT2|BIT1|BIT0);
                          msWriteByteMask(REG_01CE, 0x0F ,BIT3|BIT2|BIT1|BIT0);         //Diff
                          msWriteByteMask(REG_17BE, BIT0 ,BIT0);
                          msWriteByteMask(REG_17C0, 0xA7 ,BIT7|BIT5|BIT2|BIT1|BIT0);    //Diff
                          msWriteByteMask(REG_17C1, 0x3F ,BIT5|BIT4|BIT3|BIT2|BIT1|BIT0);
                      }
              */      //<<<DVI---------------------------------------------------------------------------------
                      //>>>MOD ATOP---------------------------------------------------------------------------------
                      //msWriteByteMask(REG_30F0, BIT0, BIT0);
                      //msWriteByteMask(REG_30EE, 0x00, BIT2|BIT1|BIT0);
                      //msWriteByteMask(REG_30DA, 0x00, 0xFF);
                      //msWrite2ByteMask(REG_308C, 0x00, 0xFFFF);
                      //msWriteByteMask(REG_308E, 0x00, 0x1F);
                      msWriteByteMask(REG_308A,  BIT5|BIT4, BIT5|BIT4);
                      //<<<MOD ATOP---------------------------------------------------------------------------------
                      //>>>KeyPad SAR---------------------------------------------------------------------------------
                      //msWriteByteMask(REG_3A60,BIT6, BIT6);       //[6]SAR_PD
                      //<<<KeyPad SAR---------------------------------------------------------------------------------
                      //>>>MPLL_PD---------------------------------------------------------------------------------
                      //msWriteByteMask(REG_1ED1,BIT0, BIT0);             // [4]: MPLL power DOWN   //move to msPM_SetPMClock()
                      msWriteByteMask(REG_1EDC, BIT5|BIT4, BIT5|BIT4);                //[5][4]:Power Down MPLL 216/432
                      //<<<MPLL_PD---------------------------------------------------------------------------------
                      //>>>Clock Gen---------------------------------------------------------------------------------
                      msWriteByteMask(REG_1E24,BIT0, BIT0);
                      msWriteByteMask(REG_1E3E,BIT0, BIT0);
                      msWriteByteMask(REG_1E35,BIT0, BIT0);
                      msWriteByteMask(REG_1E37,BIT2|BIT0, BIT2|BIT0);
                      msWriteByteMask(REG_1E47,BIT0, BIT0);
                      msWriteByteMask(REG_1E25,BIT2, BIT2);
              
                      msWriteByteMask(REG_1E28,BIT0, BIT0);
                      msWriteByteMask(REG_1E46,BIT0, BIT0);
                      msWriteByteMask(REG_1E24,BIT4, BIT4);
              #if (CHIP_ID == CHIP_TSUMJ)
                      msWriteByteMask(REG_1E40,BIT4|BIT0, BIT4|BIT0); // LED
                      msWriteByteMask(REG_1E2A,BIT0, BIT0);
              #endif
              #if (CHIP_ID == CHIP_TSUM9||CHIP_ID == CHIP_TSUMF)
              #if ENABLE_DP_INPUT
                      DPRxOutputEnable( FALSE );
              #endif
                      msWriteByteMask(REG_1ECA, 0x1F, 0x1F);  // osc432m power down
              #endif
              #else 
                  #if PM_SUPPORT_SOG_TIME_SHARE
                      msWriteByteMask(REG_2509, 0xFF, ~BIT7);
                      msWriteByte(REG_2508, 0xFF);    //Power down ADC_vref /vref/adc_rgb/phase_digitizer/adc_pll/dpl_bg
                  #else
                      msWriteByteMask(REG_2509, 0xFF, ~(BIT7|BIT2|BIT1)); //dont power down SOG main/DAC
C51 COMPILER V9.01   MS_PM                                                                 03/09/2023 15:39:11 PAGE 23  

                      msWriteByteMask(REG_2508, 0xFF, ~BIT1);             //dont power down band gap
                  #endif
                      if( sPMInfo.sPMConfig.bHVSync_enable || sPMInfo.sPMConfig.bSOG_enable )
                              msWriteByteMask(REG_2508, 0x00, BIT1);
                      if( !sPMInfo.sPMConfig.bSOG_enable )
                              msWriteByteMask(REG_2560, BIT0, BIT0);
                      else
                      {
                              msWriteByteMask(REG_2560, 0x00, BIT0);
                              msWriteByteMask(REG_2509, 0x00, BIT1|BIT2);
                      }
                      //DVI
                  #if HDMI_PRETEST
                      msWriteByteMask(REG_29C0, 0x00, ~BIT3);
                      msWriteByteMask(REG_29C1, 0x00, ~(BIT5|BIT6));
                  #else
                      msWriteByteMask(REG_29C0, 0xFF, ~BIT3);
                      msWriteByteMask(REG_29C1, 0xFF, ~(BIT5|BIT6));
                  #endif
              
                      msWriteByteMask(REG_29FE, 0xFF, ~(BIT7|BIT6));  
              #if CHIP_ID == CHIP_TSUMV && ! (USE_MOD_HW_CAL)
                      msWriteByteMask(REG_306C, 0, BIT6);
              #endif
                      msWriteByteMask(REG_306B, BIT2, BIT2);  //Power Down MOD IGEN
              
                      //ClK Gen
                      msWriteByteMask(REG_1E24,BIT0, BIT0);//[0]clk_osd_gate_l
                      msWriteByteMask(REG_1E35,BIT0, BIT0);//[0]clk_fclk_gate        
              #if CHIP_ID!=CHIP_TSUMV
                      msWriteByteMask(REG_1E36,BIT0, BIT0);//[0]clk_mod_gate
              #endif
                      msWriteByteMask(REG_1E37,BIT0, BIT0);//[0]clk_odclk1_I_gate
              #if CHIP_ID!=CHIP_TSUMV
                      msWriteByteMask(REG_1E3B,BIT6, BIT6);//[7]clk_miu_rec_gate
              #endif
                      msWriteByteMask(REG_1E3E,BIT0, BIT0);//[0]clk_idclk_i_gate
                      msWriteByteMask(REG_1E3F,BIT0, BIT0);//[0]clk_hspclk_gate
              #if CHIP_ID!=CHIP_TSUMV
                      msWriteByteMask(REG_1E41,BIT0, BIT0);//[0]clk_led_gate
                      msWriteByteMask(REG_1E45,BIT6, BIT6);//[6]clk_patgen_bias_gate
              #endif
                      msWriteByteMask(REG_1E47,BIT0, BIT0);//[0]clk_sysclk_ip_ga
                      
               #if CHIP_ID == CHIP_TSUMY
                  msWriteByteMask(REG_1E40, _BIT0, _BIT0);    //LED clock gating
                  msWriteByteMask(REG_0A60, _BIT6, _BIT6);    //LED SAR power down
                  msWrite2Byte(REG_0A80, 0x0000);          //Dimming PWM Disable
                  msWriteByteMask(REG_0A87, 0, _BIT7);        //Boost clock  Disable
                  msWriteByteMask(REG_0A95, 0, _BIT7);         //Boost PWM  Disable
                  msWriteByteMask(REG_0AE1, 0, _BIT7|_BIT6);   //Bias current and External resistor Disable
                  msWriteByteMask(REG_0A65, 0, _BIT6);            //Over temperature protectioni Disable
              #endif
              
              #if ( CHIP_ID == CHIP_TSUMB ) // 111216 coding, trunk   
                  msWriteByteMask(REG_1E25,BIT2, BIT2);               //[2]ckg_mclk_gate
                  msWriteByteMask(REG_1E28,BIT4|BIT0, BIT4|BIT0);   //[0]CLK_MEMPLL_gate [4]clk_led216_gate
              #endif
              
              #if HDMI_PRETEST
              #if CHIP_ID == CHIP_TSUMU
                  msWrite2ByteMask( REG_29C0, 0, 0xFFFF ); // enable DVI0 PLL power, [12:11]: portB/A Data R-term
C51 COMPILER V9.01   MS_PM                                                                 03/09/2023 15:39:11 PAGE 24  

              #else
                  msWriteByteMask(REG_01C4, 0x00, 0x0F); // Turn on Port 0 Date R-term
                  msWriteByteMask(REG_01C4, 0x00, 0xF0); // Turn on Port 1 Date R-term
                  msWriteByteMask(REG_01C5, 0x00, 0x0F); // Turn on Port 2 Date R-term
              #endif
              #endif
              
              #endif  
1403   1      
1404   1      
1405   1      }
1406          //**************************************************************************
1407          //  [Function Name]:
1408          //                  msPM_PowerUpMacro()
1409          //  [Description]
1410          //                  msPM_PowerUpMacro
1411          //  [Arguments]:
1412          //
1413          //  [Return]:
1414          //
1415          //**************************************************************************
1416          void msPM_PowerUpMacro(void)
1417          {
1418   1      #if CHIP_ID==CHIP_TSUMU         
                  #ifndef FPGA
                  #if (FRAME_BFF_SEL == FRAME_BUFFER)
                      BYTE ucDDR3InitCount;
                      BOOL bDDR3InitState = FALSE;
                  #endif
                  #endif
                      // PRINT_MSG("Enter msPM_PowerUpMacro");
                      //ADC
                      msWriteByte(REG_2508, 0x00);    //Power down ADC_vref /vref/adc_rgb/phase_digitizer/adc_pll/dpl_bg
                      msWriteByteMask(REG_2509, 0x00, ~BIT7);
                      msWriteByteMask(REG_2560, 0x00, BIT0);
                      msWriteByteMask(REG_03E9, 0x00, BIT7);
                      //DVI
                      msWriteByteMask(REG_29C0, 0x00, ~BIT3);
                      msWriteByteMask(REG_29C1, 0x00, ~(BIT5|BIT6));
                      msWriteByteMask(REG_29D2, 0x00, ~BIT3);
                      msWriteByteMask(REG_29D3, 0x00, ~(BIT4|BIT5|BIT6));
                      //MOD ATOP
              
                      msWriteByte(REG_3200, 0x00); // sub bank 0
                      msWriteByteMask(REG_3265, 0x00, BIT2|BIT6);
                      msWriteByteMask(REG_3250, 0x00, 0x30);
                      //DPRX
                  #if ENABLE_DP_INPUT
                      msWriteByteMask(REG_1FE3, BIT7, BIT7);//Temp for DP wake up issue
                      msWriteByte(REG_356C, 0x00);
                      msWrite2Byte(REG_37E8, 0x0000);
                      msWrite2Byte(REG_37EA, 0x0000);
                      msWriteByte(REG_356D, 0x00);
                      msWriteByteMask( REG_35E0, BIT2, BIT2 );
                      msWriteByteMask( REG_35E1, BIT2 | BIT3 | BIT6, BIT2 | BIT3 | BIT6 ); //if turn off, DP can't wake 
             -up
                      msWriteByte( REG_3580, 0x00 );
                      msWriteByteMask( REG_35FA, 0xC0, 0xC0 );
                      //dprx Audio AUPLL
                      msWriteByteMask(REG_35B3, 0x00, BIT0);
                      //dprx Video AUPLL 
                      msWriteByteMask(REG_35D1, 0x00, BIT0);
C51 COMPILER V9.01   MS_PM                                                                 03/09/2023 15:39:11 PAGE 25  

                  #endif
                      //Audio
                      msWrite2Byte(REG_2C60, 0x2F2F);
                      msWrite2Byte(REG_2C62, 0x2F06);
                      msWrite2Byte(REG_2C64, 0x0000);
                      msWrite2Byte(REG_2C66, 0x0000);
                      msWrite2Byte(REG_2C68, ((0x0A<<8)|(msReadByte(REG_2C68)&0x0B)));
                      msWrite2Byte(REG_2C6A, 0x6406);
                      msWrite2Byte(REG_2C6C, 0x0400);
                      //HDMI PLL
                      msWriteByteMask(REG_05B9, 0x00, BIT0);
                      //AU PLL
                      msWriteByteMask(REG_05F0, 0x00, BIT3);
                      //MOD LPLL
                      msWriteByteMask(REG_3881, 0x00, BIT0);
                      //SCALAR LPLL
                      msWriteByteMask(REG_38A3, 0x00, BIT7);
                      //MPLL
                      //msWriteByteMask(REG_1ED1, 0x00, BIT0);
                      msWriteByteMask(REG_1EDC, 0x00, BIT4|BIT5);
                      //DDR ATOP
                      msWriteByteMask(REG_1154, 0x00, BIT4);
                      msWriteByteMask(REG_1160, 0x00, BIT1);
                      msWriteByteMask(REG_1133, 0x00, BIT7);
                      //SDR
                      msWriteByteMask(REG_1205, BIT2, BIT2);
                      //ClK Gen
                      msWriteByteMask(REG_1E24, 0x00, BIT0);
                      msWriteByteMask(REG_1E25, 0x00, BIT2);
                      msWriteByteMask(REG_1E26, 0x00, BIT4|BIT0);
                      msWriteByteMask(REG_1E27, 0x00, BIT4);
                      msWriteByteMask(REG_1E28, 0x00, BIT0);
                      msWriteByteMask(REG_1E29, 0x00, BIT0);
                      msWriteByteMask(REG_1E2A, 0x00, BIT0);
                      msWriteByteMask(REG_1E2B, 0x00, BIT0);
                      msWriteByteMask(REG_1E2C, 0x00, BIT0);
                      msWriteByteMask(REG_1E35, 0x00, BIT0);
                      msWriteByteMask(REG_1E36, 0x00, BIT0);
                      msWriteByteMask(REG_1E37, 0x00, BIT0);
                      msWriteByteMask(REG_1E3B, 0x00, BIT6);
                      msWriteByteMask(REG_1E3E, 0x00, BIT0);
                      msWriteByteMask(REG_1E3F, 0x00, BIT0);
                      msWriteByteMask(REG_1E40, 0x00, BIT4|BIT0);
                      msWriteByteMask(REG_1E41, 0x00, BIT0);
                      msWriteByteMask(REG_1E44, 0x00, BIT0);
                      msWriteByteMask(REG_1E45, 0x00, BIT6);
                      msWriteByteMask(REG_1E46, 0x00, BIT4|BIT0);
                      msWriteByteMask(REG_1E47, 0x00, BIT4|BIT0);
              
                      //110316 The image has garbage issue after Leave PM mode.
              
                      msWrite2Byte(REG_3220, 0x5555); // TTL
                      msWrite2Byte(REG_3222, 0x5555);
                      msWrite2Byte(REG_3224, 0x5555);
              
                  #ifndef FPGA
                      #if (FRAME_BFF_SEL == FRAME_BUFFER)
              
                              msWriteByte( REG_1133, 0x00 );
                          #if !PANEL_3D_PASSIVE_4M
                                  msWriteByte( REG_1205, 0x00 );
                          #endif
C51 COMPILER V9.01   MS_PM                                                                 03/09/2023 15:39:11 PAGE 26  

                              msWriteByte( REG_1100, 0x01 );  //miu_0_atop  start
                              msWriteByte( REG_1108, 0x3F );
                              msWriteByte( REG_110E, 0xE5 );
                              msWriteByte( REG_1154, 0x00 );
                              msWriteByte( REG_1160, 0x70 );
                              msWriteByte( REG_110E, 0xA5 );  // 2/2 reg_en_mask clr bit6 eg_dqsm_rst_sel
              
                              //Initial MIU
                              Delay1ms( 1 );                          //delay 1ms
                              msWriteByteMask( REG_121E, 0x01, 0x01 );
                              msWriteByteMask( REG_121E, 0x00, 0x01 );
                              Delay1ms( 1 );                          //delay 200us
                              msWriteByteMask( REG_1200, 0x10, 0x10 );
                              Delay1ms( 1 );                          //delay 500us
                              msWriteByteMask( REG_1200, 0x08, 0x08 );
                              Delay1ms( 1 );                          //delay 500us
                              msWriteByteMask( REG_1200, 0x04, 0x04 );
                              Delay1ms( 1 );                          //delay 500us
                              msWriteByteMask( REG_1200, 0x02, 0x02 );
                              Delay1ms( 1 );                          //delay 1us
                              msWriteByteMask( REG_1200, 0x01, 0x01 );
              
                              //BIST
                              ucDDR3InitCount = 1;
                              while(!bDDR3InitState)
                              {
                                  if(msMemoryBist())
                                      bDDR3InitState=TRUE;
              
                                  if(ucDDR3InitCount++>=30)
                                  if(!bDDR3InitState)
                                      bDDR3InitState = TRUE;
                              }
                      #endif
                  #endif
              #elif (CHIP_ID == CHIP_TSUMJ || CHIP_ID == CHIP_TSUM9||CHIP_ID == CHIP_TSUMF)  //follow power down list to
             - update it
                              //>>>ADC---------------------------------------------------------------------------------
                              msWriteByteMask(REG_2509, 0x00  , 0xFF);
                              msWriteByteMask(REG_2508, 0x00  , 0xFF);
                              msWriteByteMask(REG_2560, 0x00  , BIT0);
                              msWriteByteMask(REG_01E9, 0x00  , BIT7);
                              msWriteByteMask(REG_250C, 0x00 , 0xFF);
                          msWriteByteMask(REG_250D, 0x00      , 0xFF);
                              msWrite2ByteMask(REG_25F0, 0x0002               , 0xFFFF);
                              msWrite2ByteMask(REG_25F2, 0x00C8               , 0xFFFF);
                              msWriteByteMask(REG_25F4, 0x04  , 0x0E);
                              //<<<ADC---------------------------------------------------------------------------------
              /*              //>>>DVI ATOP---------------------------------------------------------------------------------
                              msWriteByteMask(REG_01C2,BIT5,BIT6|BIT5);
                              msWriteByteMask(REG_01C3,0x00 ,BIT7|BIT5|BIT4);
                              msWriteByteMask(REG_01CD,0x00 ,BIT0);
                              msWriteByteMask(REG_01CC,0x00 ,BIT2|BIT1|BIT0);
                              msWriteByteMask(REG_01CE,0x00 ,BIT3|BIT2|BIT1|BIT0);      //Diff
                              msWriteByteMask(REG_17BE, 0x00 ,BIT0);
                              msWriteByteMask(REG_17C0, 0x00 ,BIT7|BIT5|BIT2|BIT1|BIT0);        //Diff
                              msWriteByteMask(REG_17C1, 0x00 ,BIT5|BIT4|BIT3|BIT2|BIT1|BIT0);
              */              //<<<DVI---------------------------------------------------------------------------------
                              //>>>MOD ATOP---------------------------------------------------------------------------------
                      //msWriteByteMask(REG_30F0, 0x00, BIT0);
                      //msWriteByteMask(REG_30EE, BIT2|BIT1|BIT0, BIT2|BIT1|BIT0);
                      //msWriteByteMask(REG_30DA, 0xFF, 0xFF);
C51 COMPILER V9.01   MS_PM                                                                 03/09/2023 15:39:11 PAGE 27  

                      //msWrite2ByteMask(REG_308C, 0xFFFF, 0xFFFF);
                      //msWriteByteMask(REG_308E, 0xFF, 0x1F);
                              msWriteByteMask(REG_308A,  0x00, BIT5|BIT4);
                              //<<<MOD ATOP---------------------------------------------------------------------------------
                              //>>>KeyPad SAR---------------------------------------------------------------------------------
                              msWriteByteMask(REG_3A60,0x00, BIT6);           //[6]SAR_PD
                              //<<<KeyPad SAR---------------------------------------------------------------------------------
                              //>>>MPLL_PD---------------------------------------------------------------------------------
                              //msWriteByteMask(REG_1ED1,BIT0, BIT0);                         // [4]: MPLL power DOWN   //move to msPM_SetPMClock()
                              msWriteByteMask(REG_1EDC, 0x00, BIT5|BIT4);                             //[5][4]:Power Down MPLL 216/432
                              //<<<MPLL_PD---------------------------------------------------------------------------------
                              //>>>Clock Gen---------------------------------------------------------------------------------
                              msWriteByteMask(REG_1E24,0x00, BIT0);
                              msWriteByteMask(REG_1E3E,0x00, BIT0);
                              msWriteByteMask(REG_1E35,0x00, BIT0);
                              msWriteByteMask(REG_1E37,0x00, BIT2|BIT0);
                              msWriteByteMask(REG_1E47,0x00, BIT0);
                              msWriteByteMask(REG_1E25,0x00, BIT2);
                              msWriteByteMask(REG_1E28,0x00, BIT0);
                              msWriteByteMask(REG_1E46,0x00, BIT0);
                              msWriteByteMask(REG_1E24,0x00, BIT4);
              #if (CHIP_ID == CHIP_TSUMJ)
                      msWriteByteMask(REG_1E40,0x00, BIT4|BIT0); // LED
                              msWriteByteMask(REG_1E2A,0x00, BIT0);
              #endif
                      //#endif
              #if (CHIP_ID == CHIP_TSUM9||CHIP_ID == CHIP_TSUMF)
              #if ENABLE_DP_INPUT
                      DPRxOutputEnable( TRUE );
              #endif
                      msWriteByteMask(REG_1ECA, 0x00, 0x1F);  // osc432m power up
              #endif
                              //<<<Clock Gen---------------------------------------------------------------------------------
                              MPLL_POWER_UP(_ENABLE);
                              mcuSetSystemSpeed(SPEED_NORMAL_MODE);
                              mStar_Init();  // remove it to speed up powering on time????
              #else//endMST8556
1616   1             
1617   1              //ADC
1618   1              msWriteByte(REG_2508, 0x00);    //Power down ADC_vref /vref/adc_rgb/phase_digitizer/adc_pll/dpl_bg
1619   1              msWriteByteMask(REG_2509, 0x00, ~BIT7);
1620   1              msWriteByteMask(REG_2560, 0x00, BIT0);
1621   1              msWriteByteMask(REG_03E9, 0x00, BIT7);
1622   1              //DVI
1623   1              msWriteByteMask(REG_29C0, 0x00, ~BIT3);
1624   1              msWriteByteMask(REG_29C1, 0x00, ~(BIT5|BIT6));
1625   1              msWriteByteMask(REG_29FE, 0x00, ~(BIT7|BIT6));      //111011 Rick add power up condition - C_FOS_0
             -18
1626   1      #if CHIP_ID == CHIP_TSUMV && !(USE_MOD_HW_CAL)
                      msWriteByteMask(REG_306C, BIT6, BIT6);
              #endif
1629   1              msWriteByteMask(REG_306B, 0, BIT2);  //Disable Power Down MOD IGEN
1630   1      
1631   1              //ClK Gen       
1632   1              msWriteByteMask(REG_1E24,0x00, BIT0);//[0]clk_osd_gate_l
1633   1              msWriteByteMask(REG_1E35,0x00, BIT0);//[0]clk_fclk_gate
1634   1      #if CHIP_ID!=CHIP_TSUMV
1635   1              msWriteByteMask(REG_1E36,0x00, BIT0);//[0]clk_mod_gate
1636   1      #endif
1637   1              msWriteByteMask(REG_1E37,0x00, BIT2|BIT0);//[0]clk_odclk1_I_gate //130604 Modify
1638   1      #if CHIP_ID!=CHIP_TSUMV
1639   1              msWriteByteMask(REG_1E3B,0x00, BIT6);//[7]clk_miu_rec_gate
C51 COMPILER V9.01   MS_PM                                                                 03/09/2023 15:39:11 PAGE 28  

1640   1      #endif
1641   1              msWriteByteMask(REG_1E3E,0x00, BIT0);//[0]clk_idclk_i_gate
1642   1              msWriteByteMask(REG_1E3F,0x00, BIT0);//[0]clk_hspclk_gate
1643   1      #if CHIP_ID!=CHIP_TSUMV
1644   1              msWriteByteMask(REG_1E41,0x00, BIT0);//[0]clk_led_gate
1645   1              msWriteByteMask(REG_1E45,0x00, BIT6);//[6]clk_patgen_bias_gate
1646   1      #endif
1647   1              msWriteByteMask(REG_1E47,0x00, BIT0);//[0]clk_sysclk_ip_gate
1648   1      
1649   1              
1650   1      #if CHIP_ID == CHIP_TSUMY
                      msWriteByteMask(REG_1E40, 0x00  , BIT0);                //LED clock gating
                      msWriteByteMask(REG_0A60, 0x00  , BIT6);                //LED SAR power On
                      //msWriteWord(REG_0A81, 0xFFFF);                    //Dimming PWM enable,  select CH?
                      //msWriteByteMask(REG_0A87, BIT7, BIT7);            //Boost clock  enable
                      //msWriteByteMask(REG_0A95, BIT7, BIT7);            //Boost PWM  enable
                      msWriteByteMask(REG_0AE1, BIT7|BIT6,BIT7|BIT6);     //Bias current and External resistor enable
                      msWriteByteMask(REG_0A65, BIT6, BIT6);         //Over temperature protectioni enable
              #endif
1659   1      
1660   1      #if ( CHIP_ID == CHIP_TSUMB ) // 111216 coding, trunk   
                  msWriteByteMask(REG_1E25,0x00, BIT2);               //[2]ckg_mclk_gate
                  msWriteByteMask(REG_1E28,0x00, BIT4|BIT0);   //[0]CLK_MEMPLL_gate [4]clk_led216_gate
              #endif
1664   1      
1665   1          #if CHIP_ID>=CHIP_TSUMC // nick add for C/D CHip PM Close too much  //130321
1666   1              MPLL_POWER_UP(_ENABLE);
1667   1              mcuSetSystemSpeed(SPEED_NORMAL_MODE);
1668   1              mStar_Init();
1669   1          #endif
1670   1      
1671   1      #endif        
1672   1      
1673   1          #if ((FRAME_BFF_SEL == FRAME_BUFFER) || (ENABLE_RTE))&&(CHIP_ID != CHIP_TSUMF)
                  {
                      extern void msInitMemory( void );
              #if CHIP_ID == CHIP_TSUMB
                      msWriteByteMask( REG_1207, 0, BIT4 );   // ¥´¶}°ÊºA¬Ù¹q¼Ò¦¡
              #endif
                      msInitMemory();
                  }
              #endif
1682   1      
1683   1          DDC2Bi_Init();
1684   1      msPM_InterruptEnable(TRUE);
1685   1      
1686   1      }
1687          //**************************************************************************
1688          //  [Function Name]:
1689          //                  msPM_MCCSReset()
1690          //  [Description]
1691          //                  msPM_MCCSReset
1692          //  [Arguments]:
1693          //
1694          //  [Return]:
1695          //
1696          //**************************************************************************
1697          void msPM_MCCSReset(void)
1698          {
1699   1      #if (CHIP_ID == CHIP_TSUMC || CHIP_ID == CHIP_TSUMD || CHIP_ID == CHIP_TSUM9||CHIP_ID == CHIP_TSUMF)
1700   1          msWriteByte(REG_3EC0, 0xFF); // clear status of A0, D0
1701   1          msWriteByte(REG_3EC0, 0x00);
C51 COMPILER V9.01   MS_PM                                                                 03/09/2023 15:39:11 PAGE 29  

1702   1          msWriteByte(REG_3EEE, 0xFF); // clear status of D1, D2
1703   1          msWriteByte(REG_3EEE, 0x00);
1704   1      #else
                  msWriteByteMask(REG_0381,BIT7,BIT7);  //PM wakeup status clear.
                  msWriteByteMask( REG_3EC1, (BIT5|BIT1|BIT0), (BIT5|BIT1|BIT0) );    //Clear DDC2BI D6 Comamnd 04,05  f
             -lag
              #endif
1708   1      }
1709          
1710          #if CHIP_ID <=CHIP_TSUM2
              
              //**************************************************************************
              //  [Function Name]:
              //                  msPM_StartRCOSCCal()
              //  [Description]
              //                  msPM_StartRCOSCCal
              //  [Arguments]:
              //
              //  [Return]:
              //  RCOSC = XTAL * Counter / 512 => Counter = RCOSC *512/XTAL = 143 =>8Fh
              //**************************************************************************
              Bool msPM_StartRCOSCCal(void)
              {
              #ifndef _RCOSC_MAX
                  BYTE i;
                  WORD ucCounter;
                  int iDeltaOld = 100;
                  int iDeltaNew = 0;
                  BYTE ucSetOld = 0x08;
              #endif
                  BYTE ucTemp;
                  BYTE ucSetNow = 0x08;
              
                  ucTemp = msReadByte(REG_PM_82)&0x07;  // deglitch time setting
              
              #ifdef _RCOSC_MAX
                  ucSetNow = 0xF;
                  msWriteByte(REG_PM_82, (ucSetNow<<4)|ucTemp);
              #else
                  for( i=0; i< 16; i++)
                  {
                      msWriteByte(REG_PM_82, (ucSetNow<<4)|ucTemp);
                      msWriteByte(REG_3A80, 0x80);//osc soft reset
                      msWriteByte(REG_3A80, 0x03);//RCOSC calculate & counter one time mode enable
                      while( !( msReadByte(REG_3A83) & _BIT4 ) ) // one time counter flag
                      {
                      }
                      ucCounter = msRead2Byte(REG_3A82)&0x03FF; // one time counter report
              //        PM_printData("\r\n***ucCounter(%x)", ucCounter);
                      iDeltaNew = RCOSC_TARGET - (int)ucCounter;
              //        PM_printData("\r\n***iDeltaNew(%d)", iDeltaNew);
                      if(abs(iDeltaNew) < abs(iDeltaOld))
                      {
                          ucSetOld = ucSetNow;
                          if(ucCounter > RCOSC_TARGET)
                          {
                              ucSetNow--;
                          }
                          else
                          {
                              ucSetNow++;
                          }
C51 COMPILER V9.01   MS_PM                                                                 03/09/2023 15:39:11 PAGE 30  

                          iDeltaOld = iDeltaNew;
              //          PM_printData("\r\n***RCOSC Set_new(%x)", ucSetNow);
                      }
                      else
                      {
                          msWriteByte(REG_PM_82, (ucSetOld<<4)|ucTemp);
              
                          PM_printData("\r\n***RCOSC Set_old(%x)", ucSetOld);
                          msWriteByte(REG_3A80, 0x00);
                          return TRUE;
                      }
                  }
              #endif
              
                  return FALSE;
              }
              
              #endif
1781          
1782          #if( PM_SUPPORT_AC2DC )
              //**************************************************************************
              //  [Function Name]:
              //                  msPM_EnableAC2DC()
              //  [Description]
              //                  msPM_EnableAC2DC
              //  [Arguments]:
              //
              //  [Return]:
              //
              //**************************************************************************
              void
              msPM_EnableAC2DC(Bool bEnable)
              {
                  if(bEnable)   /*Turn On PM*/
                  {
                      msWriteByteMask(REG_PM_A8, 0x00, 0xF0);       /*AC2DC controler clock bypass*/
                      msWriteByte(REG_PM_C0, AC2DC_MODE);     //AC2DC controler enable
                      msWriteByte(REG_PM_C2, OFF_PERIOD);     //AC2DC Off period
                      msWriteByte(REG_PM_C6, 0x88);       //AC detect voltage
                      msWriteByte(REG_PM_C4, AC2DC_PAD);          //AC2DC pad function enable(GPIO2)
                  }
                  else /*Turn Off PM*/
                  {
                      msWriteByteMask(REG_PM_A8, 0xB0, 0xF0);       /*AC2DC controler clock bypass*/
                      msWriteByte(REG_PM_C4, 0x00);           //AC2DC pad function disable(GPIO2)
                      msWriteByte(REG_PM_C0, OFF_MODE);       //AC2DC controler disable
                      msWriteByte(REG_PM_C2, 0x00);       /*Off period*/
                      msWriteByte(REG_PM_C6, 0x00);
                  }
              }
              #endif  // end of #if( PM_SUPPORT_AC2DC )
1814          
1815          
1816          //**************************************************************************
1817          //  [Function Name]:
1818          //                  msPM_GetPMStatus()
1819          //  [Description]
1820          //                  msPM_GetPMStatus
1821          //  [Arguments]:
1822          //
1823          //  [Return]:
1824          //
C51 COMPILER V9.01   MS_PM                                                                 03/09/2023 15:39:11 PAGE 31  

1825          //**************************************************************************
1826          Bool
1827          msPM_GetPMStatus(void)
1828          {
1829   1          BOOL bResault = FALSE;
1830   1         
1831   1          BYTE ucStatus_85;
1832   1          BYTE ucStatus_86;
1833   1          volatile WORD ucStatus_GPIO;
1834   1              
1835   1          ucWakeupStatus = ePMSTS_NON;
1836   1      
1837   1          ucStatus_85   = msReadByte(REG_EVENT1);
1838   1          ucStatus_86   = msReadByte(REG_EVENT2);
1839   1          ucStatus_GPIO = msRead2Byte( REG_PM_64 );
1840   1      
1841   1              #if  0//ENABLE_DEBUG
                      printData("ucStatus_85==%d", ucStatus_85);
                      printData("ucStatus_86===%d",ucStatus_86);
                      printData("ucStatus_GPIO==%d", ucStatus_GPIO);
                      #endif
1846   1      
1847   1      #if PM_POWERkEY_GETVALUE
                  if(PowerKey==0)
                  {
                      KeypadButton = BTN_Nothing;                //110914 Rick add for enable OSDLock function while PM 
             -On - A023
                      Key_ScanKeypad();
                      ucWakeupStatus =ePMSTS_POWERGPIO_ACT;
                      bResault = TRUE;
                  }
                  else
              #endif
1857   1          #if PM_CABLE_DETECT_USE_SAR
                  if((abs(sPMInfo.bCABLE_SAR_VALUE-CABLE_DET_SAR)>5)&&(PowerOnFlag))
                      {               
                            ucWakeupStatus =ePMSTS_CABLESAR_ACT;           
                              bResault = TRUE;
                  }   
                  else
                  #endif
1865   1      
1866   1      #if (ModelName!=LEYI_JRY_LQ570S_BV1)    
1867   1         if(ucStatus_85 & (HSYNC_DET_0|VSYNC_DET_0|HV_DET_0))// SOG_DET  OPEN  20170308  if(ucStatus_85 & (HSYNC
             -_DET_0|VSYNC_DET_0|SOG_DET_0|HV_DET_0))
1868   1          {
1869   2              ucWakeupStatus = ePMSTS_VGA_ACT;
1870   2              SrcInputType = Input_ANALOG;
1871   2              bResault = TRUE;
1872   2          }
1873   1       #else
              if (0);
              else
               #endif
1877   1          #if  0
              #if CHIP_ID==CHIP_TSUMU
                  else if( ucStatus_GPIO & ( PMGPIO00_INT \
                                            |PMGPIO01_INT \
                                            |PMGPIO02_INT \
                                            |PMGPIO03_INT \
                                            |PMGPIO04_INT \
                                            |PMGPIO05_INT \
C51 COMPILER V9.01   MS_PM                                                                 03/09/2023 15:39:11 PAGE 32  

                                            |PMGPIO06_INT \
                                            |PMGPIO07_INT \
                                            |PMGPIO24_INT \
                                            |PMGPIO25_INT \
                                            |PMGPIO26_INT \
                                            |PMGPIO27_INT ) )
              #else
                      else if( ucStatus_GPIO & (PMGPIO04_INT\                 
                                                      |GPIO22_INT\                            
                                                      | PMGPIO02_INT \                        
                                                      |PMGPIO06_INT\                  
                                                      |GPIO00_INT\                            
                                                      |GPIO11_INT\                            
                                                      |PMGPIO03_INT ) )
              
              #endif
              #endif
1902   1           if( ucStatus_GPIO&EN_GPIO_DET_MASK)
1903   1          {
1904   2            //  ucWakeupStatus = ePMSTS_GPIO_ACT;
1905   2              ucWakeupStatus =ePMSTS_GPIO_POWER_KEY_ACT;  //20121003
1906   2              bResault = TRUE;
1907   2          }
1908   1          else
1909   1          {   
1910   2               
1911   2              if( ucStatus_86 & CEC_WAKEUP )
1912   2              {
1913   3                  ucWakeupStatus = ePMSTS_CEC_ACT;
1914   3                  bResault = TRUE;
1915   3              }
1916   2              else if( ucStatus_86 & D2B_WAKEUP )
1917   2              {
1918   3      //#define D2B_PWR_CMD_WKUP_STATUS()   (msReadByte( REG_3EC1 ))
1919   3                #if CHIP_ID == CHIP_TSUMV
                                volatile BYTE VGA_mccsWakeUpStatus = msReadByte(REG_3EC4);
                                volatile BYTE DVI_mccsWakeUpStatus = msReadByte(REG_3EC5);
                                if((VGA_mccsWakeUpStatus == 0x01) || (DVI_mccsWakeUpStatus == 0x01))
                                        ucWakeupStatus = ePMSTS_MCCS01_ACT;
                                else if((VGA_mccsWakeUpStatus == 0x04) || (DVI_mccsWakeUpStatus == 0x04))
                                        ucWakeupStatus = ePMSTS_MCCS04_ACT;
                                else if((VGA_mccsWakeUpStatus == 0x05) || (DVI_mccsWakeUpStatus == 0x05))
                                        ucWakeupStatus = ePMSTS_MCCS05_ACT;
              
                        #elif CHIP_ID == CHIP_TSUMC||CHIP_ID == CHIP_TSUMD ||CHIP_ID == CHIP_TSUM9||CHIP_ID == CHIP_TSUM
             -F//20130604 nick add
1930   3                  volatile BYTE mccsWakeUpStatus;
1931   3                  if(msReadByte(REG_3EC2)&BIT2) // A0
1932   3                      mccsWakeUpStatus = msReadByte( REG_3EC4 );
1933   3                  else if(msReadByte(REG_3EC2)&BIT3) // D0
1934   3                      mccsWakeUpStatus = msReadByte( REG_3EC5 );
1935   3                  else if(msReadByte(REG_3EF0)&BIT2) // D1
1936   3                      mccsWakeUpStatus = msReadByte( REG_3EF2 );
1937   3                  else if(msReadByte(REG_3EF0)&BIT3) // D2
1938   3                      mccsWakeUpStatus = msReadByte( REG_3EF3 );
1939   3      
1940   3                  if( mccsWakeUpStatus == 0x05 )
1941   3                      ucWakeupStatus = ePMSTS_MCCS05_ACT;
1942   3                  else if( mccsWakeUpStatus == 0x04 )
1943   3                      ucWakeupStatus = ePMSTS_MCCS04_ACT;
1944   3                  else
1945   3                      ucWakeupStatus = ePMSTS_MCCS01_ACT;
C51 COMPILER V9.01   MS_PM                                                                 03/09/2023 15:39:11 PAGE 33  

1946   3                #else
                          volatile BYTE mccsWakeUpStatus = msReadByte( REG_3EC1 );
                          if( mccsWakeUpStatus & BIT7 )
                              ucWakeupStatus = ePMSTS_MCCS05_ACT;
                          else if( mccsWakeUpStatus & BIT6 )
                              ucWakeupStatus = ePMSTS_MCCS04_ACT;
                          else 
                                ucWakeupStatus = ePMSTS_MCCS01_ACT;           
                        #endif
1955   3                  bResault = TRUE;
1956   3              }
1957   2      
1958   2              else if( ucStatus_86 & SAR_IN_DET )
1959   2              {
1960   3                    ucWakeupStatus = ePMSTS_SAR_ACT;
1961   3                     bResault = TRUE; 
1962   3             }        
1963   2              //================================================================================
1964   2              //  Move DP wake up checking first before DVI, because DVI clock detected bit would report 1 when 
             -DP plug in.
1965   2              //================================================================================
1966   2          #if ((CHIP_ID == CHIP_TSUMC)||(CHIP_ID == CHIP_TSUMD))
1967   2          #if( PM_SUPPORT_WAKEUP_DP &&ENABLE_DP_INPUT)
                              #if CInput_Displayport_C2 != CInput_Nothing     //130604 xiandi
                      else if(((DP_GetSquelchPortB(1))&&((msReadByte( REG_06E3)&0x03)==0x01)) && sPMInfo.sPMConfig.bDP_ena
             -ble )
                      {      // Normal Trining Wake up
                                      ucWakeupStatus = ePMSTS_DP_ACT;
                                      SrcInputType = Input_Displayport;
                                      bResault = TRUE;
                      }
                      else if((DP_GetSquelchPortB(0x1FFF))&& sPMInfo.sPMConfig.bDP_enable)
                      {      // fast Trining Wake up
                                      ucWakeupStatus = ePMSTS_DP_ACT;
                                      SrcInputType = Input_Displayport;
                                      bResault = TRUE;
                      }
                              #endif
                              #if CInput_Displayport_C3 != CInput_Nothing     //130604 xiandi
                              else if(((DP_GetSquelchPortC(1))&&((msReadByte( REG_07E3)&0x03)==0x01)) && sPMInfo.sPMConfig.bDP_enable 
             -)
                              {          // Normal Trining Wake up
                                      ucWakeupStatus = ePMSTS_DP_ACT;
                                      SrcInputType = Input_Displayport3;
                                      bResault = TRUE;
                              }
                      else if((DP_GetSquelchPortC(0x1FFF))&& sPMInfo.sPMConfig.bDP_enable)
                      {
                                      ucWakeupStatus = ePMSTS_DP_ACT;
                                      SrcInputType = Input_Displayport3;
                                      bResault = TRUE;
                              }
                              #endif
              
                 #endif
1998   2          #endif
1999   2      
2000   2            #if (CHIP_ID == CHIP_TSUM9||CHIP_ID == CHIP_TSUMF)
                    #if( PM_SUPPORT_WAKEUP_DP &&ENABLE_DP_INPUT)
                    else if(
                    //#if DISABLE_AUTO_SWITCH
                    //            sPMInfo.sPMConfig.bDP_enable && (((FIXED_PORT == Input_Displayport)&&(DP_GetSquelchPor
C51 COMPILER V9.01   MS_PM                                                                 03/09/2023 15:39:11 PAGE 34  

             -tB(1))&&((msReadByte( REG_06E3)&0x03)==0x02)))
                    //#else
                             sPMInfo.sPMConfig.bDP_enable && (((DP_GetSquelchPortB(1))&&((msReadByte( REG_06E3)&0x03)==0
             -x02)))
                    //#endif
                            )
                    {      // Normal Trining Wake up
                                ucWakeupStatus = ePMSTS_DP_ACT;
                                SrcInputType = Input_Displayport;
                               bResault = TRUE;
                               PM_printData("ePMSTS_DP_ACT NormalTraining:%d", ePMSTS_DP_ACT);
                    }
                    
                    else if(
                    #if DISABLE_AUTO_SWITCH
                                (FIXED_PORT == Input_Displayport) &&
                    #endif
                            ((DP_GetSquelchPortB(0x1FFF))&& sPMInfo.sPMConfig.bDP_enable))
                    {      // fast Trining Wake up
                        ucWakeupStatus = ePMSTS_DP_ACT;
                        SrcInputType = Input_Displayport;
                        bResault = TRUE;
                        PM_printData("ePMSTS_DP_ACT FastTraining DP:%d", ePMSTS_DP_ACT);
                    }
                    
                    #endif
                    #endif
2030   2      
2031   2      
2032   2      #if( PM_SUPPORT_WAKEUP_DVI )
2033   2              #if (ENABLE_HDMI && (HDMI_PORT==TMDS_PORT_B)&&(DVI_PORT==TMDS_PORT_C))          //130107_25 Henry
                              else if(((UserPrefInputSelectType==INPUT_PRIORITY_AUTO)||(UserPrefInputSelectType==INPUT_PRIORITY
             -_HDMI))&&( ucStatus_86 & DVI_CLK_DET_0 ))
                              {
                                      ucWakeupStatus = ePMSTS_DVI_0_ACT;       
                                      //SrcInputType = Input_Digital; // 120117 coding reserved
                                      bResault = TRUE;
                                              
                              }
                              else if(((UserPrefInputSelectType==INPUT_PRIORITY_AUTO)||(UserPrefInputSelectType==INPUT_PRIORITY
             -_DVI))&&( ucStatus_86 & DVI_CLK_DET_1 ))
                              {
                                  ucWakeupStatus = ePMSTS_DVI_1_ACT;
                                  //SrcInputType = Input_Digital2; // 120117 coding reserved
                                  bResault = TRUE;
                              }
                      #elif       0
              
                      #else
2050   2                      else if( ucStatus_86 & DVI_CLK_DET_0 )
2051   2                      {
2052   3                              ucWakeupStatus = ePMSTS_DVI_0_ACT;       
2053   3                              //SrcInputType = Input_Digital; // 120117 coding reserved
2054   3                              bResault = TRUE;
2055   3                                      
2056   3                      }
2057   2                      else if( ucStatus_86 & DVI_CLK_DET_1 )
2058   2                      {
2059   3                          ucWakeupStatus = ePMSTS_DVI_1_ACT;
2060   3                          //SrcInputType = Input_Digital2; // 120117 coding reserved
2061   3                          bResault = TRUE;
2062   3                      }
C51 COMPILER V9.01   MS_PM                                                                 03/09/2023 15:39:11 PAGE 35  

2063   2              #endif
2064   2      #endif  // end of #if( PM_SUPPORT_WAKEUP_DVI )
2065   2      #if CHIP_ID == CHIP_TSUMU
              #if( PM_SUPPORT_WAKEUP_DP &&ENABLE_DP_INPUT)
                     else if( (g_bDPAUXVALID && sPMInfo.sPMConfig.bDP_enable ))//||(!(msRegs[REG_1FA5]&_BIT3)))
                      {
                          ucWakeupStatus = ePMSTS_DP_ACT;
                          SrcInputType = Input_Displayport;
                          bResault = TRUE;
                      }
                       if((!g_bDPAUXVALID) && sPMInfo.sPMConfig.bDP_enable && (msReadByte( REG_1FE0)&BIT4))
                      {
                              msWriteByteMask(REG_1FE0,0,BIT4);
                      }
              #endif
                       
              #endif
2080   2      
2081   2      #if CHIP_ID == CHIP_TSUMC || CHIP_ID == CHIP_TSUMD || CHIP_ID == CHIP_TSUM9||CHIP_ID == CHIP_TSUMF// 20130
             -604 nick add
2082   2      #if ENABLE_MHL
                      if((sPMInfo.ucPMMode != ePM_POWEROFF))  // 130801 william
                      {
                          BYTE tempport;
                          if(mapi_mhl_WakeupDetect(TRUE, &tempport))// 20130604 nick add
                          {
                              //if(tempport == Input_HDMI || tempport == Input_HDMI2)
                              {
                                  SrcInputType = tempport;
                                  ucWakeupStatus = ePMSTS_MHL_ACT;
                                  bResault = TRUE;
                                      #if ENABLE_MHL //&& (CHIP_ID == CHIP_TSUM2)//130703 nick
                                      MHLExtenCountFlag = 0;
                                      #endif
                                  PM_printData("ePMSTS_MHL_ACT PowerSaving:%d", ePMSTS_MHL_ACT);
                                  PM_printData("MHL wakeup port:%d", SrcInputType);
                              }
                          }
                      }
                      else
                      {
                          mapi_mhl_ChargePortDetect();
                      }
              #endif
2106   2      #endif
2107   2          }
2108   1      
2109   1          return  bResault;
2110   1      }
2111          
2112          
2113          //**************************************************************************
2114          //  [Function Name]:
2115          //                  msPM_SetPMClock()
2116          //  [Description]
2117          //                  msPM_SetPMClock
2118          //  [Arguments]:
2119          //
2120          //  [Return]:
2121          //
2122          //**************************************************************************
2123          void
C51 COMPILER V9.01   MS_PM                                                                 03/09/2023 15:39:11 PAGE 36  

2124          msPM_SetPMClock(BYTE clk_sel)
2125          #if 1
2126          {
2127   1          if (clk_sel == RCOSC)
2128   1          {
2129   2              //PM_printMsg(" \r\n***PM Clock =>RCOSC ");
2130   2      #if (CHIP_ID == CHIP_TSUMC||CHIP_ID == CHIP_TSUMD||CHIP_ID == CHIP_TSUM9||CHIP_ID == CHIP_TSUMF)//130604 M
             -odify
2131   2              mcuSetSystemSpeed(SPEED_12MHZ_MODE);
2132   2      #else
                      mcuSetSystemSpeed(SPEED_4MHZ_MODE);
              #endif
2135   2              msWriteByteMask(REG_PM_BC, _BIT6, _BIT6);            // mcu clk Live select ROSC
2136   2      #if (CHIP_ID != CHIP_TSUMC && CHIP_ID!=CHIP_TSUMD)&&(CHIP_ID!=CHIP_TSUM9)&&(CHIP_ID!=CHIP_TSUMF)// 2013060
             -4 nick add
                      msWriteByteMask(REG_PM_8D, 0x00, 0xF0);             // pm CLK select RCOSC mux
              #endif
2139   2          }
2140   1          else
2141   1          {
2142   2              
2143   2              //PM_printMsg(" \r\n***PM Clock =>XTAL ");
2144   2              mcuSetSystemSpeed(SPEED_XTAL_MODE);
2145   2              msWriteByteMask(REG_PM_BC, 0, _BIT6);                // mcu clk Live select XTAL
2146   2      #if(CHIP_ID != CHIP_TSUMC && CHIP_ID!=CHIP_TSUMD&&CHIP_ID != CHIP_TSUM9&&CHIP_ID != CHIP_TSUMF)// 20130604
             - nick add
                      msWriteByteMask(REG_PM_8D, 0x30, 0xF0);         // pm CLK select xtal
              #endif
2149   2          }
2150   1      
2151   1          Delay1ms(1);
2152   1          msWriteByteMask(REG_1ED1,_BIT4|_BIT0 , _BIT4|_BIT0);    // power down LPLL and MPLL
2153   1          msWriteByteMask(SC0_F0, 0, BIT1|BIT0);
2154   1          msWriteByte(SC0_F1, 0x01);
2155   1          msWriteByte(SC0_F1, 0x00);
2156   1          msWriteByteMask(SC0_F0, BIT4|BIT1|BIT0, BIT4|BIT1|BIT0);
2157   1          
2158   1      
2159   1      }
2160          #else
              {
              #if PM_CLOCK == RCOSC
                  PM_printMsg(" \r\n***PM Clock =>RCOSC ");
                  mcuSetSpiSpeed( SPI_CLK_4M );
                  mcuSetMcuSpeed( MCU_CLK_4M );
                  msWriteByteMask(REG_PM_8D, 0x00, 0xF0); // pm CLK select RCOSC mux
                  msWriteByteMask(REG_03A6, 0, _BIT2);    // SW XTAL off
              #else
                  PM_printMsg(" \r\n***PM Clock =>XTAL ");
                  mcuSetSpiSpeed( SPI_CLK_XTAL );
                  mcuSetMcuSpeed( MCU_CLK_XTAL );
                  msWriteByteMask(REG_PM_8D, 0x00, 0xF0); // pm CLK select xtal
                  msWriteByteMask(REG_PM_A5, 0xff, BIT2); //SET_PM_REG_FORCE_XTAL_ON();
              #endif
                  Delay1ms(1);
                  msWriteByteMask(REG_1ED1,_BIT4|_BIT0 , _BIT4|_BIT0); // power down LPLL and MPLL
                  msWriteByteMask(SC0_F0, 0, BIT1|BIT0);
                  msWriteByte(SC0_F1, 0x01);
                  msWriteByte(SC0_F1, 0x00);
                  msWriteByteMask(SC0_F0, BIT4|BIT1|BIT0, BIT4|BIT1|BIT0);
              }
              #endif
C51 COMPILER V9.01   MS_PM                                                                 03/09/2023 15:39:11 PAGE 37  

2183          
2184          
2185          //**************************************************************************
2186          //  [Function Name]:
2187          //                  msPM_ClearStatus()
2188          //  [Description]
2189          //                  msPM_ClearStatus
2190          //  [Arguments]:
2191          //
2192          //  [Return]:
2193          //
2194          //**************************************************************************
2195          void
2196          msPM_ClearStatus(Bool bResetPM)
2197          {    
2198   1          msWriteBit(REG_PM_81, TRUE, BIT7);
2199   1          msWriteBit(REG_PM_81, 0   , BIT7);
2200   1           //*********************************************************
2201   1          //Software reset PM //Sky110719                       _                             //
2202   1          ////                                                                 | |                           //
2203   1          //Some wake up event just report a pulse    ____| |___,                    //
2204   1          //if wake up event keep happen after Wake up status Clear,              //
2205   1          //wake up report register will not update status.                               //
2206   1          //software reset can solve it                                                           //
2207   1          //*********************************************************
2208   1          if(bResetPM)
2209   1              msWriteBit(REG_PM_83, TRUE, BIT1);     
2210   1          msWriteBit(REG_PM_83, 0, BIT1);
2211   1            
2212   1           
2213   1        
2214   1      } 
2215          
2216          //**************************************************************************
2217          //  [Function Name]:
2218          //                  msPM_EnableDPDetect(BOOL bEnable)
2219          //  [Description]
2220          //                  Enable DP detect
2221          //  [Arguments]:
2222          //
2223          //  [Return]:
2224          //
2225          //**************************************************************************
2226          #if ENABLE_DP_INPUT
              void msPM_EnableDPDetect(BOOL bEnable)//if not enable can reduce 10mA
              {
              #if (CHIP_ID == CHIP_TSUMC || CHIP_ID == CHIP_TSUMD||CHIP_ID == CHIP_TSUM9||CHIP_ID == CHIP_TSUMF)
                  if(bEnable)
                   {
                      //130524 XD
                       //msWriteByteMask(REG_06AE,(bEnable)?0x07:0x00,0x07);
                       //msWriteByteMask(REG_07AE,(bEnable)?0x07:0x00,0x07);
                    }
              #else
                  if(bEnable)
                  {
                       msWriteByteMask(REG_356D, 0, BIT1);//Disable Power down CDR center bias gen       
                  }
                  else
                  {
                       msWriteByteMask(REG_356D, BIT1, BIT1);//Power down CDR center bias gen
                  }
C51 COMPILER V9.01   MS_PM                                                                 03/09/2023 15:39:11 PAGE 38  

              #endif
              }
              #endif
2248          //**************************************************************************
2249          //  [Function Name]:
2250          //                  msPM_XtalEnable()
2251          //  [Description]
2252          //                  In TSUM9 the register for SW enable XTAL has been changed
2253          //                  to PM_B2[4:0] and need password to overwrite.
2254          //  [Arguments]:
2255          //
2256          //  [Return]:
2257          //
2258          //**************************************************************************
2259          #if (CHIP_ID == CHIP_TSUM9||CHIP_ID == CHIP_TSUMF)
              static void msPM_XtalEnable(BOOL bEn)
              {
                      if (!ENABLE_XTAL_LESS)
                      {
                              msWrite2Byte(REG_PM_B0, 0x5566);        // unlock system configuration protection
              
                              if (bEn)
                      {
                                      msWriteByteMask(REG_PM_B2, 0x1F, 0x1F);         // enable XTAL
                                      ForceDelay1ms(2);
                      }
                              else
                      {
                                      msWriteByteMask(REG_PM_B2, 0x00, 0x1F);         // disable XTAL
                      }
              
                              msWrite2Byte(REG_PM_B0, 0xAA99);        // lock system configuration protection
                      }
              
                      return;
              }
              #endif
2282          //**************************************************************************
2283          //  [Function Name]:
2284          //                  msPM_SetPMMode()
2285          //  [Description]
2286          //                  msPM_SetPMMode
2287          //  [Arguments]:
2288          //
2289          //  [Return]:
2290          //
2291          //**************************************************************************
2292          void msPM_SetPMMode(void)
2293          {
2294   1      #if PM_SUPPORT_ADC_TIME_SHARE
                  msWriteBit(REG_PM_FF,1,BIT2);
                  msWrite2ByteMask(REG_DVI_CHEN, 0xE0|DVI_CTRL_PERIOD, 0xE7 );
              #else
2298   1          msWriteBit(REG_PM_FF,0,BIT2);
2299   1          msWrite2ByteMask(REG_DVI_CHEN, 0x00|DVI_CTRL_PERIOD, 0xE7 );
2300   1      #endif
2301   1      
2302   1          if (sPMInfo.sPMConfig.bHVSync_enable)
2303   1          {
2304   2              msPM_EnableHVSyncDetect(TRUE);
2305   2          }
2306   1          else
C51 COMPILER V9.01   MS_PM                                                                 03/09/2023 15:39:11 PAGE 39  

2307   1          {
2308   2              msPM_EnableHVSyncDetect(FALSE);
2309   2          }
2310   1      
2311   1          if (sPMInfo.sPMConfig.bSOG_enable)
2312   1          {
2313   2              msPM_EnableSOGDetect(TRUE);
2314   2          }
2315   1          else
2316   1          {
2317   2              msPM_EnableSOGDetect(FALSE);
2318   2          }
2319   1      #if ENABLE_DP_INPUT&&PM_SUPPORT_WAKEUP_DP
               if (sPMInfo.sPMConfig.bDP_enable)
                      msPM_EnableDPDetect(TRUE);
              else
                    msPM_EnableDPDetect(FALSE);
              #endif
2325   1      #if( PM_SUPPORT_WAKEUP_DVI )
2326   1          if (sPMInfo.sPMConfig.bDVI_enable)
2327   1          {
2328   2              msPM_EnableDVIDetect(TRUE);
2329   2          }
2330   1          else
2331   1          {
2332   2              msPM_EnableDVIDetect(FALSE);
2333   2          }
2334   1      #endif  // end of #if( PM_SUPPORT_WAKEUP_DVI )
2335   1      
2336   1          if (sPMInfo.ucPMMode == ePM_POWEROFF)       
2337   1              while (((Key_GetKeypadStatus()^KeypadMask)&KeypadMask)==KEY_POWER); //Wait power key released,avoi
             -d power off and the power on again
2338   1      
2339   1          if (sPMInfo.sPMConfig.bGPIO_enable)
2340   1          {
2341   2              msPM_EnableGPIODetect(TRUE);
2342   2          }
2343   1          else
2344   1          {
2345   2              msPM_EnableGPIODetect(FALSE);
2346   2          }
2347   1      
2348   1          if (sPMInfo.sPMConfig.bSAR_enable)
2349   1          {
2350   2              msPM_EnableSARDetect(TRUE);
2351   2          }
2352   1          else
2353   1          {
2354   2              msPM_EnableSARDetect(FALSE);
2355   2          }
2356   1      
2357   1          if (sPMInfo.sPMConfig.bMCCS_enable)
2358   1          {
2359   2              msPM_EnableMCCSDetect(TRUE);
2360   2          }
2361   1          else
2362   1          {
2363   2              msPM_EnableMCCSDetect(FALSE);
2364   2          }
2365   1      
2366   1          msPM_MCCSReset();
2367   1      
C51 COMPILER V9.01   MS_PM                                                                 03/09/2023 15:39:11 PAGE 40  

2368   1      #if( PM_SUPPORT_AC2DC )
                  if (sPMInfo.sPMConfig.bACtoDC_enable)
                  {
                      msPM_EnableAC2DC(TRUE);
                  }
                  else
                  {
                      msPM_EnableAC2DC(FALSE);
                  }
              #endif  // end of #if( PM_SUPPORT_AC2DC )
2378   1      
2379   1          if (sPMInfo.sPMConfig.bEDID_enable)
2380   1          {
2381   2              msPM_Enable_EDID_READ(TRUE);
2382   2          }
2383   1          else
2384   1          {
2385   2              msPM_Enable_EDID_READ(FALSE);
2386   2          }
2387   1      
2388   1          if (sPMInfo.ucPMMode == ePM_POWERON) return;
2389   1          //------------------------------------------------------
2390   1      #if CHIP_ID <=CHIP_TSUM2
                  if (!msPM_StartRCOSCCal())
                  {
                      PM_printData("CALIBARYION RCOSC FAIL!",0);
                  }
                  else
                      PM_printData("CALIBARYION RCOSC Success!",0);
              #endif
2398   1      
2399   1      #if 0//CHIP_ID == CHIP_TSUMC
              #if SPI_SSC_EN
                  mcuSetSpiSpeed(IDX_SPI_CLK_XTAL);// change to other clock source before  DDR clk pd
              #endif
              #endif
2404   1          msPM_PassWord(TRUE);        
2405   1          msPM_PowerDownMacro();
2406   1          msPM_OutputTriState();
2407   1          msPM_ClearStatus(FALSE);
2408   1          
2409   1      #if ENABLE_DP_INPUT // 20130604 nick add
                  DPRXPMForceEnter();
              #endif
2412   1      
2413   1      #if 0//ENABLE_DP_INPUT
                  DPRxClearAUXVliadStatus();
              #endif
2416   1      
2417   1      #if 0//DEBUG_EN
                  msPM_UART();
              #endif
2420   1      //--------------- Sacaler Reset Start--------------------------------
2421   1      
2422   1      //--------------- Sacaler Reset End--------------------------------
2423   1      #if 0//Enable_Cache
                  CACHE_DISABLE();//MCU_EnableCache(_DISABLE);
              #endif
2426   1          if (sPMInfo.sPMConfig.bMCUSleep)
2427   1          {
2428   2              msWriteByteMask(REG_PM_A6, 0, _BIT0);         
2429   2              msPM_SetPMClock(RCOSC);
C51 COMPILER V9.01   MS_PM                                                                 03/09/2023 15:39:11 PAGE 41  

2430   2              msWriteByteMask(REG_PM_AA, _BIT1, _BIT1);//130604 Modify
2431   2              msWriteByteMask(REG_PM_A6, _BIT7, _BIT7|_BIT6);  // Enable HW PM mode (Enable mcu gating)
2432   2              //Set MCU sleep mode
2433   2              PM_printMsg("Enter HW PM Mode");
2434   2              msWriteByte(REG_PM_80, 0xA5);
2435   2              msWriteByte(REG_PM_80, 0x56);
2436   2          }
2437   1          else
2438   1          {
2439   2              //Set MCU no die mode
2440   2              msPM_SetPMClock(PM_CLOCK);
2441   2              if(PM_CLOCK == XTAL)
2442   2                  msWriteByteMask(REG_PM_A6, BIT2, _BIT2|BIT3); 
2443   2              else if((PM_CLOCK == RCOSC))
2444   2      #if ENABLE_DP_INPUT     //111110 modified VS230 PM mode Clock speed 
                          msWriteByteMask(REG_PM_A6, BIT2, _BIT2|BIT3); 
              #else
2447   2              {
2448   3                  //msWriteByteMask(REG_PM_A6, 0, _BIT2|BIT3); 
2449   3                  msWriteByteMask(REG_PM_A6, _BIT2, _BIT2); 
2450   3                  msWriteByteMask(REG_PM_A6, 0, _BIT2); 
2451   3                  msWriteByteMask(REG_PM_A6, 0, BIT3); 
2452   3              }
2453   2      #endif
2454   2      
2455   2              msWriteByteMask(REG_PM_A6, 0, _BIT0); 
2456   2              msWriteByteMask(REG_PM_A6, _BIT0, _BIT0); //Software power down mode
2457   2      
2458   2      #if ENABLE_DP_INPUT
                      g_bDoDPInit = FALSE;
              #endif
2461   2      
2462   2      
2463   2              
2464   2              sPMInfo.ePMState = ePM_WAIT_EVENT;
2465   2              PM_printMsg("Enter SW PM Mode");
2466   2          
2467   2              PM_printData("sPMInfo.ePMState %d",sPMInfo.ePMState);
2468   2          }
2469   1      #if  0//CHIP_ID == CHIP_TSUMD
                      msPM0W_Mode_PassWord(TRUE);
              #endif
2472   1      
2473   1      #if PM_CABLE_DETECT_USE_SAR
                      sPMInfo.bCABLE_SAR_VALUE=CABLE_DET_SAR;
              #endif
2476   1      
2477   1         
2478   1      }
2479          
2480          //**************************************************************************
2481          //  [Function Name]:
2482          //                  msPM_Reset()
2483          //  [Description]
2484          //                  msPM_Reset
2485          //  [Arguments]:
2486          //
2487          //  [Return]:
2488          //      PM status
2489          //
2490          //**************************************************************************
2491          BYTE msPM_Reset(void)
C51 COMPILER V9.01   MS_PM                                                                 03/09/2023 15:39:11 PAGE 42  

2492          {
2493   1          BYTE ucStatus = ePMSTS_INVAID;
2494   1      
2495   1          //msPM_EnableAC2DC(FALSE);
2496   1      
2497   1         // msWriteByte(SC0_F1, 0);
2498   1        //  msWriteByte(REG_1ED1, 0x4);    //MPLL function enable
2499   1         // msWriteByte(SC0_F0, 0);
2500   1      
2501   1         //  msWriteByteMask(REG_PM_A6, _BIT3|_BIT2|BIT1, _BIT3|_BIT2|BIT1);       //SW XTAL on
2502   1         //  msWriteByteMask(REG_01BC, 0, _BIT6);           //Live cLK select XTAL
2503   1      
2504   1         // mcuSetSystemSpeed(SPEED_NORMAL_MODE);
2505   1          //mcuSetMcuSpeed(MCU_SPEED_INDEX) ; // see function body for detail description
2506   1          //mcuSetSpiSpeed(SPI_SPEED_INDEX) ; // see function body for detail description
2507   1         
2508   1        //  msWriteByteMask(REG_PM_A6, 0, _BIT7|_BIT0);  // PM SW power down mode  (MCU no die mode)
2509   1        //  msWriteByte(SC0_06, 0x00);                  //power up idclk and odclk
2510   1      
2511   1          #if 0//Enable_Cache
                  CACHE_ENABLE();//MCU_EnableCache(_ENABLE);
                  #endif
2514   1      
2515   1          msPM_PassWord(FALSE);
2516   1          msPM_Init();
2517   1          //msPM_SetPMMode();
2518   1      
2519   1          msPM_ClearStatus(TRUE);
2520   1      
2521   1          msPM_MCCSReset();
2522   1          PM_printData("Enter PM ePM_PowerON mode!",0);
2523   1          return ucStatus;
2524   1      }
2525          
2526          
2527          
2528          #if 1
2529          void msPM_InterruptEnable(Bool benable)
2530          {
2531   1      #if (CHIP_ID==CHIP_TSUMC||CHIP_ID==CHIP_TSUMD || CHIP_ID == CHIP_TSUM9 || CHIP_ID == CHIP_TSUMF)
2532   1          INT_IRQ_DISP_ENABLE(benable);
2533   1          INT_IRQ_DVI_ENABLE(benable);
2534   1       #else
                   if( benable )
                   {
                   }
                   else
                   {
                   }
               #endif
2542   1      }
2543          #endif
2544          
2545          
2546          #define RECHECK_COUNT_VGA     5
2547          #define RECHECK_COUNT_TMDS    15 // 121026 coding, modified for pattern gen. may output slower when dual o
             -utput
2548          Bool IsHVSyncActive(BYTE count)
2549          {
2550   1          Bool u8Rlt=FALSE;
2551   1          WORD u16InputValue;
2552   1          BYTE check_cnt;
C51 COMPILER V9.01   MS_PM                                                                 03/09/2023 15:39:11 PAGE 43  

2553   1      
2554   1          for(check_cnt=0; check_cnt<count; check_cnt++)
2555   1          {
2556   2      #if     CHIP_ID == CHIP_TSUMC// 20130604 nick modify
2557   2              TMDS_Config_For_PM();// TMDS_SETTING(); //20130416 
2558   2      #endif
2559   2              ForceDelay1ms(20);
2560   2              
2561   2              u16InputValue = msRead2Byte(SC0_E4) & 0x1FFF; 
2562   2              if (u16InputValue == 0x1FFF || u16InputValue < 20)
2563   2                  continue;
2564   2              if(labs( (DWORD)u16InputValue-(msRead2Byte(SC0_E4) & 0x1FFF))>4)//130604 Modify
2565   2                  continue;
2566   2              
2567   2              u16InputValue = msRead2Byte(SC0_E2) & 0x7FF;
2568   2              if (u16InputValue == 0x7FF || u16InputValue < 200)
2569   2                  continue;
2570   2              
2571   2              u8Rlt=TRUE;
2572   2              break;
2573   2          }
2574   1      
2575   1          return u8Rlt;
2576   1      }
2577          #if MS_VGA_SOG_EN
              extern BYTE GetVSyncWidth(void);
              #endif
2580          #if (INPUT_TYPE != INPUT_2H) && (INPUT_TYPE != INPUT_1H)&&(INPUT_TYPE != INPUT_1D1H1DP)
2581          Bool msPM_CheckAnalogSyncActive(void)
2582          {
2583   1          Bool u8Rlt=TRUE;
2584   1          BYTE SyncTYPE = 0;
2585   1      #if MS_VGA_SOG_EN
                  BYTE ucStatus;
                  BYTE w_VSyncWidth;
              #endif
2589   1      
2590   1              msWriteByte(SC0_F3, 0x00);// for SOG+video timing can't wake up(no v count) 
2591   1              msWriteByte(SC0_F0,0x00);       
2592   1              msWriteByte(REG_2E02,0x00);
2593   1              msWriteByte(REG_2508,0x00);
2594   1              msWriteByte(REG_2509,0x00);     
2595   1              //msWriteByteMask(REG_1EDC, 0, _BIT5|_BIT4);                //Power On MPLL 216MHz/432MHz
2596   1              //msWriteByteMask(REG_1ED1,0, _BIT4|_BIT0);               // power on LPLL and MPLL     
2597   1          msWriteByteMask(REG_1E47, 0x00, BIT0);     //Select clk source
2598   1          SrcInputType = Input_VGA; // 120523 coding, check it again
2599   1          mStar_SetupInputPort();     
2600   1          msWriteByteMask(REG_1E3E, 0, BIT0);//Sky110702 Modify for SOG can't Get V Sync
2601   1                      
2602   1              
2603   1               for (SyncTYPE=0; SyncTYPE<2; SyncTYPE++)
2604   1              {
2605   2                      mStar_SetAnalogInputPort(SyncTYPE); 
2606   2                      msWriteByteMask(SC0_ED,0,BIT5);
2607   2                      u8Rlt = IsHVSyncActive(RECHECK_COUNT_VGA);      
2608   2                      if(u8Rlt)
2609   2                      {
2610   3                  #if MS_VGA_SOG_EN
                                  ucStatus = SC0_READ_SYNC_STATUS();//msReadByte(SC0_E1);
                                      if (ucStatus&(SOGP_B)&& ucStatus&(CSP_B))
                                      {
                                              if (ucStatus&SOGD_B )
C51 COMPILER V9.01   MS_PM                                                                 03/09/2023 15:39:11 PAGE 44  

                                              {
                                                      w_VSyncWidth = GetVSyncWidth();                                 
                                                      if (w_VSyncWidth>15 || w_VSyncWidth==0)//check SOG pulse width if bigger than 15  //djyang 20080605
                                                      {
                                                      
                                                              return FALSE;
                                                      }
                                              msWriteByteMask(SC0_ED,1,BIT5); 
                                              }                       
                                      return TRUE;
                                      }
                          #endif                      
2627   3              return u8Rlt;
2628   3                      }
2629   2               }
2630   1         return u8Rlt;
2631   1      }
2632          #endif
2633          #if CHIP_ID == CHIP_TSUM9 ||  CHIP_ID == CHIP_TSUMF
              extern void msInitHDCPProductionKey(void);
              #endif
2636          
2637          #if( PM_SUPPORT_WAKEUP_DVI )
2638          Bool msPM_CheckDVISyncActive( ) 
2639          {
2640   1          Bool u8Rlt=FALSE;
2641   1      #if 1 // // 120523 coding, check it again
2642   1          BYTE count;
2643   1      
2644   1          msWriteByteMask(REG_1E3E, 0x00, BIT0);
2645   1          msWriteByteMask(REG_1E47, 0x00, BIT4|BIT0);
2646   1      #if (CHIP_ID == CHIP_TSUMC || CHIP_ID == CHIP_TSUMD)
2647   1          msWriteByteMask(REG_01A6,BIT3,BIT3);
2648   1          msWrite2Byte(REG_142A, 0x0017);
2649   1          msWrite2Byte(REG_17BC, 0x8000);
2650   1          msWrite2Byte(REG_17BE, 0x0000);
2651   1          msWrite2Byte(REG_01CE, 0x0020);
2652   1      #elif CHIP_ID == CHIP_TSUM9 || CHIP_ID == CHIP_TSUMF
                  mcuSetSystemSpeed(SPEED_NORMAL_MODE);
                  msTMDSInit();
                  msInitHDCPProductionKey();
              #endif
2657   1      #if CHIP_ID!=CHIP_TSUMU && CHIP_ID < CHIP_TSUMC
                  msWriteByteMask(REG_29FE, 0x00, ~(BIT7|BIT6));  
              #endif
2660   1      
2661   1      
2662   1          for(count=0; count<Input_Nums; count++) // 121026 coding modified for prevent SrcInputType over TMDS i
             -nput port numbers
2663   1              {
2664   2               //20130415 for C/D set CLK port fail
2665   2                  SrcInputType = count;
2666   2      
2667   2              if(CURRENT_INPUT_IS_TMDS())
2668   2              {
2669   3                  mStar_SetupInputPort(); 
2670   3                  
2671   3                  u8Rlt = IsHVSyncActive(RECHECK_COUNT_TMDS);
2672   3                  if(u8Rlt == TRUE)
2673   3                  {
2674   4                      break;
2675   4                  }
C51 COMPILER V9.01   MS_PM                                                                 03/09/2023 15:39:11 PAGE 45  

2676   3              }
2677   2          }
2678   1      
2679   1      #if PM_DEBUG
                  PM_printData("PM_A2:%x", msReadByte(REG_PM_A2));
                  PM_printData("PM_A4:%x", msReadByte(REG_PM_A4));
                   PM_printData("u8Rlt:%d", u8Rlt);   
                  if(u8Rlt == TRUE)
                      PM_printData("msPM_CheckDVISyncActive:%d", SrcInputType);
              #endif
2686   1      #else
                  mStar_SetupInputPort();     
                  msWriteByteMask(REG_1E3E, 0x00, BIT0);
                  msWriteByteMask(REG_1E47, 0x00, BIT4|BIT0);
              #if CHIP_ID!=CHIP_TSUMU
                  msWriteByteMask(REG_29FE, 0x00, ~(BIT7|BIT6));  
              #endif
              
                  if(DVI_DE_STABLE() == TRUE)
                      u8Rlt=TRUE;
              
                  u8Rlt = IsHVSyncActive(RECHECK_COUNT);
              #endif
2699   1          return u8Rlt;
2700   1      
2701   1      }
2702          #endif
2703          #if   0//  sahdow_Need test
              Bool msPM_CheckDPMCCSActive(void)
              {
                      Bool bExitPM = TRUE;
                       if(msRegs[REG_1FE6]&_BIT7)   //MCCS Interrupt 
                              {
                                      //DDC2BI_DP() ;
                                      if(DDCBuffer[2]==PowerMode)
                                      {
                                              if((DDCBuffer[4] == 0x01)
                                              &&(sPMInfo.ucPMMode == ePM_POWEROFF || sPMInfo.ucPMMode == ePM_STANDBY))
                                                      ;
                                              else  if((DDCBuffer[4] == 0x05) && (sPMInfo.ucPMMode == ePM_STANDBY))
                                              {
                                                      msPM_Reset();
                                                      PowerOffSystem();
                                                      bExitPM=FALSE;
                                              }
                                              else  if((DDCBuffer[4] == 0x05) && (sPMInfo.ucPMMode == ePM_POWEROFF))
                                              {
              
                                              } 
                                              else 
                                                      bExitPM=FALSE;
                                      }
                                              
                              }
              
               return bExitPM;
              
              
              }
              #endif
2736          Bool msPM_CheckMCCSActive(void)
2737          {
C51 COMPILER V9.01   MS_PM                                                                 03/09/2023 15:39:11 PAGE 46  

2738   1          Bool bExitPM = TRUE;
2739   1                if((ucWakeupStatus == ePMSTS_MCCS01_ACT)
2740   1                      &&(sPMInfo.ucPMMode == ePM_POWEROFF || sPMInfo.ucPMMode == ePM_STANDBY))
2741   1                      ;
2742   1                #if 0//def WH_REQUEST //130424 Modify fot FQ request 05h command can't do any active
                       else  if((ucWakeupStatus == ePMSTS_MCCS05_ACT) && (sPMInfo.ucPMMode == ePM_STANDBY))
                              {
                                      msPM_Reset();
                                      PowerOffSystem();
                                      bExitPM=FALSE;
                              }
                         else  if((ucWakeupStatus == ePMSTS_MCCS05_ACT) && (sPMInfo.ucPMMode == ePM_POWEROFF))
                           {
                           
                             } 
                        #endif
2754   1                 else 
2755   1                      bExitPM=FALSE;
2756   1          return bExitPM;
2757   1      }
2758          Bool msPM_CheckPowerKeyActive(void)
2759          {
2760   1          Bool bExitPM = FALSE;
2761   1      
2762   1      #if  PM_POWERkEY_GETVALUE
                      {
                              if(sPMInfo.ucPMMode == ePM_STANDBY)
                              {
                                  msPM_Reset();
                                  PowerOffSystem();
                              }
                              else if(sPMInfo.ucPMMode == ePM_POWEROFF)
                              {
                                  bExitPM = TRUE;
                              }
                          }
              #else
2775   1      
2776   1          WORD ucStatus_GPIO;
2777   1          ucStatus_GPIO = msRead2Byte( REG_PMGPIO_STS );
2778   1      
2779   1          if ( ucStatus_GPIO & (PM_POWERKEY_INT) )//power key
2780   1          {
2781   2              if(sPMInfo.ucPMMode == ePM_STANDBY)
2782   2              {
2783   3                  //msPM_Reset();
2784   3                  PowerOffSystem();
2785   3              }
2786   2              else if(sPMInfo.ucPMMode == ePM_POWEROFF)
2787   2                  bExitPM = TRUE;
2788   2          }
2789   1      #endif  
2790   1          return bExitPM;
2791   1      }
2792          
2793          
2794          BOOL msPM_Checkagain(void)
2795          {
2796   1          Bool bExitPM = TRUE;
2797   1          
2798   1          BYTE GetKeyTemp = 0;
2799   1          
C51 COMPILER V9.01   MS_PM                                                                 03/09/2023 15:39:11 PAGE 47  

2800   1         //volatile WORD ucStatus_GPIO;
2801   1          msWriteByte(SC0_F1, 0);
2802   1         // msWriteByte(REG_1ED1, 0x4);    //MPLL function enable//130604 Modify
2803   1          msWriteByte(SC0_F0, 0);
2804   1      
2805   1          msWriteByteMask(REG_PM_A6, _BIT3|_BIT2|BIT1, _BIT3|_BIT2|BIT1);       //SW XTAL on
2806   1          ForceDelay1ms(10);//20130512 add mail 20130426 
2807   1          #if (CHIP_ID == CHIP_TSUM9 || CHIP_ID == CHIP_TSUMF)
                  msPM_XtalEnable(TRUE);              // eanble XTAL
                  drvmStar_MpllSrcCfg();
                  #endif
2811   1        
2812   1              msWriteByteMask(REG_PM_BC, 0, _BIT6);           //Live cLK select XTAL
2813   1          mcuSetSystemSpeed(SPEED_NORMAL_MODE);
2814   1          msWriteByteMask(REG_PM_A6, 0, _BIT7|_BIT0);  // PM SW power down mode  (MCU no die mode)
2815   1          msWriteByte(SC0_06, 0x00);                  //power up idclk and odclk
2816   1      
2817   1          #if 0//Enable_Cache
                  CACHE_ENABLE();//MCU_EnableCache(_ENABLE);
                  #endif
2820   1      #if ENABLE_MHL
                  if(ucWakeupStatus ==ePMSTS_MHL_SOURCE_ACT)
                  {
                      mapi_mhl_PowerCtrl(MHL_POWER_ON);
                      //drvDVI_PowerCtrl(DVI_POWER_ON);
                      mStar_SetupInputPort(); 
                      bExitPM = TRUE;//wakeup
                  }
                  else
              #endif
2830   1          if(ucWakeupStatus == ePMSTS_VGA_ACT)
2831   1          {
2832   2            #if ENABLE_VGA_INPUT
2833   2              if(msPM_CheckAnalogSyncActive())
2834   2              {
2835   3                      bExitPM = TRUE;//wakeup
2836   3              }
2837   2              else
2838   2             #endif
2839   2                  bExitPM = FALSE;
2840   2              
2841   2          }
2842   1          #if( PM_SUPPORT_WAKEUP_DVI )
2843   1          else if(ucWakeupStatus == ePMSTS_DVI_0_ACT||ucWakeupStatus ==ePMSTS_DVI_1_ACT||ucWakeupStatus ==ePMSTS
             -_MHL_SOURCE_ACT)
2844   1          {
2845   2           #if ENABLE_MHL
                          mapi_mhl_PowerCtrl(MHL_POWER_ON);
                    #endif
2848   2              if(msPM_CheckDVISyncActive())
2849   2              {
2850   3                      bExitPM = TRUE;//wakeup
2851   3              }
2852   2             else
2853   2                  bExitPM = FALSE;
2854   2          }
2855   1          #endif      
2856   1          else if(ucWakeupStatus == ePMSTS_GPIO_ACT)
2857   1          {
2858   2                  #if !(PM_POWERkEY_GETVALUE)
2859   2                      if(msPM_CheckPowerKeyActive())
2860   2                              {
C51 COMPILER V9.01   MS_PM                                                                 03/09/2023 15:39:11 PAGE 48  

2861   3                              bExitPM = TRUE;//wakeup         
2862   3                              }
2863   2                              else
2864   2                  #endif              
2865   2                  #if         PM_CABLEDETECT_USE_GPIO&&ENABLE_DP_INPUT
                                      if (!(DP_CABLE_NODET))
                                      {
                                                SrcInputType=Input_Displayport;
                                                 mStar_SetupInputPort();      
                                              bExitPM = TRUE; 
                                      }
                              else
                          #endif      
2874   2                              
2875   2                              bExitPM = FALSE;
2876   2                              
2877   2              
2878   2          }
2879   1          else if(ucWakeupStatus == ePMSTS_SAR_ACT)
2880   1          {
2881   2      
2882   2                      bExitPM = TRUE;
2883   2          }   
2884   1          else if(ucWakeupStatus == ePMSTS_ITE_POWER_KEY_ACT)
2885   1          {
2886   2      
2887   2                      bExitPM = TRUE;
2888   2          }   
2889   1          else if(ucWakeupStatus == ePMSTS_GPIO_POWER_KEY_ACT)
2890   1          {
2891   2      
2892   2                      bExitPM = TRUE;
2893   2          }   
2894   1      #if ENABLE_AutoDetech   
                  else if(ucWakeupStatus == ePMSTS_ITE_SOURCE_KEY_ACT)
                  {
                          if(PowerOnFlag)
                          {
                              bExitPM = TRUE;
                          }
                          else
                            bExitPM = FALSE;
                  }   
              #endif  
2905   1      #if  (FEnterFunction==FEnter_POWER_MENU)||(FEnterFunction==FEnter_POWER_EXIT)
                  else if(ucWakeupStatus == ePMSTS_ITE_FACTORY_KEY_ACT)       //120523 Modify
                  {
                      if(!PowerOnFlag)
                                      bExitPM = TRUE;
                      else
                                      bExitPM = FALSE;
                  }   
              #endif
2914   1          else if(ucWakeupStatus == ePMSTS_ITE_OSDLOCK_KEY_ACT)       //120524 Modify
2915   1          {
2916   2              if(!PowerOnFlag)
2917   2                              bExitPM = TRUE;
2918   2              else
2919   2                              bExitPM = FALSE;
2920   2          }   
2921   1          else if(ucWakeupStatus == ePMSTS_MCCS05_ACT||ucWakeupStatus==ePMSTS_MCCS04_ACT||ucWakeupStatus == ePMS
             -TS_MCCS01_ACT)//20100419
C51 COMPILER V9.01   MS_PM                                                                 03/09/2023 15:39:11 PAGE 49  

2922   1          {
2923   2              if(msPM_CheckMCCSActive())
2924   2                  bExitPM = TRUE;//wakeup
2925   2              else
2926   2                  bExitPM = FALSE;
2927   2          }
2928   1      #if ENABLE_DP_INPUT&&PM_SUPPORT_WAKEUP_DP
              else if(ucWakeupStatus == ePMSTS_DP_ACT)
                 {
                   mStar_SetupInputPort();    
                      #if  0 //  sahdow_Need test 
                      if(msPM_CheckDPMCCSActive())
                              bExitPM = TRUE;
                      else
                              bExitPM = FALSE;
                      #else
                      bExitPM = TRUE;
                      #endif
                 }
              #endif
2942   1      #if (PM_POWERkEY_GETVALUE)
                      else if(ucWakeupStatus == ePMSTS_POWERGPIO_ACT)
                 {
                      if(msPM_CheckPowerKeyActive())
                              {
                                      bExitPM = TRUE;//wakeup
                                      KeypadButton=BTN_Repeat;      //110914 Rick modified
                              }
                      else
                              bExitPM = FALSE;
                 }
              
              #endif
2955   1      #if (PM_CABLE_DETECT_USE_SAR)
              else if(ucWakeupStatus ==ePMSTS_CABLESAR_ACT)
                      {         
                              if(CABLE_DET_SAR<sPMInfo.bCABLE_SAR_VALUE)
                                      bExitPM = TRUE;
                              else
                                      bExitPM = FALSE;
                      }
              #endif
2964   1      #if ENABLE_MHL
                      else if(ucWakeupStatus == ePMSTS_MHL_ACT)
                      {
                          bExitPM = TRUE;
                          PM_printData("ePMSTS_MHL_ACT:%d", ePMSTS_MHL_ACT);
                      }
              #endif
2971   1      #if ENABLE_ANDROID_IR   //131008 Modify
                      else if(ucWakeupStatus==ePMSTS_IR_PowerKEY_ACT) //
                      {
                          bExitPM = TRUE;
                      }
              #endif
2977   1      
2978   1          else
2979   1              bExitPM = FALSE;
2980   1          
2981   1              //    bExitPM = TRUE;//wakeup
2982   1      
2983   1          return bExitPM;
C51 COMPILER V9.01   MS_PM                                                                 03/09/2023 15:39:11 PAGE 50  

2984   1      }
2985          
2986          Bool PM_CheckKeypadStatus(BYTE KeypadStatus)
2987          {
2988   1          bit bresult = FALSE;
2989   1      
2990   1          if( KeypadStatus)
2991   1          {
2992   2              #if ENABLE_AutoDetech
                              if(KeypadStatus==KEY_EXIT)
                              {
                                      {
                                              ucWakeupStatus = ePMSTS_ITE_SOURCE_KEY_ACT;
                                              bresult = TRUE;
                                      }
                              }
              
                      else
                      #endif
3003   2                if (KeypadStatus == KEY_POWER)
3004   2              {
3005   3                              {
3006   4                          ucWakeupStatus = ePMSTS_ITE_POWER_KEY_ACT;
3007   4                          bresult = TRUE;
3008   4      
3009   4                              }
3010   3                                                                                                                
             -                                                                                                                        
             -                                                                                                                        
             -                                                                                                                        
             -                                                                                                                        
             -                                                                                                                        
             -                                                                                                                        
             -                                                                                                                        
             -                                                                                                                        
             -                                                                                                                        
             -                                                                                                                        
             -                                                                                                                        
             -                                                                                                                        
             -                                                                                                                        
             -                                                                                                                        
             -                                                                                                                        
             -                                                                                                                        
             -              
3011   3                                                                                                          }
3012   2                #if  (FEnterFunction==FEnter_POWER_MENU)||(FEnterFunction==FEnter_POWER_EXIT)
                      else if ((KeypadStatus == KEY_FACTORY) && (!PowerOnFlag))       //120523 Modify
                      {
                          ucWakeupStatus = ePMSTS_ITE_FACTORY_KEY_ACT;
                          bresult = TRUE;
                      }
                       #endif 
3019   2          }
3020   1      
3021   1      
3022   1          return bresult;
3023   1      }
3024          //**************************************************************************
3025          //  [Function Name]:
3026          //                  msPM_WaitingEvent()
3027          //  [Description]
3028          //                  msPM_WaitingEvent
C51 COMPILER V9.01   MS_PM                                                                 03/09/2023 15:39:11 PAGE 51  

3029          //  [Arguments]:
3030          //
3031          //  [Return]:
3032          //
3033          //**************************************************************************
3034          #define SAR_KEY_TH      0x30
3035          void
3036          msPM_WaitingEvent(void)
3037          {
3038   1          BYTE GetKeyTemp = 0;
3039   1      
3040   1         // msPM_InterruptEnable(FALSE);
3041   1          //msPM_ClearStatus(TRUE); // 120209 coding reserved. PM sw mode, after disable xtal, it should not res
             -et PM
3042   1       #if ENABLE_DEBUG   
                  printMsg("msPM_WaitingEvent.....");
              #endif
3045   1          while(1)
3046   1          {     
3047   2      #if ENABLE_DEBUG
                          DebugHandler();
                      if ( DebugOnlyFlag )
                          continue;
              #endif
3052   2          
3053   2      #ifdef UseVGACableReadWriteAllPortsEDID    
              #endif        
3055   2              {
3056   3                  if( SyncLossState() && IsCableNotConnected() )
3057   3                  {
3058   4                      hw_SetDDC_WP();//petit 20121123 for TPV new request
3059   4                  }
3060   3                  
3061   3              }
3062   2      
3063   2              Main_SlowTimerHandler();
3064   2              //120521 Modify
3065   2              if( !TPDebunceCounter )
3066   2              {
3067   3                  TPDebunceCounter = SKPollingInterval;
3068   3                  GetKeyTemp =  (Key_GetKeypadStatus() ^ KeypadMask) &KeypadMask;//Key_GetKeypadStatus();
3069   3                  if(PM_CheckKeypadStatus(GetKeyTemp))
3070   3                      break;
3071   3              }
3072   2      
3073   2      #if ENABLE_ANDROID_IR   //131008 Modify
                      IR_PM_KeyPadStatus = ( IR_GetIRKeypadStatus() ^ KeypadMask ) & KeypadMask;
                      //PM_printData("IR_PM_KeyPadStatus %x",IR_PM_KeyPadStatus );
                      if(IR_PM_KeyPadStatus == KEY_POWER)
                      {
                          ucWakeupStatus=ePMSTS_IR_PowerKEY_ACT;
                          break;
                      }
              #endif
3082   2                      
3083   2              #if ENABLE_MHL&&CHIP_ID==CHIP_TSUM2     //130605 nick
                      if(MHL_CHECK_CONDITION())
                      {
                          if(mdrv_mhl_WakeupDetect())
                          {
                              ucWakeupStatus= ePMSTS_MHL_SOURCE_ACT;
                              PM_printMsg("MHL Detect Wakup");
C51 COMPILER V9.01   MS_PM                                                                 03/09/2023 15:39:11 PAGE 52  

                              break;
                          }
                      }
                      #endif                            
3094   2           #if  Enable_CheckVcc5V
                     if ( CheckVCC5V() )      
                      break;
                   #endif
3098   2      
3099   2              if(msPM_GetPMStatus())
3100   2                  break;
3101   2              #if 0//!DEBUG_EN
                      if(DDCCI_CheckDMPSON())
                          break;
                      #endif
3105   2      
3106   2                      
3107   2           /*   if((ForceEnterPowerOffFlag)&&(PowerOnFlag))
3108   2              {
3109   2                  Clr_ForceEnterPowerOffFlag();
3110   2                  //ExecuteKeyEvent(MIA_Power);
3111   2                  KeypadButton = BTN_Nothing;             
3112   2                   ucWakeupStatus = ePMSTS_ITE_POWER_KEY_ACT;
3113   2                  break;
3114   2                              
3115   2              }*/
3116   2                      
3117   2                      
3118   2          }
3119   1          PM_printData("\r\nPM Wakeup Event1 (%d) !", ucWakeupStatus);
3120   1          //msPM_InterruptEnable(TRUE);
3121   1      }
3122          
3123          
3124          #if 0
              void   msPM_SetupWakeUpFunc( void )
              {
              #define _PMMETA  sPMInfo.sPMConfig
                  msPM_printConfiguration();
                  msPM_EnableHVSyncDetect(_PMMETA.bHVSync_enable);
                  msPM_EnableSOGDetect(_PMMETA.bSOG_enable);
                  msPM_EnableGPIODetect(_PMMETA.bGPIO_enable);
                  msPM_EnableSARDetect(_PMMETA.bSAR_enable);
                  msPM_EnableMCCSDetect(_PMMETA.bMCCS_enable);
                  msPM_Enable_EDID_READ(_PMMETA.bEDID_enable);
              #if( PM_SUPPORT_AC2DC )
                  msPM_EnableAC2DC(_PMMETA.bACtoDC_enable);
              #endif  // end of #if( PM_SUPPORT_AC2DC )
              #if( PM_SUPPORT_WAKEUP_DVI )
                  msPM_EnableDVIDetect(_PMMETA.bDVI_enable);
              #endif  // end of #if( PM_SUPPORT_WAKEUP_DVI )
              #if (!PM_SUPPORT_SOG_TIME_SHARE) && (!PM_SUPPORT_DVI_TIME_SHARE)
                  msPM_EnableDVIClockAmp(FALSE);
              #elif PM_SUPPORT_DVI_TIME_SHARE
                  if( !_PMMETA.bDVI_enable )
                      msPM_EnableDVIClockAmp(FALSE);
              #elif PM_SUPPORT_SOG_TIME_SHARE
                  if( !_PMMETA.bSOG_enable )
                      msPM_EnableDVIClockAmp(FALSE);
              #else
                  if( (!_PMMETA.bSOG_enable) && (!_PMMETA.bDVI_enable) )
                      msPM_EnableDVIClockAmp(FALSE);
C51 COMPILER V9.01   MS_PM                                                                 03/09/2023 15:39:11 PAGE 53  

              #endif
              #undef _PMMETA
              }
              #endif
3156          
3157          //**************************************************************************
3158          //  [Function Name]:
3159          //                  msPM_Handler()
3160          //  [Description]
3161          //                  msPM_Handler
3162          //  [Arguments]:
3163          //
3164          //  [Return]:
3165          //
3166          //**************************************************************************
3167          void  msPM_Handler(void)
3168          {
3169   1          switch(sPMInfo.ePMState)
3170   1          {
3171   2              case ePM_ENTER_PM:
3172   2                      #if( ENABLE_WATCH_DOG ) //130716 xiandi follow demo code
                                      Init_WDT( _DISABLE );
                              #endif
3175   2                  msPM_SetPMMode();
3176   2                  
3177   2              break;
3178   2      
3179   2              case ePM_WAIT_EVENT:
3180   2                  
3181   2                  msPM_WaitingEvent();
3182   2                  if(msPM_Checkagain())
3183   2                      sPMInfo.ePMState = ePM_EXIT_PM;
3184   2                  else
3185   2                      sPMInfo.ePMState = ePM_ENTER_PM;                        
3186   2              break;
3187   2      
3188   2              case ePM_EXIT_PM:
3189   2                              
3190   2      #if DEBUG_PRINTDATA                             
                 printMsg("ePM_EXIT_PM   Enter");
              #endif                  
3193   2                  msPM_Reset();
3194   2      
3195   2                  msPM_PowerUpMacro();
3196   2              #if ENABLE_DisplayPortTX
                      gDPTXInfo.bReTraining = 1;
                      #endif
3199   2                  sPMInfo.ePMState = ePM_IDLE; // 121011 coding, check it again, moves to here for power off set
             - 
3200   2      
3201   2      
3202   2      
3203   2                  // 121026 coding modified for wakeup priority 
3204   2                  if(PowerOnFlag) // wakeup form power saving
3205   2                  {
3206   3      #if !PM_POWERSAVING_WAKEUP_GPIO //121108 Modify
3207   3                      if (ucWakeupStatus==ePMSTS_ITE_POWER_KEY_ACT
3208   3      #if ENABLE_ANDROID_IR //Modify HDMI Source Powersaving Press IR Power don't DC ON Issue 20150316 Alpha
                                              || ucWakeupStatus==ePMSTS_IR_PowerKEY_ACT
              #endif                          
3211   3                                      )
3212   3                      {
C51 COMPILER V9.01   MS_PM                                                                 03/09/2023 15:39:11 PAGE 54  

3213   4                          ExecuteKeyEvent( MIA_Power);
3214   4                          KeypadButton = BTN_Repeat;
3215   4                      }
3216   3                      else
3217   3      #else
                              if (ucWakeupStatus==ePMSTS_GPIO_POWER_KEY_ACT)
                              {
                                  ExecuteKeyEvent( MIA_Power);
                                  KeypadButton = BTN_Repeat;
                              }
                              else
              #endif
3225   3              #if ENABLE_AutoDetech
                              if (ucWakeupStatus==ePMSTS_ITE_SOURCE_KEY_ACT)
                              {
                                  Set_PowerSavingFlag();
                                              mStar_PowerUp();
                                  ExecuteKeyEvent( MIA_SourceSel );
                                  OsdCounter = UserPrefOsdTime;       //120523 Modify
                              }
                              else
                      #endif                          
3235   3                              if((ucWakeupStatus == ePMSTS_VGA_ACT) 
3236   3                           #if( PM_SUPPORT_WAKEUP_DVI )
3237   3                           ||(ucWakeupStatus == ePMSTS_DVI_0_ACT)
3238   3                           ||(ucWakeupStatus ==ePMSTS_DVI_1_ACT)
3239   3                           #endif
3240   3                           #if ENABLE_DP_INPUT        //121130 Modify
                                   ||(ucWakeupStatus ==ePMSTS_DP_ACT)
                                   #endif
3243   3                           #if ENABLE_MHL//130703 nick
                                    ||(ucWakeupStatus == ePMSTS_MHL_ACT)
                                   #endif
3246   3                                      )
3247   3                         {
3248   4                             Power_PowerOnSystem();
3249   4                             if(ucWakeupStatus != ePMSTS_VGA_ACT && UserPrefInputType == Input_VGA)
3250   4                             {
3251   5                                 SrcInputType = Input_VGA;
3252   5                                 mStar_SetupInputPort();      
3253   5                                 ucWakeupStatus = ePMSTS_VGA_ACT;
3254   5                             }
3255   4                         }
3256   3                  }
3257   2                  else // wakeup from dc off          
3258   2                  {
3259   3                   #if  (FEnterFunction==FEnter_POWER_MENU)||(FEnterFunction==FEnter_POWER_EXIT)
                              if (ucWakeupStatus==ePMSTS_ITE_FACTORY_KEY_ACT) //120523 Modify
                              {
                                      Set_FactoryModeFlag();
                                   Set_BurninModeFlag();
                                   Set_DoBurninModeFlag();    
                                      #if !USEFLASH
                                      NVRam_WriteByte(nvrMonitorAddr(MonitorFlag), MonitorFlags);
                                  #else
                                      SaveMonitorSetting();
                                  #endif
                              }
                              #endif
3272   3                      PowerOnSystem();
3273   3                  }
3274   2                  //sPMInfo.ePMState = ePM_IDLE; // 121011 coding, check it again, moves to upper position for p
C51 COMPILER V9.01   MS_PM                                                                 03/09/2023 15:39:11 PAGE 55  

             -ower off 
3275   2                      #if( ENABLE_WATCH_DOG ) //130716 xiandi follow demo code
                                      Init_WDT( _ENABLE );
                                      WDT_CLEAR();
                              #endif
3279   2                      
3280   2              break;
3281   2      
3282   2              case ePM_IDLE:
3283   2              default:
3284   2              break;
3285   2          }
3286   1        
3287   1      }
3288          
3289          #if (CHIP_ID == CHIP_TSUM9 || CHIP_ID == CHIP_TSUMF)
              void msPM_Exit(void)
              {
                      msWriteByte(REG_PM_A6, 0x0E); //turn on core power
                      msPM_PassWord(FALSE);
              }
              #endif
3296          
3297          
3298          
3299          #endif
3300          
3301          
3302          
3303          
3304          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3274    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     10    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      23
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

C51 COMPILER V9.01   MSMINILVDSI2C                                                         03/09/2023 15:39:13 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE MSMINILVDSI2C
OBJECT MODULE PLACED IN .\obj\msMiniLVDSI2C.obj
COMPILER INVOKED BY: D:\Keil4\C51\BIN\C51.EXE ..\..\DRIVER\extDEVICE\msMiniLVDSI2C.c OPTIMIZE(SIZE) BROWSE INCDIR(..\..\
                    -DRIVER\INC;..\..\KERNEL\SCALER\INC;..\..\KERNEL\SYSTEM\INC;..\..\LIB\INC;..\..\PANEL\INC;..\..\BOARD;..\..\DRIVER\INC;..
                    -\..\KERNEL\SYSTEM\INC\AOC2011;..\..\DRIVER\extDEVICE\INC;..\..\MODEL;..\..\CONFIG;..\..\PANEL;..\..\UI\F_LOGO\INC;..\..\
                    -UI\HkcOsd\INC) DEFINE(ModelName=JRY_TESTBOARD_C_BOARD) DEBUG OBJECTEXTEND PRINT(.\list\msMiniLVDSI2C.lst) OBJECT(.\obj\m
                    -sMiniLVDSI2C.obj)

line level    source

   1          #define _MSMINILVDS_C_
   2          #include "types.h"
   3          #include "board.h"
   4          #include "global.h"
   5          #include "i2cdef.h"
   6          
   7          #include "debug.h"
   8          #include "misc.h"
   9          #include "panel.h"
  10          #include "GPIO_DEF.h"
  11          
  12          
  13          #if PanelminiLVDS ||PANEL_VCOM_ADJUST   //110229 Modify
              
              #define I2C_CHECK       1
              #if I2C_CHECK
              #define I2C_CHECK_PIN_DUMMY 100
              
              void msMiniLVDSi2cSCL_Chk(void)
              {
                  BYTE ucDummy = I2C_CHECK_PIN_DUMMY; // initialize dummy
                  while (HW_GET_VCOM_I2C_SCL_Lo()&&(ucDummy--))
                      ; // check SCL pull high
              }
              
              void msMiniLVDSi2cSDA_Chk(void)
              {  
                  BYTE ucDummy = I2C_CHECK_PIN_DUMMY; // initialize dummy
                  while (HW_GET_VCOM_I2C_SDA_Lo()&&(ucDummy--))
                      ; // check SCL pull high
              }
              #endif
              
              
              Bool Wait_Bus_Release(void)
              {
                  BYTE Counter=100;
                  
                  do
                  {
                      Counter--;
                      Delay4us();
                  }
                  
                  while((HW_GET_VCOM_I2C_SDA_HI()) && (Counter >0) );
                  
                  if(HW_GET_VCOM_I2C_SDA_Lo())                     
                      return TRUE;
                  
                  return FALSE;           
              }
C51 COMPILER V9.01   MSMINILVDSI2C                                                         03/09/2023 15:39:13 PAGE 2   

              
              Bool msMiniLVDSi2c_Start(void)
              {   
                  HW_SET_VCOM_I2C_SDA();
                  #if I2C_CHECK
                  msMiniLVDSi2cSDA_Chk();
                  #endif
                  Delay4us();
                  HW_SET_VCOM_I2C_SCL();
                  #if I2C_CHECK
                  msMiniLVDSi2cSCL_Chk();//ywb++
                  #endif
                  Delay4us();
                  if (HW_GET_VCOM_I2C_SDA_Lo() || HW_GET_VCOM_I2C_SCL_Lo())
                      return FALSE;
                  HW_CLR_VCOM_I2C_SDA();
                  Delay4us();
                  HW_CLR_VCOM_I2C_SCL();
                  
                  return TRUE;
              }
              
              void msMiniLVDSi2c_Stop(void)
              {
                  HW_CLR_VCOM_I2C_SCL();
                  Delay4us();
                  HW_CLR_VCOM_I2C_SDA();
                  Delay4us();
              
                  HW_SET_VCOM_I2C_SCL();
                  Delay4us();
                  HW_SET_VCOM_I2C_SDA();
              }
              
              Bool msMiniLVDSi2c_SendByte(BYTE value)
              {   
                  BYTE i;
                  Bool result;
              
                  for (i=0; i<8; i++)
                  {   
                      if (value&BIT7)
                      {
                          HW_SET_VCOM_I2C_SDA();
                          #if I2C_CHECK
                          msMiniLVDSi2cSDA_Chk();
                          #endif
                      }
                      else
                          HW_CLR_VCOM_I2C_SDA();
                      Delay4us();
                      Delay4us();
                      Delay4us();
                      HW_SET_VCOM_I2C_SCL();
                      Delay4us();     //111118 Modify for LNT request
                      value<<=1;
                      HW_CLR_VCOM_I2C_SCL();
                  }
                  HW_SET_VCOM_I2C_SDA();
                  Wait_Bus_Release();
                  Delay4us();
                  HW_SET_VCOM_I2C_SCL();
C51 COMPILER V9.01   MSMINILVDSI2C                                                         03/09/2023 15:39:13 PAGE 3   

                  #if I2C_CHECK
                  msMiniLVDSi2cSCL_Chk();
                  #endif
              
                  result=HW_GET_VCOM_I2C_SDA_Lo();
              
                  HW_CLR_VCOM_I2C_SCL();
                  Delay4us();
                  HW_CLR_VCOM_I2C_SDA();
              
                  return result;
              }
              
              
              BYTE msMiniLVDSi2c_ReceiveByte(const Bool ack)
              {   
                  BYTE i;
                  BYTE value=0;
              
                  for (i=0; i<8; i++)
                  {   
                      value<<=1;
                      HW_SET_VCOM_I2C_SDA();
                      #if I2C_CHECK
                      msMiniLVDSi2cSDA_Chk();
                      #endif
                      HW_SET_VCOM_I2C_SCL();
                      #if I2C_CHECK
                      msMiniLVDSi2cSCL_Chk();
                      #endif
                      Delay4us();
                      Delay4us();
                      Delay4us();
                      if (HW_GET_VCOM_I2C_SDA_HI())
                          value|=BIT0;
                      HW_CLR_VCOM_I2C_SCL();
                  }
              
                  if (ack)
                      HW_CLR_VCOM_I2C_SDA();
                  else
                  {
                      HW_SET_VCOM_I2C_SDA();
                      #if I2C_CHECK
                      msMiniLVDSi2cSDA_Chk();
                      #endif
                  }
                  Delay4us();
              
                  HW_SET_VCOM_I2C_SCL();
                  Delay4us();
                  HW_CLR_VCOM_I2C_SCL();
              
                  return value;
              }
              
              /*
              Bool msMiniLVDSi2c_BurstWrite(BYTE count, BYTE *buffer)
              {   
                  while (count--)
                  { 
                      if (msMiniLVDSi2c_SendByte(*(buffer++))==FALSE)
C51 COMPILER V9.01   MSMINILVDSI2C                                                         03/09/2023 15:39:13 PAGE 4   

                          return FALSE;
                  }
                  
                  return TRUE;
              }
              
              Bool msMiniLVDSi2c_BurstRead(BYTE count, BYTE * buffer)
              {   
                  BYTE i;
              
                  for (i=0; i<count-1; i++)
                      *(buffer+i)=msMiniLVDSi2c_ReceiveByte(1);
                  *(buffer+i)=msMiniLVDSi2c_ReceiveByte(0);
              
                  msMiniLVDSi2c_Stop();
              
                  return TRUE;
              }
              */
              Bool msMiniLVDSi2c_MasterStart(I2C_Direction direct, BYTE addr)
              {       
                  BYTE retry=5;
              
                  if (direct==I2C_READ)
                      addr|=BIT0;
                  else
                      addr&=~BIT0;
              
                  while (retry--)
                  {   
                      if (msMiniLVDSi2c_Start()==FALSE)
                          continue;
              
                      if (msMiniLVDSi2c_SendByte(addr)==TRUE)
                          return TRUE;
              
                      msMiniLVDSi2c_Stop();
                      ForceDelay1ms(1);               //Delay1ms(1);
                  }
              
                  return FALSE;
              }
              
              #if VCOM_TYPE == VCOM_MAXIM             //120322 Modify
              Bool msMiniLVDSi2c_Write2Byte(BYTE add, WORD val)
              {
              #if 0
                  BYTE XDATA tempbuf;
                  tempbuf[0] = (BYTE)(val>>8);
                  tempbuf[1] = (BYTE)val;
              #else
                  BYTE XDATA tempbuf1, tempbuf2;
                  tempbuf1 = (BYTE)(val>>8);
                  tempbuf2 = (BYTE)val;
              #endif
                  if (msMiniLVDSi2c_MasterStart(I2C_WRITE, MINILVDSTCON_DEVICE) == FALSE)
                      return FALSE;
              #if 1//0
                  if (msMiniLVDSi2c_SendByte(add) == FALSE)
                  {
                      msMiniLVDSi2c_Stop();
                      return FALSE;
C51 COMPILER V9.01   MSMINILVDSI2C                                                         03/09/2023 15:39:13 PAGE 5   

                  }
              
                  if (msMiniLVDSi2c_SendByte(tempbuf1) == FALSE)
                  {
                      msMiniLVDSi2c_Stop();
                      return FALSE;
                  }
                  if (msMiniLVDSi2c_SendByte(tempbuf2) == FALSE)
                  {
                      msMiniLVDSi2c_Stop();
                      return FALSE;
                  }
              
                  msMiniLVDSi2c_Stop();
              
                  ForceDelay1ms(50); //yywang // PACKET2PACKET_PEROID     
              #endif
                  return TRUE;
              }
              
              Bool msMiniLVDSi2c_Read2Byte( BYTE add, WORD *val )
              {
                  if (msMiniLVDSi2c_MasterStart(I2C_WRITE, MINILVDSTCON_DEVICE) == FALSE)
                      return FALSE;
                  if (msMiniLVDSi2c_SendByte(add) == FALSE)
                  {
                      msMiniLVDSi2c_Stop();
                      return FALSE;
                  }
                  
                  if (msMiniLVDSi2c_MasterStart(I2C_READ, MINILVDSTCON_DEVICE) == FALSE)
                  {
                      msMiniLVDSi2c_Stop();
                      return FALSE;
                  }
              
                  *val= ((msMiniLVDSi2c_ReceiveByte(1)<<8)+msMiniLVDSi2c_ReceiveByte(0));
                  
                  msMiniLVDSi2c_Stop();
                  return TRUE;
              }
              
              WORD msReadMiniLVDSi2c_Vcom(void)
              {
                      WORD ucVcom=0;
              
                  msMiniLVDSi2c_Read2Byte(0x12, &ucVcom);
                
                  return ucVcom;
              }
              Bool msWriteMiniLVDSi2c_Vcom(WORD ucVcom)
              {    
                  if (msMiniLVDSi2c_Write2Byte(0x12, BIT14 | ucVcom) == TRUE)
                      return TRUE;
                  
                  return FALSE;
              }
              Bool msWriteMiniLVDSi2c_Vcom_DAC(WORD ucVcom)   //111103 Modify
              {    
                  if(msMiniLVDSi2c_Write2Byte(0x12, BIT15 | ucVcom) == TRUE)
                      return TRUE;
                  
C51 COMPILER V9.01   MSMINILVDSI2C                                                         03/09/2023 15:39:13 PAGE 6   

                  return FALSE;
              }
              #if 0
              WORD msReadMiniLVDSi2c_Vcom_DAC(void)
              {
                WORD ucVcom=0;
                
                  msMiniLVDSi2c_Read2Byte(0x12, &ucVcom);
                  
                  return ucVcom;
              }
              #endif
              
              #elif VCOM_TYPE == VCOM_SMIM
              
              Bool msMiniLVDSi2c_Write2Byte(BYTE add, WORD val)
              {
              #if 0
                  BYTE XDATA tempbuf;
                  tempbuf[0] = (BYTE)(val>>8);
                  tempbuf[1] = (BYTE)val;
              #else
                  BYTE XDATA tempbuf1, tempbuf2;
                  tempbuf1 = (BYTE)(val>>8);
                  tempbuf2 = (BYTE)val;
              #endif
                  if (msMiniLVDSi2c_MasterStart(I2C_WRITE, MINILVDSTCON_DEVICE) == FALSE)
                      return FALSE;
              #if 1//0
                  if (msMiniLVDSi2c_SendByte(add) == FALSE)
                  {
                      msMiniLVDSi2c_Stop();
                      return FALSE;
                  }
              
                  if (msMiniLVDSi2c_SendByte(tempbuf1) == FALSE)
                  {
                      msMiniLVDSi2c_Stop();
                      return FALSE;
                  }
                  if (msMiniLVDSi2c_SendByte(tempbuf2) == FALSE)
                  {
                      msMiniLVDSi2c_Stop();
                      return FALSE;
                  }
              
                  msMiniLVDSi2c_Stop();
              
                  ForceDelay1ms(50); //yywang // PACKET2PACKET_PEROID     
              #endif
                  return TRUE;
              }
              
              Bool msMiniLVDSi2c_Read2Byte( BYTE add, WORD *val )
              {
                  if (msMiniLVDSi2c_MasterStart(I2C_WRITE, MINILVDSTCON_DEVICE) == FALSE)
                      return FALSE;
                  if (msMiniLVDSi2c_SendByte(add) == FALSE)
                  {
                      msMiniLVDSi2c_Stop();
                      return FALSE;
                  }
C51 COMPILER V9.01   MSMINILVDSI2C                                                         03/09/2023 15:39:13 PAGE 7   

                  
                  if (msMiniLVDSi2c_MasterStart(I2C_READ, MINILVDSTCON_DEVICE) == FALSE)
                  {
                      msMiniLVDSi2c_Stop();
                      return FALSE;
                  }
              
                  *val= ((msMiniLVDSi2c_ReceiveByte(1)<<8)+msMiniLVDSi2c_ReceiveByte(0));
                  
                  msMiniLVDSi2c_Stop();
                  return TRUE;
              }
              
              WORD msReadMiniLVDSi2c_Vcom(void)
              {
                      WORD ucVcom=0;
                      
                      msMiniLVDSi2c_Write2Byte(0xFF, 0x0001);
                  msMiniLVDSi2c_Read2Byte(0x15, &ucVcom);
                
                  return ucVcom;
              }
              Bool msWriteMiniLVDSi2c_Vcom(WORD ucVcom)
              {    
              
                  msMiniLVDSi2c_Write2Byte(0x15, ucVcom);
                              
                  if (msMiniLVDSi2c_Write2Byte(0xFF, 0x0080)==TRUE)
                              return TRUE;
                      
                  return FALSE;
              }
              Bool msWriteMiniLVDSi2c_Vcom_DAC(WORD ucVcom)   //111103 Modify
              {    
                  if(msMiniLVDSi2c_Write2Byte(0x15, ucVcom) == TRUE)
                      return TRUE;
                  
                  return FALSE;
              }
              
              #elif VCOM_TYPE == VCOM_TPSIM
              
              Bool msMiniLVDSi2c_Write2Byte(BYTE add, WORD val)
              {
              #if 0
                  BYTE XDATA tempbuf;
                  tempbuf[0] = (BYTE)(val>>8);
                  tempbuf[1] = (BYTE)val;
              #else
                  BYTE XDATA tempbuf1, tempbuf2;
                  tempbuf1 = (BYTE)(val>>8);
                  tempbuf2 = (BYTE)val;
              #endif
                  if (msMiniLVDSi2c_MasterStart(I2C_WRITE, MINILVDSTCON_DEVICE) == FALSE)
                      return FALSE;
              #if 1//0
                  if (msMiniLVDSi2c_SendByte(add) == FALSE)
                  {
                      msMiniLVDSi2c_Stop();
                      return FALSE;
                  }
              
C51 COMPILER V9.01   MSMINILVDSI2C                                                         03/09/2023 15:39:13 PAGE 8   

                  if (msMiniLVDSi2c_SendByte(tempbuf1) == FALSE)
                  {
                      msMiniLVDSi2c_Stop();
                      return FALSE;
                  }
                  if (msMiniLVDSi2c_SendByte(tempbuf2) == FALSE)
                  {
                      msMiniLVDSi2c_Stop();
                      return FALSE;
                  }
              
                  msMiniLVDSi2c_Stop();
              
                  ForceDelay1ms(50); //yywang // PACKET2PACKET_PEROID     
              #endif
                  return TRUE;
              }
              
              Bool msMiniLVDSi2c_Read2Byte( BYTE add, WORD *val )
              {
                  if (msMiniLVDSi2c_MasterStart(I2C_WRITE, MINILVDSTCON_DEVICE) == FALSE)
                      return FALSE;
                  if (msMiniLVDSi2c_SendByte(add) == FALSE)
                  {
                      msMiniLVDSi2c_Stop();
                      return FALSE;
                  }
                  
                  if (msMiniLVDSi2c_MasterStart(I2C_READ, MINILVDSTCON_DEVICE) == FALSE)
                  {
                      msMiniLVDSi2c_Stop();
                      return FALSE;
                  }
              
                  *val= ((msMiniLVDSi2c_ReceiveByte(1)<<8)+msMiniLVDSi2c_ReceiveByte(0));
                  
                  msMiniLVDSi2c_Stop();
                  return TRUE;
              }
              
              WORD msReadMiniLVDSi2c_Vcom(void)
              {
                      WORD ucVcom=0;
                      
                      msMiniLVDSi2c_Write2Byte(0xFF, 0x0001);
                  msMiniLVDSi2c_Read2Byte(0x16, &ucVcom);
                
                  return ucVcom;
              }
              Bool msWriteMiniLVDSi2c_Vcom(WORD ucVcom)
              {    
              
                  msMiniLVDSi2c_Write2Byte(0x16, ucVcom);
                              
                  if (msMiniLVDSi2c_Write2Byte(0xFF, 0x0080)==TRUE)
                              return TRUE;
                      
                  return FALSE;
              }
              Bool msWriteMiniLVDSi2c_Vcom_DAC(WORD ucVcom)   //111103 Modify
              {    
                  if(msMiniLVDSi2c_Write2Byte(0x16, ucVcom) == TRUE)
C51 COMPILER V9.01   MSMINILVDSI2C                                                         03/09/2023 15:39:13 PAGE 9   

                      return TRUE;
                  
                  return FALSE;
              }
              
              #else
              Bool msMiniLVDSi2c_WriteByte(BYTE add, BYTE val)
              {
                  if (msMiniLVDSi2c_MasterStart(I2C_WRITE, MINILVDSTCON_DEVICE) == FALSE)
                      return FALSE;
              
                  if (msMiniLVDSi2c_SendByte(add) == FALSE)
                  {
                      msMiniLVDSi2c_Stop();
                      return FALSE;
                  }
              
                  if (msMiniLVDSi2c_SendByte(val) == FALSE)
                  {
                      msMiniLVDSi2c_Stop();
                      return FALSE;
                  }
              
                  msMiniLVDSi2c_Stop();
              
                  ForceDelay1ms(50); //yywang 
              
                  return TRUE;
              }
              
              Bool msMiniLVDSi2c_ReadByte( BYTE add, BYTE *val )
              {
                  if (msMiniLVDSi2c_MasterStart(I2C_WRITE, MINILVDSTCON_DEVICE) == FALSE)
                      return FALSE;
              
                  if (msMiniLVDSi2c_SendByte(add) == FALSE)
                  {
                      msMiniLVDSi2c_Stop();
                      return FALSE;
                  }
              
                  if (msMiniLVDSi2c_MasterStart(I2C_READ, MINILVDSTCON_DEVICE) == FALSE)
                  {
                      msMiniLVDSi2c_Stop();
                      return FALSE;
                  }
              
                  *val = msMiniLVDSi2c_ReceiveByte(0);
                  
                  msMiniLVDSi2c_Stop();
                  
                  return TRUE;
              }
              
              
              BYTE msReadMiniLVDSi2c_Vcom(void)
              {
                BYTE ucVcom=0;
                
                  msMiniLVDSi2c_WriteByte(0x02, 0x00);
              
                  msMiniLVDSi2c_ReadByte(0x00, &ucVcom);
C51 COMPILER V9.01   MSMINILVDSI2C                                                         03/09/2023 15:39:13 PAGE 10  

              
                  return ucVcom;
              }
              
              Bool msWriteMiniLVDSi2c_Vcom(BYTE ucVcom)
              {    
                  msMiniLVDSi2c_WriteByte(0x02, 0x00);
                  msMiniLVDSi2c_WriteByte(0x00, ucVcom);
                  
                  return TRUE;
              }
              Bool msWriteMiniLVDSi2c_Vcom_DAC(BYTE ucVcom)
              {    
                  msMiniLVDSi2c_WriteByte(0x02, 0x80);
                  msMiniLVDSi2c_WriteByte(0x00, ucVcom);
                  
                  return TRUE;
              }
              #endif
              #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   ----    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

C51 COMPILER V9.01   ISR                                                                   03/09/2023 15:38:59 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE ISR
OBJECT MODULE PLACED IN .\obj\isr.obj
COMPILER INVOKED BY: D:\Keil4\C51\BIN\C51.EXE ..\..\KERNEL\SYSTEM\isr.c OPTIMIZE(SIZE) BROWSE INCDIR(..\..\DRIVER\INC;..
                    -\..\KERNEL\SCALER\INC;..\..\KERNEL\SYSTEM\INC;..\..\LIB\INC;..\..\PANEL\INC;..\..\BOARD;..\..\DRIVER\INC;..\..\KERNEL\SY
                    -STEM\INC\AOC2011;..\..\DRIVER\extDEVICE\INC;..\..\MODEL;..\..\CONFIG;..\..\PANEL;..\..\UI\F_LOGO\INC;..\..\UI\HkcOsd\INC
                    -) DEFINE(ModelName=JRY_TESTBOARD_C_BOARD) DEBUG OBJECTEXTEND PRINT(.\list\isr.lst) OBJECT(.\obj\isr.obj)

line level    source

   1          #include "types.h"
   2          #include "board.h"
   3          #include "global.h"
   4          #include "power.h"
   5          #include "debug.h"
   6          #include "debugDef.h"
   7          #include "ddc2bi.h"
   8          #include "Menudef.h"
   9          #include "ms_reg.h"
  10          #include "Ms_rwreg.h"
  11          #include "GPIO_DEF.h"
  12          #include "mcu.h"
  13          
  14          
  15          #if ENABLE_DP_INPUT 
              #include "drvDPRxApp.h"
              #endif
  18          
  19          #if ENABLE_HDMI || ENABLE_FREESYNC
  20          #include "msHDMI.h"
  21          #endif
  22          #if MS_DAC
  23          #include "drvDAC.h"
  24          #endif
  25          #if 0//USEFLASH
              extern WORD xdata ucFlashSaveCount;
              #endif
  28          
  29          
  30          #if ENABLE_UART1
              #include "UartControl.h"
              #endif
  33          #if  ENABLE_ANDROID_IR  //131008 Modify
              #include "drv_Ir.h"
              #endif
  36          
  37          #if ENABLE_DisplayPortTX
              #include "drvDPTxApp.h"
              #endif
  40          
  41          #if ENABLE_FREESYNC
              extern xdata Bool bHDMIFreesyncChk;
              #endif
  44          #if ! EANBLE_NEW_DCR_Functing
              extern BYTE xdata DCRStepTransCnt; // 081205 dcr test
              #endif
  47          //#define ReSyncTick          255//54 // 0.2 Second for resynchorize dubug process
  48          #if EXT_TIMER0_1MS || (ENABLE_MENULOAD && ML_USE_INT)||EXT_TIMER0_1S    //111223 Modify
  49          #define EnableExt0Interrupt             1
  50          #define EnableTime0Interrupt        1
  51          #elif ENABLE_SW_DOUBLE_BUFFER
              #define EnableExt0Interrupt          1
C51 COMPILER V9.01   ISR                                                                   03/09/2023 15:38:59 PAGE 2   

              #define EnableTime0Interrupt        1
              #else
              #define EnableExt0Interrupt             0
              #define EnableTime0Interrupt        1
              #endif
  58          
  59          #if UseINT
  60          #define EnableExt1Interrupt             1
  61          #define EnableSerialPortInterrupt   1 // 0
  62          #else
              #define EnableExt1Interrupt             0
              #define EnableSerialPortInterrupt   1
              #endif
  66          
  67          #if ENABLE_UART1
              #define EnableSerialPortInterrupt1  1
              #else
  70          #define EnableSerialPortInterrupt1  0
  71          #endif
  72          
  73          
  74          #if  ENABLE_ANDROID_IR  //131008 Modify
              #define EnableTime1Interrupt        1
              #else
  77          #define EnableTime1Interrupt        0
  78          #endif
  79          
  80          #define EnableTime2Interrupt        0
  81          
  82          #if CHIP_ID == CHIP_TSUM2 || CHIP_ID == CHIP_TSUMC || CHIP_ID == CHIP_TSUMD || CHIP_ID == CHIP_TSUM9|| CHI
             -P_ID == CHIP_TSUMF
  83          #if ENABLE_MHL
              #include "DRVMHL.h"
              //extern xdata WORD g_u16S2PatchCnt;
              //extern BYTE xdata g_u16S2PatchCntFlag;
              //extern xdata WORD g_u16MHLHandlerCnt;
              //extern bit g_u16MHLHandlerCntFlag;
              #endif
  90          
  91          #if ENABLE_SW_DOUBLE_BUFFER
  92          extern XDATA StuSWDBCtrl SWDBCtrl;
  93          
  94          void IsrML(void)
  95          {
  96   1          SWDBCtrl.ucSWDB_Counter = 0;
  97   1          SWDBCtrl.ucSWDB_OnFire = 0;
  98   1          SWDBCtrl.ucSWDB_Num = 1;
  99   1          msRegs[REG_3C25] &=0x3F;
 100   1      }
 101          #endif
 102          
 103          #if 0
              void IsrBDMA(void)
              {      
                  if(_bit2_(msRegs[REG_3302]))
                  {
                      msRegs[REG_3302] = BIT2|BIT3;
                      msRegs[REG_12C4] = 0x00;
                      msRegs[REG_2080] = 0x27;
                  }
              }
              #endif
C51 COMPILER V9.01   ISR                                                                   03/09/2023 15:38:59 PAGE 3   

 114          #endif
 115          
 116          #if UseINT
 117          void MuteVideoAndAudio(void)
 118          {
 119   1      #if !ENABLE_ExpanderIO
 120   1      #if ENABLE_HDMI
 121   1          if( gScInfo.InputTmdsType == TMDS_HDMI )
 122   1          {
 123   2              hw_SetMute(); // for changed mode have "po-po"
 124   2          }
 125   1      #endif
 126   1      #endif
 127   1      #if ENABLE_DP_INPUT     //130603 william        
              #if AudioFunc 
                      if(CURRENT_INPUT_IS_DISPLAYPORT())
                      {
                          hw_SetMute();
                      }
              #endif
              #endif
 135   1      
 136   1      
 137   1          hw_ClrBlacklit();
 138   1      
 139   1          Set_InputTimingChangeFlag();
 140   1          Clr_ForcePowerSavingFlag();
 141   1          InputTimingStableCounter = 0;
 142   1          SrcFlags |= SyncLoss;
 143   1      }
 144          
 145          void IsrModeChangeCheck(void)
 146          {
 147   1          BYTE xdata ucBank = MEM_SCREAD_BYTE(0x00);
 148   1      #if ((ENABLE_RTE && CHIP_ID==CHIP_TSUMF))
                  bit INT_VsyncEdge;
              #endif
 151   1      
 152   1          MEM_SCWRITE_BYTE(0, 0); //bk0
 153   1      
 154   1          if (INT_STATUS_A_ISR((MEM_SCREAD_BYTE(SC0_CE))&(BIT4|BIT5|BIT6|BIT7)) || (INT_STATUS_B_ISR((MEM_SCREAD
             -_BYTE(SC0_CF))&(BIT2))))
 155   1          {
 156   2              INT_SCALER_A_ISR(0);//MEM_SCWRITE_BYTE(SC0_CE, 0); //disable INT
 157   2              INT_SCALER_B_ISR(0);//MEM_SCWRITE_BYTE(SC0_CF, 0); //disable INT
 158   2              INT_STATUS_CLEAR_ISR();
 159   2              if (!SyncLossState())
 160   2              {
 161   3                  MuteVideoAndAudio();
 162   3              }
 163   2          }
 164   1      #if 0//ENABLE_FREESYNC
                  else if (INT_STATUS_A_ISR((MEM_SCREAD_BYTE(SC0_CE))&BIT3))
                  {
                      MEM_SCWRITE_BYTE(SC0_CC,(MEM_SCREAD_BYTE(SC0_CC)&(~BIT3)));
                      if(IS_HDMI_FREESYNC_ISR())
                      {
                          if(bHDMIFreesyncChk)
                              MEM_SCWRITE_BYTE(SC0_E8,(MEM_SCREAD_BYTE(SC0_E8)&(~BIT1))|BIT0);    //Enable force P mode
                          bHDMIFreesyncChk = FALSE;
                      }
                  }
C51 COMPILER V9.01   ISR                                                                   03/09/2023 15:38:59 PAGE 4   

              #endif
 176   1      
 177   1      #if ( (ENABLE_RTE && CHIP_ID==CHIP_TSUMF))
                  INT_VsyncEdge = (Bool)(INT_STATUS_A_ISR(INT_VSYNC_EDGE));
                  if(INT_VsyncEdge)
                  {
                      INT_VsyncEdge = 0;
                      
              
              
                      MEM_SCWRITE_BYTE(SC0_CC,(~INT_VSYNC_EDGE));
                  }
              #endif
 188   1          
 189   1          MEM_SCWRITE_BYTE(0x00, ucBank);
 190   1      }
 191          #endif
 192          
 193          #if EXT_TIMER0_1S   // 2012-05-23
 194          void ms1SHandler( void )
 195          {
 196   1          g_oneSecondFlag=1;
 197   1          g_second++;
 198   1          if(g_second==60)
 199   1          {
 200   2              g_oneMinuteFlag=1;
 201   2              g_second=0;
 202   2              g_minute++;
 203   2              if(g_minute==60)
 204   2              {
 205   3                  g_minute=0;
 206   3                  g_hour++;
 207   3                  if(g_hour==24)
 208   3                      g_hour=0;
 209   3              }
 210   2          }
 211   1      }
 212          #endif
 213          
 214          #if EnableExt0Interrupt
 215          void EXT0Interrupt(void)interrupt 0
 216          {
 217   1              BYTE xdata ucStatus;
 218   1              ucStatus = msRegs[REG_2B10];
 219   1              
 220   1      #if ENABLE_MENULOAD && ML_USE_INT       //111223 Modify
                      if( ucStatus & _BIT5 )
                      {
                              extern BYTE xdata u8ML_Status;
                              u8ML_Status=msRegs[REG_3C27]&(ML_STS_BUSY|ML_STS_TRIG_ERR|ML_STS_CMD_ERR|ML_STS_DONE);
                              msRegs[REG_3C25]=msRegs[REG_3C25]&~(BIT7|BIT6); //disable ML
                      }
              #endif
 228   1      
 229   1              msRegs[REG_2B08] = ucStatus;
 230   1              msRegs[REG_2B08] = 0x00;
 231   1      
 232   1      
 233   1      #if CHIP_ID == CHIP_TSUM2 || CHIP_ID == CHIP_TSUMC || CHIP_ID == CHIP_TSUMD || CHIP_ID == CHIP_TSUM9|| CHI
             -P_ID == CHIP_TSUMF
 234   1      #if  ENABLE_SW_DOUBLE_BUFFER
 235   1          if(_bit5_(ucStatus))
C51 COMPILER V9.01   ISR                                                                   03/09/2023 15:38:59 PAGE 5   

 236   1              IsrML();
 237   1      #endif
 238   1      #endif
 239   1      
 240   1      #if EXT_TIMER0_1MS||EXT_TIMER0_1S
 241   1              if( ucStatus & _BIT0 )
 242   1              ms1SHandler();
 243   1      #endif
 244   1      
 245   1              IE0 = 0;
 246   1      }
 247          #endif
 248          #if EnableTime0Interrupt
 249          extern WORD ms_Counter;
 250          extern xdata BYTE ReSyncCounter;
 251          //extern BYTE Second;
 252          extern BYTE xdata OsdCounter;
 253          extern BYTE xdata HotKeyCounter;
 254          extern BYTE xdata PowerDownCounter;
 255          void Time0Interrupt(void)interrupt 1
 256          {
 257   1          TH0 = g_ucTimer0_TH0;
 258   1          TL0 = g_ucTimer0_TL0; // timer 1 counter
 259   1              
 260   1          ms_Counter--;
 261   1      
 262   1      #if 0  //nick add for checking timer correct or not
              if(ms_Counter%2)
              {
                  hw_SetGreenLed();
              }
              else
              {
                  hw_ClrGreenLed();
              }
              #endif
 272   1      
 273   1      #if ENABLE_DEBUG
                  if (ReSyncCounter)
                  {
                      ReSyncCounter--;
                  }
              #endif
 279   1          
 280   1          if(bDelayFlag)
 281   1          {
 282   2              if(-- DelayCounter == 0)
 283   2                  bDelayFlag = 0;
 284   2          }
 285   1      
 286   1               // if(TimeOutCounter)
 287   1                //    TimeOutCounter--;
 288   1         if( bTimeOutCounterFlag )
 289   1               if( --u16TimeOutCounter == 0 )
 290   1                       bTimeOutCounterFlag = 0;
 291   1      #if ENABLE_DP_INPUT
              #if DP_FastTraining&&(CHIP_ID==CHIP_TSUMU)      //#if CHIP_ID == CHIP_TSUMC             //130116_3 Henry For DC Off/O
             -n,Dp Source Can not Wake Up   //130912 nick
                  if(u16DPRxStableTimeout)
                     u16DPRxStableTimeout--;
              #endif
                          
C51 COMPILER V9.01   ISR                                                                   03/09/2023 15:38:59 PAGE 6   

              #if (CHIP_ID==CHIP_TSUMC ||CHIP_ID==CHIP_TSUMD||CHIP_ID == CHIP_TSUM9|| CHIP_ID == CHIP_TSUMF)  //130912 ni
             -ck
                  if( bDPRxStableTimeoutFlag )
                      if( --u16DPRxStableTimeout == 0 )
                          bDPRxStableTimeoutFlag = 0;
              #endif
              
              #if DPCTS
              #if DP_FastTraining&&(CHIP_ID==CHIP_TSUMC ||CHIP_ID==CHIP_TSUMD||CHIP_ID == CHIP_TSUM9|| CHIP_ID == CHIP_T
             -SUMF)        //130912 nick
                          if( bCDR_HPDCntFlag )
                              if( --u16CDR_HPDCnt == 0 )
                                  bCDR_HPDCntFlag = 0;
              
                              if( bSkew_HPDCntFlag )
                                  if( --u16Skew_HPDCnt == 0 )
                                      bSkew_HPDCntFlag = 0;
              #endif          
              #if (CHIP_ID==CHIP_TSUMU)       //130912 nick
                      if(CDR_HPDCnt)
                         CDR_HPDCnt--;
              
                      if(Skew_HPDCnt)
                         Skew_HPDCnt--;
               #endif
              
              #if (CHIP_ID==CHIP_TSUM9 || CHIP_ID==CHIP_TSUMF)
                       if(gDPInfo.bPacketTimer )
                                 gDPInfo.bPacketTimer --;
              #endif
              
              #if CHIP_ID == CHIP_TSUMC||CHIP_ID == CHIP_TSUMD||CHIP_ID == CHIP_TSUM9|| CHIP_ID == CHIP_TSUMF //130912 n
             -ick
              #if 1
               if( bAudio_BWCntFlag )
                   if( --u16Audio_BWCnt == 0 )
                       bAudio_BWCntFlag = 0;
              #else
                   if(Audio_BWCnt)           //20130716
                          Audio_BWCnt--;   
              #endif  
              #endif        
              #endif
              #endif
 338   1      #if ENABLE_TIME_MEASUREMENT   //need enable this if test Timer0
                      if( g_u16TimeMeasurementCounter )
                              g_u16TimeMeasurementCounter--;
              #endif
 342   1      
 343   1      #if MS_DAC && (CHIP_ID==CHIP_TSUMC ||CHIP_ID==CHIP_TSUMD||CHIP_ID == CHIP_TSUM9|| CHIP_ID == CHIP_TSUMF)
 344   1      #if InitialDACByISR
 345   1                                      if( bDAC_DePopCountFlag )
 346   1                                      {
 347   2                                              if( (--w16DAC_DePopCounter) == 0 )
 348   2                                              {
 349   3                                                      bDAC_DePopCountFlag = 0;
 350   3                                                      bDAC_DePopFlag = 1;
 351   3                                              }
 352   2                                      }
 353   1      #endif
 354   1      #endif
 355   1      
C51 COMPILER V9.01   ISR                                                                   03/09/2023 15:38:59 PAGE 7   

 356   1          if(!g_bMcuPMClock) // system runs at normal speed
 357   1          {
 358   2              if(bPanelDelayFlag)
 359   2              {
 360   3                  if(--PanelOffOnDelayCntr == 0)
 361   3                      bPanelDelayFlag = 0;
 362   3              }
 363   2      
 364   2      #if ENABLE_MHL
                  #if CHIP_ID == CHIP_TSUM2
                      if(g_u16S2PatchCntFlag)
                      {
                          if(--g_u16S2PatchCnt == 0)
                              g_u16S2PatchCntFlag = 0;
                      }
              
                      if(g_u16MHLHandlerCntFlag)
                      {
                          if(--g_u16MHLHandlerCnt == 0)
                              g_u16MHLHandlerCntFlag = 0;
                      }
                  #elif (CHIP_ID == CHIP_TSUMC)||(CHIP_ID == CHIP_TSUMD||CHIP_ID == CHIP_TSUM9|| CHIP_ID == CHIP_TSUMF)
                      mapi_mhl_CbusTimerInterrupt();
                  #endif
              #endif
 381   2      
 382   2      
 383   2          }
 384   1      
 385   1          if (ms_Counter == 0)
 386   1          {
 387   2      
 388   2              
 389   2              Set_SecondFlag();
 390   2              ms_Counter=SystemTick;
 391   2      
 392   2          }
 393   1      
 394   1          if((ms_Counter % 10) == 0)
 395   1          {
 396   2              Set_ms10Flag();
 397   2      
 398   2      #if ENABLE_MHL_COUNT
                      if(MHLActionCount)
                          MHLActionCount++;
              #endif
 402   2      
 403   2              if((ms_Counter % 50) == 0)
 404   2              {
 405   3                  Set_ms50Flag();
 406   3      
 407   3      #if CHIP_ID == CHIP_TSUM2
                          if(FPLLTimeoutCounter)
                              FPLLTimeoutCounter--;
              #endif
 411   3      
 412   3      #if  EANBLE_NEW_DCR_Functing
 413   3                        if(( ms_Counter % 100 ) == 0 )
 414   3                              {
 415   4                                      if ( DCRStepTransCnt )
 416   4                                      {
 417   5                               DCRStepTransCnt --;
C51 COMPILER V9.01   ISR                                                                   03/09/2023 15:38:59 PAGE 8   

 418   5                                       }      
 419   4                              }
 420   3      #endif
 421   3      
 422   3                  
 423   3      #if 0//ENABLE_FREESYNC
                          if(( ms_Counter % 250 ) == 0 )
                          {
                              Set_ms250Flag();
                          }
              #endif
 429   3                  if ((ms_Counter % 500) == 0)
 430   3                  {
 431   4                      Set_ms500Flag();
 432   4                  }
 433   3              }
 434   2          }
 435   1          
 436   1          if(TF0)
 437   1          {
 438   2              TH0 = g_ucTimer0_TH0;
 439   2              TL0 = g_ucTimer0_TL0; // timer 1 counter
 440   2          }
 441   1      
 442   1          TF0 = 0; // timer 1 flag
 443   1      }
 444          #endif
 445          #if EnableExt1Interrupt
 446          void EXT1Interrupt(void)interrupt 2
 447          {
 448   1          BYTE xdata ucBank = MEM_SCREAD_BYTE(0x00);       //110926 Rick add to store the current bank - Verify 
             -A036, A039
 449   1      
 450   1      
 451   1      #if (ENABLE_DP_INPUT&& ((CHIP_ID == CHIP_TSUMC)||(CHIP_ID == CHIP_TSUMD)||(CHIP_ID == CHIP_TSUM9)||(CHIP_I
             -D == CHIP_TSUMF)))
                  if((_bit2_(msRegs[REG_2B2A]))||(_bit3_(msRegs[REG_2B2A])))
                  {
                          DPISR_AUX0();
                  }
              #endif
 457   1      
 458   1      
 459   1      #if (CHIP_ID == CHIP_TSUMC)||(CHIP_ID == CHIP_TSUMD) ||(CHIP_ID == CHIP_TSUM9)||(CHIP_ID == CHIP_TSUMF)
 460   1      
 461   1          if(_bit7_(msRegs[REG_2B29]))
 462   1          {
 463   2                 TMDSISR();
 464   2      #if ENABLE_DP_INPUT
                         DPISR();
              #endif
 467   2          }
 468   1      
 469   1      #if ENABLE_MHL
                  if(_bit0_(msRegs[REG_2B2A]))
                  {
                      mapi_mhl_IsrHandler();
                  }
              
              #endif
 476   1      
 477   1      #endif
C51 COMPILER V9.01   ISR                                                                   03/09/2023 15:38:59 PAGE 9   

 478   1      
 479   1      #if CHIP_ID == CHIP_TSUMU
              #if ENABLE_DP_INPUT
                      if(_bit6_(msRegs[REG_2B29])) { DPISR(); }       // read status
              #endif
              
              #if ENABLE_DisplayPortTX
                  if(_bit7_(msRegs[REG_2B29])) { DPISR_TX(); }   // read status
              #endif
              
              #endif
 489   1      
 490   1              
 491   1          if( INT_STATUS_D2B_ISR() )  //if( DDC_MCCS_IRQ_DET() )
 492   1          {
 493   2              ISR_DDC2Bi();
 494   2          }
 495   1      
 496   1      #if UseINT
 497   1          if(INT_STATUS_DISP_ISR())
 498   1          {
 499   2              IsrModeChangeCheck();
 500   2          }
 501   1      #endif
 502   1          #if 0
              #if CHIP_ID == CHIP_TSUM2 || CHIP_ID == CHIP_TSUMC||CHIP_ID == CHIP_TSUM9||CHIP_ID == CHIP_TSUMF
                      if(_bit0_(msRegs[REG_2B2A]))
                          IsrBDMA();
              #elif CHIP_ID == CHIP_TSUMD
                  if(_bit5_(msRegs[REG_2B2A]))
                  {
                      IsrBDMA();
                  }
                  #endif
              #endif
 513   1      
 514   1      #if ENABLE_ANDROID_IR   //131008 Modify
              {
                  BYTE  final_status;                 // use idata to speedup
                  final_status = msRegs[REG_2B29];    // read status
                  if(IR_PinStatus(final_status))
                  {
                      IR_INT1();
                  }
                  msRegs[REG_2B29] = final_status;    // clear status
                  msRegs[REG_2B29] = 0x00;
              }
              #endif
 526   1      
 527   1      
 528   1          MEM_SCWRITE_BYTE(0x00, ucBank);
 529   1          IE1 = 0;
 530   1          //  EX1=1;
 531   1      }
 532          #endif
 533          
 534          
 535          #if EnableTime1Interrupt
              void Time1Interrupt( void ) interrupt 3
              {
              #if 0
                          BYTE test;
C51 COMPILER V9.01   ISR                                                                   03/09/2023 15:38:59 PAGE 10  

                          test++;
                      
                          if(test%2)
                              hw_SetDDC_WP();
                          else
                              hw_ClrDDC_WP();
              #endif
              
                  TH1 = Timer1_TH1;  //200us reload
                  TL1 = Timer1_TL1;  //200us reload   
              
              #if ENABLE_ANDROID_IR   //131008 Modify
                  if(IRstateHighCount > 32)
                  {
                      return;
                  }
              
                  if(IR_Pin)  //high
                      IRstateHighCount++;
                  else        
                      IRstateLowCount++;      
              
                  if(TF1)
                  {
                      TH1=Timer1_TH1;  //200us reload
                      TL1=Timer1_TL1;  //200us reload 
                  }
              
                  TF1 = 0;
              #endif
              #if ENABLE_TIME_MEASUREMENT  //need enable this if test Timer1
                      if(bTimeMeasurementFlag)
                      {
                              if(--g_u16TimeMeasurementCounter == 0)
                                      bTimeMeasurementFlag = 0;
                      }
              #endif
              
              }
              #endif
 580          
 581          
 582          #if EnableSerialPortInterrupt
 583          
 584          
 585          void SerialPortInterrupt(void)interrupt 4
 586              {
 587   1              BYTE xdata sioData;
 588   1      
 589   1              if( RI )
 590   1              {
 591   2                  RI = 0;
 592   2                  sioData = SBUF;
 593   2                  if( SIORxIndex < _UART_BUFFER_LENGTH_ )
 594   2                  {
 595   3                      ReSyncCounter = ReSyncTick;
 596   3                      SIORxBuffer[SIORxIndex++] = sioData;
 597   3                  }
 598   2              }
 599   1      
 600   1              if( TI )
 601   1              {
C51 COMPILER V9.01   ISR                                                                   03/09/2023 15:38:59 PAGE 11  

 602   2                  TI = 0;
 603   2                  TI0_FLAG = 1;
 604   2              }
 605   1      }
 606          
 607          
 608          #endif
 609          
 610          
 611          
 612          #if EnableTime2Interrupt
                  void Time2Interrupt(void)interrupt 5
                  {
                      TF2 = 0;
                  }
              #endif
 618          
 619          
 620          #if EnableSerialPortInterrupt1
              
              #if ENABLE_UART_CONTROL
              
              #define UART1UseChecksum                0
              void SerialPortInterrupt1( void ) interrupt 16
                  {
                      BYTE sioData;
                      if( S1CON & RI1)
                      {
                          S1CON &= ~RI1;    // clear RI1
                          sioData = S1BUF;        
                          if(rxARMUartIndex<(_ARM_UART_CMD_BUFFER_LENGTH_-1))
                          {
                                if(rxARMUartIndex==0)
                                {
                                    AndroidRxCounter = 2;
                                    }
                              rxARMUartBuffer[rxARMUartIndex++]=sioData;
                          }
                      #if 0   
                          switch(rxARMUartStatus)
                          {
                              case ARM_UART_IDLE:
                                  rxARMUartIndex=0;
                                  Checksum = sioData; // 20121101 ChunHan add
                                  rxARMUartBuffer[rxARMUartIndex++]=sioData;
                                  rxARMUartStatus=ARM_START_RECV;
                                  AndroidRxCounter = 3;
                              break;
                  
                              case ARM_START_RECV:
                              Checksum ^= sioData;    // 20121101 ChunHan add
                              if(rxARMUartIndex>(_ARM_UART_CMD_BUFFER_LENGTH_-1))
                              {
                                  rxARMUartStatus=ARM_UART_IDLE;
                                  break;
                              }
                              rxARMUartBuffer[rxARMUartIndex++]=sioData;
                              if(rxARMUartIndex>((ARM_UART_FIELD_PKTSIZE& ~DDC2Bi_CONTROL_STATUS_FLAG)+3))    // 2012110
             -1 ChunHan modify
                              {
                                  rxARMUartStatus=ARM_UART_IDLE;
                                  rxARMUartIndex=0;
C51 COMPILER V9.01   ISR                                                                   03/09/2023 15:38:59 PAGE 12  

                                      rxARMUartFlag=1;
                              }
                              else if((rxARMUartIndex>(rxARMUartBuffer[2]+2) )&& ((rxARMUartBuffer[0]+ rxARMUartBuffer[1
             -])==0xFF))
                              {
                                  rxARMUartStatus=ARM_UART_IDLE;
                                  rxARMUartIndex=0;
                                  rxARMUartFlag=1;
                              }
                              else
                                  AndroidRxCounter = 3;
                  
                              break;
                  
                              default:
                                      rxARMUartStatus=ARM_UART_IDLE;
                                      rxARMUartIndex=0;
                  
                              break;
                          }
              #endif
                  
                      }
                      if( S1CON & TI1 )     // check TI1;
                      {
                          S1CON &= ~TI1;    // clear TI1
                          TI1_FLAG = 1;
                      }
                  }
              
              #else
              void SerialPortInterrupt1( void ) interrupt 16
              {
                  // SFR: 0x9B
                  // s1con        [7]: 0:9-bit        1: 8-bit
                  //              [6]: not used
                  //              [5]: multiple processor enable
                  //              [4]: reception enable
                  //              [3]: tb81
                  //              [2]: rb81
                  //              [1]: ti1
                  //              [0]: ri1
              
                      BYTE ucTmp;
              
                      if( S1CON & RI1 )     // check RI1;
                      {
                              S1CON &= ~RI1;    // clear RI1
                              ucTmp = S1BUF;
                              #if ENABLE_DEBUG
                              if( SIORxIndex < _UART_BUFFER_LENGTH_  ) // Protect buffer overflow
                              {
                                      ReSyncCounter = ReSyncTick;
                                      SIORxBuffer[SIORxIndex++] = ucTmp; // recieve byte
                              }
                              #endif
                      }
                      if( S1CON & TI1 )     // check TI1;
                      {
                              S1CON &= ~TI1;    // clear TI1
                              TI1_FLAG = 1;
                      }
C51 COMPILER V9.01   ISR                                                                   03/09/2023 15:38:59 PAGE 13  

              }
              
              #endif
              
              #endif
 729          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    695    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----       4
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

C51 COMPILER V9.01   MSHDMI                                                                03/09/2023 15:39:03 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE MSHDMI
OBJECT MODULE PLACED IN .\obj\msHDMI.obj
COMPILER INVOKED BY: D:\Keil4\C51\BIN\C51.EXE ..\..\KERNEL\SCALER\msHDMI.c OPTIMIZE(SIZE) BROWSE INCDIR(..\..\DRIVER\INC
                    -;..\..\KERNEL\SCALER\INC;..\..\KERNEL\SYSTEM\INC;..\..\LIB\INC;..\..\PANEL\INC;..\..\BOARD;..\..\DRIVER\INC;..\..\KERNEL
                    -\SYSTEM\INC\AOC2011;..\..\DRIVER\extDEVICE\INC;..\..\MODEL;..\..\CONFIG;..\..\PANEL;..\..\UI\F_LOGO\INC;..\..\UI\HkcOsd\
                    -INC) DEFINE(ModelName=JRY_TESTBOARD_C_BOARD) DEBUG OBJECTEXTEND PRINT(.\list\msHDMI.lst) OBJECT(.\obj\msHDMI.obj)

line level    source

   1          #ifndef _MSHDMI_C_
   2          #define _MSHDMI_C_
   3          #include "types.h"
   4          #include "board.h"
   5          #include "Global.h"
   6          #include "Adjust.h"
   7          #include "ms_Reg.h"
   8          #include "ms_rwreg.h"
   9          #include "msHDMI.h"
  10          #include "Debug.h"
  11          #include <math.h>
  12          
  13          #include "misc.h"
  14          #include "GPIO_DEF.h"
  15          
  16          #if  ENABLE_HDMI_1_4
              #include "msScaler.h"
              #endif
  19          #if ENABLE_RTE
              #include "drvmsovd.h"
              #endif
  22          
  23          #if ENABLE_HDMI
  24          
  25          extern void mStar_SetUserPref(void);
  26          
  27          #define HDMI_DEBUG   0
  28          #if ENABLE_DEBUG &&HDMI_DEBUG
              #define HDMI_printData(str, value)   printData(str, value)
              #define HDMI_printMsg(str)           printMsg(str)
              #else
  32          #define HDMI_printData(str, value)
  33          #define HDMI_printMsg(str)
  34          #endif
  35          
  36          
  37          void mstar_HDMIInitialVariable( void )
  38          {
  39   1          gScInfo.InputColor = INPUT_RGB;
  40   1          gScInfo.InputColorimetry = YUV_Colorimetry_ITU601;
  41   1          gScInfo.InputSource = INPUT_TMDS_A;
  42   1          gScInfo.InputTmdsType = TMDS_DVI;
  43   1          gScInfo.ColorChanged = 0;
  44   1          gScInfo.ModeChange = 0;
  45   1          gScInfo.wAviPktLossCnt = 0;
  46   1          gScInfo.InputPacketStatus = 0;
  47   1      #if ENABLE_HDMI_1_4
                  gScInfo.NoVsPktCnt = 0;
              #endif
  50   1          gScInfo.AudioOffDebunce = 0;
  51   1          gScInfo.InputPacketError = 0;
  52   1          gScInfo.InputVideoMode = 16; // check here
C51 COMPILER V9.01   MSHDMI                                                                03/09/2023 15:39:03 PAGE 2   

  53   1          gScInfo.InputAVIInfoReceived = 0;
  54   1      #if ENABLE_FREESYNC
                  gScInfo.InputSPDInfoReceived = 0;
              #endif    
  57   1          gScInfo.OutputAudioState = HDMI_AUDIO_OFF; //Mute
  58   1          gScInfo.OutputDataState = HDMI_DATA_OUTPUT_OFF;
  59   1      #if ENABLE_HDMI_SW_CTS_STABLE
                  gScInfo.InputCTSValue = 0;
                  gScInfo.OutputAudioCnt = AudioDeBounce;
              #endif
  63   1          gScInfo.cs0 = 0;
  64   1      #if ENABLE_CTS_INT && ENABLE_CTSN_FILTER        //130814 jb
  65   1              gScInfo.ucAudioErrorEvents.bAVMUTE = 0;
  66   1      #endif
  67   1      #if  0
                  CSpcPollingCounter = 0;
              #endif
  70   1      }
  71          
  72          void mstar_HDMIInitialAudio( void )
  73          {
  74   1          drv_mstar_HDMIInitialAudio();
  75   1      }
  76          
  77          void mstar_HDMIHandler( void )
  78          {
  79   1          mstar_MonitorHDMI();//2这是主要的流程
  80   1          mstar_HDMIHandleColor();
  81   1          mstar_HDMIHandleMode();
  82   1      }
  83          
  84          
  85          void mstar_HDMIRst( BYTE rst )
  86          {
  87   1          drv_mstar_HDMIRst(rst);
  88   1      }
  89          
  90          void mstar_HDMIHandleMode( void )
  91          {
  92   1          //BYTE    temp;
  93   1          if( gScInfo.ModeChange )
  94   1          {
  95   2              gScInfo.ModeChange = 0;
  96   2              Set_InputTimingChangeFlag();
  97   2              HDMI_printData( "TMDS mode is=%d", gScInfo.InputTmdsType );
  98   2          }
  99   1      }
 100          void mstar_HDMIHandleColor( void )
 101          {
 102   1          if( gScInfo.ColorChanged )
 103   1          {
 104   2              gScInfo.ColorChanged = 0;
 105   2              mStar_SetUserPref();
 106   2              HDMI_printData( "Handle HDMI CSC%d", gScInfo.InputColor );
 107   2          }
 108   1      }
 109          #if  0
              void mstar_HDMIResetColorSpace( void )
              {
                  BYTE temp, reg_bank;
              
              
C51 COMPILER V9.01   MSHDMI                                                                03/09/2023 15:39:03 PAGE 3   

                  HDMI_printMsg( "HDMIResetColorSpace ");
              
                  reg_bank = msReadByte( BK0_00 );
                  msWriteByte( BK0_00, REGBANK0 );
              
                  if( msReadByte( BK0_5C )&BIT3 )
                  {
                      temp = msReadByte( BK0_5A ) | BIT7 | BIT6;
                      msWriteByte( BK0_5A, temp );
                  }
                  temp = msReadByte( BK0_02 ) & ( ~BIT3 );
                  msWriteByte( BK0_02, temp );
                  SetMainWinVideoDomain( INPUT_RGB );     //MainWin Color Space Change YUV -> RGB
                  msWriteByte( BK0_00, reg_bank );
              }
              #endif
 131          void mstar_MonitorHDMI( void )
 132          {
 133   1          BYTE temp, curr_color;
 134   1      
 135   1          if( HdmiPollingCounter == 0 )
 136   1          {
 137   2              HdmiPollingCounter = 20;
 138   2      
 139   2      
 140   2              if(CURRENT_INPUT_IS_TMDS())//( SrcInputType == Input_Digital || SrcInputType == Input_Digital2 )
 141   2              {
 142   3                  if( SrcFlags&( SyncLoss | bUnsupportMode ) ) // unsupport mode
 143   3                  {
 144   4                      if( gScInfo.OutputAudioState != HDMI_AUDIO_OFF )
 145   4                          mstar_HDMIAudioMute( HDMI_AUDIO_OFF ); // mute audio
 146   4                  }
 147   3                  else if( InputTimingStableFlag )
 148   3                  {
 149   4      
 150   4                      temp = mstar_HDMITmdsGetType();
 151   4      
 152   4                      if( temp != gScInfo.InputTmdsType )
 153   4                      {
 154   5                          gScInfo.InputTmdsType = temp;
 155   5                          gScInfo.InputPacketStatus = 0;
 156   5                         gScInfo.ModeChange = 1;
 157   5                          return;
 158   5                      }
 159   4      
 160   4                      // 120604 coding modified for reading packet status is unnecessary for DVI mode.
 161   4                      if(temp == TMDS_DVI)
 162   4                      {
 163   5                          mstar_HDMIRst(Reset_HDMIStatus);
 164   5                          return;
 165   5                      }
 166   4      
 167   4                  mstar_HDMIGetPktStatus();
 168   4                  mstar_HDMICheckAudio();
 169   4                  mstar_HDMIAutoEQProc();
 170   4      
 171   4                #if ENABLE_HDMI_1_4
                              msHDMI_Check_3D_Mode_Chg(1);
                              if(InputTimingChangeFlag)
                                  return;
                        #endif
 176   4                  
C51 COMPILER V9.01   MSHDMI                                                                03/09/2023 15:39:03 PAGE 4   

 177   4                  #if (ENABLE_CTS_INT && (ENABLE_CTSN_FILTER || ENABLE_AUDIO_AUTO_MUTE || ENABLE_AUDIO_AUTO_FADI
             -NG))
 178   4                      CheckAudioErrorStatus();
 179   4                  #endif
 180   4      
 181   4                      if( gScInfo.InputPacketStatus & BIT3 )
 182   4                      {
 183   5                          gScInfo.wAviPktLossCnt = 0;
 184   5                          curr_color = mstar_HDMIPacketColor();
 185   5      
 186   5                          if( curr_color != gScInfo.InputColor )
 187   5                          {                       
 188   6                              gScInfo.InputColor = curr_color;
 189   6                              gScInfo.ColorChanged = 1;
 190   6                              if(curr_color == INPUT_RGB)
 191   6                                  InputColorFormat = INPUTCOLOR_RGB;
 192   6                              else
 193   6                                  InputColorFormat = INPUTCOLOR_YUV;
 194   6                          }
 195   5                      }
 196   4                      else
 197   4                      {
 198   5                          if( gScInfo.wAviPktLossCnt >= AviPktLossBound )
 199   5                          {
 200   6                              if( gScInfo.InputColor != INPUT_RGB )
 201   6                              {
 202   7                                  gScInfo.InputColor = INPUT_RGB;
 203   7                                  InputColorFormat = INPUTCOLOR_RGB;
 204   7                                  mstar_HDMIRst(Reset_Color);
 205   7                                  gScInfo.ColorChanged = 1;
 206   7                              }
 207   6                          }
 208   5                      }
 209   4                      
 210   4                  }
 211   3              }
 212   2          }
 213   1      }
 214          //BYTE xdata bAudioInputStatus;
 215          #message "Please check the audio"
*** MESSAGE C320 IN LINE 215 OF ..\..\KERNEL\SCALER\msHDMI.c: "Please check the audio"
 216          void mstar_HDMICheckAudio( void )
 217          {
 218   1          BYTE temp;
 219   1      #if ENABLE_HDMI_SW_AUDCLK_CHECK
                  BYTE ucCurInFreq;
              #endif
 222   1      
 223   1          if( (gScInfo.InputPacketError &( BIT5 | BIT4 )) )//|| gScInfo.cs0 & BIT6 ) //audio sample error
 224   1          {
 225   2              temp = HDMI_AUDIO_OFF;
 226   2          }
 227   1          else if(( gScInfo.InputPacketStatus&( BIT6 | BIT5 ) ) == ( BIT6 | BIT5 ) )
 228   1          {
 229   2             /* if( (bAudioInputStatus)&&(UserPrefVolume == 0 || UserPrefMuteState))
 230   2                  temp = HDMI_AUDIO_OFF;
 231   2              else
 232   2              */
 233   2              {
 234   3                  if( gScInfo.OutputDataState == HDMI_DATA_OUTPUT_ON )
 235   3                      temp = HDMI_AUDIO_ON;
 236   3                  else
C51 COMPILER V9.01   MSHDMI                                                                03/09/2023 15:39:03 PAGE 5   

 237   3                      temp = HDMI_AUDIO_OFF;
 238   3              }
 239   2      
 240   2      #if ENABLE_HDMI_SW_CTS_STABLE
                      if( gScInfo.OutputAudioCnt ) // && gScInfo.OutputAudioState==HDMI_AUDIO_ON)    // Check CTS Value 
             -Stable
                          temp = HDMI_AUDIO_OFF;
              #endif
 244   2          }
 245   1      
 246   1          else
 247   1              temp = HDMI_AUDIO_OFF;
 248   1      
 249   1          if( gScInfo.OutputAudioState == HDMI_AUDIO_ON && temp == HDMI_AUDIO_OFF )
 250   1          {
 251   2              if( ++gScInfo.AudioOffDebunce < 20 )
 252   2                  return ;
 253   2          }
 254   1          else
 255   1              gScInfo.AudioOffDebunce = 0;
 256   1      #if ENABLE_HDMI_SW_AUDCLK_CHECK// 20080403 audio clock over spec
                  ucCurInFreq = mstar_HDMICheckAudioFreq();
                  if( temp == HDMI_AUDIO_ON )
                  {
                      if(( ucCurInFreq > AUD_FREQ_ERROR ) )
                      {
                          if( ucCurInFreq != gScInfo.CurOutAudFreq )
                          {
                              if( ++gScInfo.FreqStableDebunce > 1 ) // > "1" this value can be adjust
                              {
                                  gScInfo.CurOutAudFreq = ucCurInFreq;
                                  mstar_SetAudioClockLock( TRUE ); // chip w          
                              }
                          }
                          else
                              gScInfo.FreqStableDebunce = 0;
                      }
                      else
                      {
                          if( ucCurInFreq != gScInfo.CurOutAudFreq )
                          {
                              if( ++gScInfo.FreqStableDebunce > 3 )
                              {
                                  HDMI_printData( "--Input Audio Freq Error[%d]--", gScInfo.CurOutAudFreq );
                                  gScInfo.CurOutAudFreq = ucCurInFreq;
                                  if( temp == HDMI_AUDIO_ON )
                                      temp = HDMI_AUDIO_OFF;
                              }
                          }
                          else
                              gScInfo.FreqStableDebunce = 0;
                      }
                  }
              #endif
 290   1      
 291   1          if( temp != gScInfo.OutputAudioState )
 292   1          {
 293   2              mstar_HDMIAudioMute( temp );
 294   2          }
 295   1      }
 296          
 297          BYTE mstar_HDMIPacketColor( void )
C51 COMPILER V9.01   MSHDMI                                                                03/09/2023 15:39:03 PAGE 6   

 298          {
 299   1          return drv_mstar_HDMIPacketColor();
 300   1      }
 301          
 302          
 303          void mstar_HDMIAudioMute( BYTE sw )
 304          {
 305   1          drv_mstar_HDMIAudioMute(sw);
 306   1      }
 307          
 308          void mstar_HDMIGetPktStatus( void )
 309          {
 310   1          drv_mstar_HDMIGetPktStatus();
 311   1      }
 312          #if (ENABLE_FREESYNC&&ENABLE_HDMI)
              Bool mstar_HDMIGetFreeSyncFlag( void )
              {
              #if 1
                  if(gScInfo.InputPacketStatus==0) //170118 Test
                      {
                              mstar_HDMIGetPktStatus();
                      }
                      
                  if(gScInfo.InputSPDInfoReceived)
                      {
                         return drv_mstar_HDMIGetFreeSyncFlag();              
                      }
                  else 
                      return FALSE;
              
              #else
                  if(gScInfo.InputSPDInfoReceived)
                      return drv_mstar_HDMIGetFreeSyncFlag();
                  else 
                      return FALSE;
              #endif  
              }
              #endif
 336          
 337          void mstar_HDMIAutoEQProc(void)
 338          {
 339   1          drv_mstar_HDMIAutoEQProc();
 340   1      }
 341          
 342          BYTE mstar_HDMITmdsGetType( void )
 343          {
 344   1          return drv_mstar_HDMITmdsGetType();
 345   1      }
 346          
 347          #if ENABLE_CTS_INT
 348          #if ENABLE_CTSN_FILTER
 349          /*
 350          void EnableCTSNFileterFunction( void )
 351          {
 352              drv_EnableCTSNFileterFunction();
 353          }
 354          
 355          void CheckCTSNFilterFunction( void )
 356          {
 357              drv_CheckCTSNFilterFunction();
 358          }
 359          */
C51 COMPILER V9.01   MSHDMI                                                                03/09/2023 15:39:03 PAGE 7   

 360          #else
              void EnableCTSFileterFunction( void )
              {
                  drv_EnableCTSFileterFunction();
              }
              
              void CheckCTSFilterFunction( void )
              {
                  drv_CheckCTSFilterFunction();
              }
              #endif
 371          #endif
 372          #if ENABLE_HDMI_SW_AUDCLK_CHECK   // 20080403 audio clock over spec
              //*******************************************************************
              // Function Name: mstar_HDMICheckAudioFreq
              // Decscription: N/CTS = (128 fs)/(TMDS_Clk)
              //*******************************************************************
              AudioFreqType mstar_HDMICheckAudioFreq( void )
              //BYTE mstar_HDMICheckAudioFreq(void)
              {
                  return drv_mstar_HDMICheckAudioFreq();
              }
              
              void mstar_SetAudioClockLock( Bool bLock )
              {
                  drv_mstar_SetAudioClockLock(bLock);
              }
              #endif // #if EN_HDMI_SW_AUDCLK_CHECK
 388          
 389          #if ENABLE_AUDIO_AUTO_MUTE || ENABLE_AUDIO_AUTO_FADING || ENABLE_CTSN_FILTER
 390          
 391          ///////////////////////////////////////////////////////////////////////////////
 392          //     Audio mute/fading events:
 393          //     [0]: HDMI audio sample error.
 394          //     [1]: HDMI audio sample parity error.
 395          //     [2]: HDMI non-PCM.
 396          //     [3]: HDMI AVMUTE.
 397          //     [4]: HDMI CTS/N over range.
 398          //     [5]: HDMI no input clock.
 399          //     [6]: HDMI video clock big change.
 400          //     [7]: HDMI audio sample channel status information changes.
 401          //     [8]: HDMI 2-channel audio sample present bit error.
 402          //     [9]: HDMI audio sample flat bit is set.
 403          ///////////////////////////////////////////////////////////////////////////////
 404          void CheckAudioErrorStatus( void )
 405          {
 406   1          drv_CheckAudioErrorStatus();
 407   1      }
 408          
 409          #endif // #if ENABLE_AUDIO_AUTO_MUTE || ENABLE_AUDIO_AUTO_FADING || ENABLE_CTSN_FILTER
 410          #if ENABLE_HDMI_1_4
              // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              //                                HDMI 1.4 new feature:
              //                                1. 3D format
              //                                2. 4K x 2K format
              // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              
              // HDMI_Video_Format: Vendor Specifc Info-frame, PB4[7:5]
              //   000: No additional HDMI video format is presented in this packet
              //   001: Extended resolution format (e.g. 4Kx2K video) present
              //   010: 3D format indication present
              //   011~111: Reserved
C51 COMPILER V9.01   MSHDMI                                                                03/09/2023 15:39:03 PAGE 8   

              E_HDMI_ADDITIONAL_VIDEO_FORMAT msHDMI_Check_Additional_Format(void)
              {
                  return drv_msHDMI_Check_Additional_Format();
              }
              
              
              // 3D_Structure: Vendor Specifc Info-frame, PB5[7:4]
              //   0000: Frame packing
              //   0001: Field alternative
              //   0010: Line alternative
              //   0011: Side-by-Side(Full)
              //   0100: L+depth
              //   0101: L+depth+graphics+graphics-depth
              //   0110: Top-and-Bottom
              //   0111: Reserved
              //   1000: Side-by-Side(Half)
              //   1001 ~ 1111: Reserved
              E_HDMI_3D_INPUT_MODE msHDMI_Get_3D_Structure(void)
              {
                  return drv_msHDMI_Get_3D_Structure();
              }
              
              void msHDMI_Check_3D_Mode_Chg(BYTE SetTimingChg)
              {
              
                  BYTE ucSCFmtIn = SC_FMT_IN_NORMAL;
                  if(InputTimingChangeFlag || DisplayLogoFlag)//(InputTimingChangeFlag || DisplayLogoFlag || DoModeSetti
             -ngFlag)
                      return;
              
                  gScInfo.NoVsPktCnt++;
                  if( gScInfo.InputPacketStatus & BIT7 )
                  {
                  }
              
                  if( ((ucSCFmtIn != g_SetupPathInfo.ucSCFmtIn) && ( (gScInfo.NoVsPktCnt==0) || (gScInfo.NoVsPktCnt >= N
             -oVsPktBound))) )
                  {
                      HDMI_printData("HDMI 3D FMT CHG : %d", ucSCFmtIn);
                      gScInfo.NoVsPktCnt = 0;
                      if(!g_SetupPathInfo.bOverrideSCFmtIn)
                      {
                          g_SetupPathInfo.ucSCFmtIn = ucSCFmtIn;
                          if ( SetTimingChg )
                          {
                              Set_InputTimingChangeFlag();
                          }
                      }
                  }
              
              }
              #endif // #if ENABLE_HDMI_1_4
 472          
 473          #endif//#if ENABLE_HDMI
 474          #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    400    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     32    ----
   PDATA SIZE       =   ----    ----
C51 COMPILER V9.01   MSHDMI                                                                03/09/2023 15:39:03 PAGE 9   

   DATA SIZE        =   ----       1
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

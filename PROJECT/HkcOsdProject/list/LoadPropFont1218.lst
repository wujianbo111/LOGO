C51 COMPILER V9.01   LOADPROPFONT1218                                                      03/09/2023 15:39:10 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE LOADPROPFONT1218
OBJECT MODULE PLACED IN .\obj\LoadPropFont1218.obj
COMPILER INVOKED BY: D:\Keil4\C51\BIN\C51.EXE ..\..\KERNEL\SCALER\LoadPropFont1218.c OPTIMIZE(SIZE) BROWSE INCDIR(..\..\
                    -DRIVER\INC;..\..\KERNEL\SCALER\INC;..\..\KERNEL\SYSTEM\INC;..\..\LIB\INC;..\..\PANEL\INC;..\..\BOARD;..\..\DRIVER\INC;..
                    -\..\KERNEL\SYSTEM\INC\AOC2011;..\..\DRIVER\extDEVICE\INC;..\..\MODEL;..\..\CONFIG;..\..\PANEL;..\..\UI\F_LOGO\INC;..\..\
                    -UI\HkcOsd\INC) DEFINE(ModelName=JRY_TESTBOARD_C_BOARD) DEBUG OBJECTEXTEND PRINT(.\list\LoadPropFont1218.lst) OBJECT(.\ob
                    -j\LoadPropFont1218.obj)

line level    source

   1          ///////////////////////////////////////////////////////////////////////////////
   2          /// @file LoadPropFont1218.c
   3          /// @brief
   4          /// @author MStarSemi Inc.
   5          ///
   6          /// The Prop. font generating and loading function.
   7          ///
   8          /// Features
   9          ///  -Left/Center/Right Align
  10          ///  -Prop Font shift up/down
  11          ///  -Load 12x18 font format to 12x18 font RAM
  12          ///
  13          ///////////////////////////////////////////////////////////////////////////////
  14          
  15          
  16          #define _LOADPROPFONT1218_C
  17          
  18          #include <stddef.h>
  19          #include "LoadPropFont1218.h"
  20          #include "Ms_rwReg.h"
  21          #include "board.h"
  22          #include "Ms_Reg.h"
  23          #include "global.h"
  24          //#include "DebugMsg.h"
  25          
  26          #if 1
  27          extern void Font_Transform( BYTE u8Data );
  28          
  29          extern WORD code tPropFontSet[];
  30          extern WORD code tPropFontMap[];
  31          
  32          extern void printMsg(char *str);
  33          extern void printData(char *str, WORD value);
  34          
  35           
  36          xdata BYTE Font_Transform_Counter = 0;
  37          xdata BYTE Font_Transform_Type = 0;
  38          xdata BYTE Font_Transform_Data[9] = 0;
  39          
  40          void Font_Transform( BYTE u8Data )
  41              {
  42   1      #if CHIP_ID>=CHIP_TSUMV
  43   1              Font_Transform_Data[Font_Transform_Counter] = u8Data;
  44   1              Font_Transform_Counter++;
  45   1              if (Font_Transform_Type == 0 && Font_Transform_Counter >= 3)
  46   1              {
  47   2                  DWORD xdata u32Data = 0;
  48   2                  u32Data = ((DWORD)(Font_Transform_Data[0]&0x0F)<<20)
  49   2                            |((DWORD)(Font_Transform_Data[0]&0xF0)<<4)
  50   2                            |((DWORD)Font_Transform_Data[1]<<12)
  51   2                            |((DWORD)Font_Transform_Data[2]);
C51 COMPILER V9.01   LOADPROPFONT1218                                                      03/09/2023 15:39:10 PAGE 2   

  52   2                  WRITE_FONT();
  53   2                  msWriteByte ( PORT_FONT_DATA, u32Data >> 16 );
  54   2                  msWriteByte ( PORT_FONT_DATA, u32Data >> 8 );
  55   2                  msWriteByte ( PORT_FONT_DATA, u32Data >> 0 );
  56   2                  Font_Transform_Counter = 0;
  57   2              }
  58   1              else if (Font_Transform_Type == 1 && Font_Transform_Counter >= 3)
  59   1              {
  60   2                  DWORD xdata u32Data = 0;
  61   2                  WORD xdata u16FontIndex;
  62   2                  WORD xdata u16FontData1 = ((WORD)Font_Transform_Data[1]) | ((WORD)(Font_Transform_Data[0]&0x0F
             -)<<8);
  63   2                  WORD xdata u16FontData2 = ((WORD)Font_Transform_Data[2]) | ((WORD)(Font_Transform_Data[0]&0xF0
             -)<<4);
  64   2                  u16FontIndex = BIT11;
  65   2                  while ( u16FontIndex )
  66   2                  {
  67   3                      u32Data <<= 2;
  68   3                      if ( u16FontData1 & u16FontIndex ) //color bit0
  69   3                      {
  70   4                          u32Data |= BIT0;
  71   4                      }
  72   3                      if ( u16FontData2 & u16FontIndex ) //color bit1
  73   3                      {
  74   4                          u32Data |= BIT1;
  75   4                      }
  76   3                      u16FontIndex >>= 1;
  77   3                  }
  78   2                  WRITE_FONT();
  79   2                  msWriteByte ( PORT_FONT_DATA, u32Data >> 16 );
  80   2                  msWriteByte ( PORT_FONT_DATA, u32Data >> 8 );
  81   2                  msWriteByte ( PORT_FONT_DATA, u32Data >> 0 );
  82   2                  Font_Transform_Counter = 0;
  83   2              }
  84   1              else if (Font_Transform_Type == 2 && Font_Transform_Counter >= 9)
  85   1              {
  86   2                  DWORD xdata u32Data = 0;
  87   2                  BYTE xdata u8FontData0, u8FontData1, u8FontData2;
  88   2                  BYTE xdata u8PixelBit;
  89   2                  BYTE xdata i;
  90   2                  for ( i = 0; i < 3; i++ )
  91   2                  {
  92   3                      if ( i == 0 )
  93   3                      {
  94   4                          u8FontData0 =(Font_Transform_Data[0]<<4) + (Font_Transform_Data[1]>>4);
  95   4                          u8FontData1 =(Font_Transform_Data[0]&0xF0) + (Font_Transform_Data[2]>>4);
  96   4                          u8FontData2 =(Font_Transform_Data[3]<<4) + (Font_Transform_Data[4]>>4);
  97   4                      }
  98   3                      else if ( i == 1 )
  99   3                      {
 100   4                          u8FontData0 =(Font_Transform_Data[1]<<4) + (Font_Transform_Data[3]>>4);
 101   4                          u8FontData1 =(Font_Transform_Data[2]<<4) + (Font_Transform_Data[6]&0x0F);
 102   4                          u8FontData2 =(Font_Transform_Data[4]<<4) + (Font_Transform_Data[6]>>4);
 103   4                      }
 104   3                      else
 105   3                      {
 106   4                          u8FontData0 =(Font_Transform_Data[5]);
 107   4                          u8FontData1 =(Font_Transform_Data[7]);
 108   4                          u8FontData2 =(Font_Transform_Data[8]);
 109   4                      }
 110   3                      u8PixelBit = BIT7;
 111   3                      u32Data = 0;
C51 COMPILER V9.01   LOADPROPFONT1218                                                      03/09/2023 15:39:10 PAGE 3   

 112   3                      while ( u8PixelBit )
 113   3                      {
 114   4                          u32Data <<= 3;
 115   4                          if ( u8FontData0 & u8PixelBit ) //color bit0
 116   4                          {
 117   5                              u32Data |= BIT0;
 118   5                          }
 119   4                          if ( u8FontData1 & u8PixelBit ) //color bit1
 120   4                          {
 121   5                              u32Data |= BIT1;
 122   5                          }
 123   4                          if ( u8FontData2 & u8PixelBit ) //color bit2
 124   4                          {
 125   5                              u32Data |= BIT2;
 126   5                          }
 127   4                          u8PixelBit >>= 1;
 128   4                      }
 129   3                      WRITE_FONT();
 130   3                      msWriteByte ( PORT_FONT_DATA, u32Data >> 16 );
 131   3                      msWriteByte ( PORT_FONT_DATA, u32Data >> 8 );
 132   3                      msWriteByte ( PORT_FONT_DATA, u32Data );
 133   3                  }
 134   2                      Font_Transform_Counter = 0;
 135   2              }
 136   1      #else
                      msWriteByte ( OSD2_A4, ( BYTE ) u8Data );
                  
              #endif
 140   1              
 141   1          }
 142          
 143          
 144          void ClearPropFontRam ( WORD *font_ram )
 145          {
 146   1          BYTE i;
 147   1          for ( i = 0; i < 18; i++ )
 148   1          {
 149   2              font_ram[i] = 0;
 150   2          }
 151   1      }
 152          
 153          //========================================================================================================
             -===========================================================:
 154          WORD GetFontSpace ( BYTE index )
 155          {
 156   1          return tPropFontSet[tPropFontMap[index + font_offset]];
 157   1      }
 158          //========================================================================================================
             -===========================================================:
 159          void _GetPropCompressFontData ( BYTE index )
 160              {
 161   1              WORD *pTable;
 162   1              BYTE xdata count, i, row;
 163   1                              
 164   1              pTable = & ( tPropFontSet[tPropFontMap[index + font_offset]] );
 165   1              pTable++;
 166   1              row = 0;
 167   1              do
 168   1              {
 169   2                  count = ( *pTable ) >> 12;
 170   2                  for ( i = 0; i < count; i++ )
 171   2                  {
C51 COMPILER V9.01   LOADPROPFONT1218                                                      03/09/2023 15:39:10 PAGE 4   

 172   3                      CFontData[row + i] = ( *pTable ) & 0x0fff;
 173   3                  }
 174   2                  row += count;
 175   2                  pTable++;
 176   2              }
 177   1              while ( row < 18 );
 178   1          }
 179          
 180          
 181          //========================================================================================================
             -===========================================================:
 182          void LoadFontRam ( WORD *font_ram )
 183          {
 184   1          BYTE i;
 185   1          WORD font_data;
 186   1          for ( i = 0; i < 9; i++ )
 187   1          {
 188   2              font_data = ( font_ram[2 * i] >> 8 ) | ( ( font_ram[2 * i + 1] & 0xf00 ) >> 4 );
 189   2              //msWriteByte ( PORT_FONT_DATA, ( BYTE ) font_data );
 190   2              Font_Transform( ( BYTE ) font_data );
 191   2              font_data = font_ram[2 * i] & 0x0ff;
 192   2              //msWriteByte ( PORT_FONT_DATA, ( BYTE ) font_data );
 193   2              Font_Transform( ( BYTE ) font_data );
 194   2              font_data = font_ram[2 * i + 1] & 0x0ff;
 195   2              //msWriteByte ( PORT_FONT_DATA, ( BYTE ) font_data );
 196   2              Font_Transform( ( BYTE ) font_data );
 197   2          }
 198   1      }
 199          
 200          BYTE LoadCompressedPropFonts ( BYTE *font, WORD num )
 201          {
 202   1          Bool not_prop;
 203   1          BYTE i;
 204   1          BYTE l_space, r_space, font_width;
 205   1          BYTE xdata NeedSpaceWidth;
 206   1          WORD xdata font_data;
 207   1          WORD xdata TotalFont = 0;
 208   1          WORD xdata PropFontRam[18];
 209   1          WORD xdata FontIndex = 0;
 210   1          font_offset = 0;
 211   1      #if 1
 212   1          if ( font[FontIndex] == FONT_COMMAND )
 213   1          {
 214   2              FontIndex ++;
 215   2              num--;
 216   2              font_offset = font[FontIndex] * 0x0100;
 217   2              FontIndex ++;
 218   2              num--;
 219   2          }
 220   1      #endif
 221   1      
 222   1          //GetPropFontTable ();
 223   1          ClearPropFontRam ( PropFontRam );
 224   1          NeedSpaceWidth = 0;
 225   1          PropFontRamWidth = INIT_WORD_SPACE;
 226   1          //PropFontRamWidth = ( BYTE ) font_shift;
 227   1          font_width = ( BYTE ) GetFontSpace ( font[FontIndex] );
 228   1          l_space = font_width >> 4;
 229   1          r_space = font_width & 0x0f;
 230   1          font_width = 12 - l_space - r_space;
 231   1          TotalFontWidth += font_width; //new
 232   1          FontUsedPixel = font_width;
C51 COMPILER V9.01   LOADPROPFONT1218                                                      03/09/2023 15:39:10 PAGE 5   

 233   1          while ( num )
 234   1          {
 235   2      #if 1
 236   2              if ( font[FontIndex] == FONT_COMMAND )
 237   2              {
 238   3                  FontIndex ++;
 239   3                  num--;
 240   3                  font_offset = font[FontIndex] * 0x0100;
 241   3                  FontIndex ++;
 242   3                  num--;
 243   3              }
 244   2      #endif
 245   2              _GetPropCompressFontData ( font[FontIndex] );
 246   2              for ( i = 0; i < 18; i++ )
 247   2              {
 248   3                  font_data = CFontData[i];
 249   3                  PropFontRam[i] = PropFontRam[i] | ( ( ( font_data << ( l_space + font_width - FontUsedPixel ) 
             -) & 0x0fff ) >> PropFontRamWidth );
 250   3              }
 251   2              PropFontRamWidth += FontUsedPixel;
 252   2              if ( PropFontRamWidth > 12 )
 253   2              {
 254   3                  FontUsedPixel = PropFontRamWidth - 12;
 255   3                  PropFontRamWidth = 12;
 256   3              }
 257   2              else
 258   2              {
 259   3                  FontUsedPixel = 0;
 260   3              }
 261   2              if ( FontUsedPixel == 0 )  // word finish
 262   2              {
 263   3                  if ( num )
 264   3                  {
 265   4                      num--;
 266   4                      if ( num == 0 )
 267   4                      {
 268   5                          TotalFont++;
 269   5                          LoadFontRam ( PropFontRam );
 270   5                          return ( BYTE ) TotalFont;
 271   5                      }
 272   4                  }
 273   3                  FontIndex++;
 274   3      #if 1
 275   3                  if ( font[FontIndex] == FONT_COMMAND )
 276   3                  {
 277   4                      FontIndex ++;
 278   4                      num--;
 279   4                      font_offset = font[FontIndex] * 0x0100;
 280   4                      FontIndex ++;
 281   4                      num--;
 282   4                  }
 283   3      #endif
 284   3                  if ( font[FontIndex] == 0x00 )  // new string
 285   3                  {
 286   4                      TotalFont++;
 287   4                      LoadFontRam ( PropFontRam );
 288   4                      if ( num )
 289   4                      {
 290   5                          num--;
 291   5                          if ( num == 0 )
 292   5                          {
 293   6      
C51 COMPILER V9.01   LOADPROPFONT1218                                                      03/09/2023 15:39:10 PAGE 6   

 294   6                              return ( BYTE ) TotalFont;
 295   6                          }
 296   5                      }
 297   4                      FontIndex++;
 298   4                      ClearPropFontRam ( PropFontRam );
 299   4                      PropFontRamWidth = INIT_WORD_SPACE;
 300   4                      NeedSpaceWidth = 0;
 301   4                  }
 302   3                  else  // next word
 303   3                  {
 304   4      #if 1
 305   4                      if ( font[FontIndex] == FONT_COMMAND )
 306   4                      {
 307   5                          FontIndex ++;
 308   5                          num--;
 309   5                          font_offset = font[FontIndex] * 0x0100;
 310   5                          FontIndex ++;
 311   5                          num--;
 312   5                      }
 313   4      #endif
 314   4                      //GetPropFontTable ();
 315   4                      if ( GetFontSpace ( font[FontIndex] ) & 0x8000 )
 316   4                      {
 317   5                          not_prop = 1;
 318   5                      }
 319   4                      else
 320   4                      {
 321   5                          not_prop = 0;
 322   5                          NeedSpaceWidth += WORD_SPACE;
 323   5                          TotalFontWidth += WORD_SPACE; //new
 324   5                      }
 325   4                  }
 326   3      #if 1
 327   3                  if ( font[FontIndex] == FONT_COMMAND )
 328   3                  {
 329   4                      FontIndex ++;
 330   4                      num--;
 331   4                      font_offset = font[FontIndex] * 0x0100;
 332   4                      FontIndex ++;
 333   4                      num--;
 334   4                  }
 335   3      #endif
 336   3                  //GetPropFontTable ();
 337   3                  font_width = ( BYTE ) GetFontSpace ( font[FontIndex] );
 338   3                  l_space = font_width >> 4;
 339   3                  r_space = font_width & 0x0f;
 340   3                  font_width = 12 - l_space - r_space;
 341   3                  TotalFontWidth += font_width; //new
 342   3                  FontUsedPixel = font_width;
 343   3              }
 344   2              PropFontRamWidth += NeedSpaceWidth;
 345   2              if ( PropFontRamWidth > 12 )
 346   2              {
 347   3                  NeedSpaceWidth = PropFontRamWidth - 12;
 348   3                  PropFontRamWidth = 12;
 349   3              }
 350   2              else
 351   2              {
 352   3                  NeedSpaceWidth = 0;
 353   3              }
 354   2              if ( PropFontRamWidth == 12 )
 355   2              {
C51 COMPILER V9.01   LOADPROPFONT1218                                                      03/09/2023 15:39:10 PAGE 7   

 356   3                  TotalFont++;
 357   3                  LoadFontRam ( PropFontRam );
 358   3                  ClearPropFontRam ( PropFontRam );
 359   3                  PropFontRamWidth = 0;
 360   3              }
 361   2              PropFontRamWidth += NeedSpaceWidth;
 362   2              NeedSpaceWidth = 0;
 363   2          }
 364   1      
 365   1          return ( BYTE ) TotalFont;
 366   1      }
 367          #else
              
              
              
              #if PropFontUseCommonArea
              extern PropFontNonCompressType code tPropFontSet[];
              extern PropFontNonCompressType code tPropFontSet1[];
              extern PropFontNonCompressType code tPropFontSet2[];
              #endif
              //#define OSD2_A3 0xA3
              //#define OSD2_A4 0xA4
              
              PropFontNonCompressType *pstPropFontSet1218;
              ///BIT 0~1 : pixel between font
              ///BIT 2~3 : align(00=left align, 01=right align, 11= center align)
              BYTE g_u8PropFontFlags=SPACE2PIXEL|LEFT_ALIGN;
              BYTE g_u8AlignResetIndex=0xFF;  ///start number of strings for reset align flag to left align
              BYTE xdata g_u8ByPassLength=0;
              /// Shift "a font" up or down inner 12x18 dimension.
              static void ShiftFontUpDown(WORD *pu16SN, BYTE u8Shift)
              {
                  BYTE  i;
                  BYTE  u8ShiftUp;
              
                  if(u8Shift&0x80)
                  {   u8ShiftUp=1;
                      u8Shift&=0x7F;
                  }
                  else
                      u8ShiftUp=0;
              
                  if(u8ShiftUp)
                  {
                      for(i=u8Shift;i<FONT_HEIGHT;i++)
                          *(pu16SN+i-u8Shift) = (*(pu16SN+i));
                      for(i=(FONT_HEIGHT-u8Shift);i<FONT_HEIGHT;i++)
                          *(pu16SN+i) = 0;
                  }
                  else//ShiftDown
                  {
                      for(i=(FONT_HEIGHT-u8Shift);i>0;i--)
                          *(pu16SN+i-1+u8Shift) = (*(pu16SN+i-1));
                      for(i=0;i<u8Shift;i++)
                          *(pu16SN+i) = 0;
                  }
              }
              
              #if 0
              /// Write 2 words of font data(2 line with 12 pixel width) to font RAM. ex: 0Aaa,0Bbb ===> BA,AA,BB
              /// This function should be modified if use 16x16
              static void WriteWord2Font(WORD u16SN1,WORD u16SN2)
C51 COMPILER V9.01   LOADPROPFONT1218                                                      03/09/2023 15:39:10 PAGE 8   

              {
                  msWriteByte(OSD2_A4, HIBYTE(u16SN1) + (HIBYTE(u16SN2) <<4));
                  msWriteByte(OSD2_A4, LOBYTE(u16SN1));
                  msWriteByte(OSD2_A4, LOBYTE(u16SN2));
              }
              /// Load a font char(12x18) to font RAM.
              /// This function should be modified if use 16x16!
              void OSDLoadOneFont(WORD* pu16SN)
              {   BYTE  i;
                  for(i=0; i < (FONT_HEIGHT>>1); i++)
                      WriteWord2Font(*(pu16SN+(i<<1)),*(pu16SN+(i<<1)+1));
              }
              #else
              /// Load a font char(12x18) to font RAM.
              /// This function should be modified if use 16x16!
              void OSDLoadOneFont(WORD* pu16SN)
              {   BYTE  i;
                  #define u16SN1  (*(pu16SN+i))
                  #define u16SN2  (*(pu16SN+i+1))
                  for(i=0; i < FONT_HEIGHT; i+=2)
                  {
                  #if CHIP_ID>=CHIP_TSUMV
                      //xxxx0000 00001111
                      //xxxx1111 22222222
                      MEM_MSWRITE_BYTE(PORT_FONT_DATA, (BYTE)(u16SN1>>4) );
                      MEM_MSWRITE_BYTE(PORT_FONT_DATA, (LOBYTE(u16SN1)<<4)+HIBYTE(u16SN2));
                      MEM_MSWRITE_BYTE(PORT_FONT_DATA, LOBYTE(u16SN2));
                  #else
                      MEM_MSWRITE_BYTE(OSD2_A4, HIBYTE(u16SN1) + (HIBYTE(u16SN2) <<4));
                      MEM_MSWRITE_BYTE(OSD2_A4, LOBYTE(u16SN1));
                      MEM_MSWRITE_BYTE(OSD2_A4, LOBYTE(u16SN2));
                  #endif
                  }
                  #undef u16SN1
                  #undef u16SN2
              }
              #endif
              
              /// Clear a font char(12x18) buffer.
              void ClearFontBuf(WORD* pu16SN)
              {   BYTE  i;
              
              #if 0
                  for(i=0; i < FONT_HEIGHT; i++)
                      *(pu16SN + i) = 0;
              #else
                  //Jison: Speed up
                  for(i=0; i < (FONT_HEIGHT>>1); i++)
                      *((DWORD*)pu16SN + i) = 0;
              #endif
              
              }
              /// Do OR operation between two font buffer, save the sesult to 1st buffer.
              static void MergeFontBuf(WORD* pu16SN ,WORD* pu16SN1)
              {   BYTE  i;
                  for(i=0; i < FONT_HEIGHT; i++)
                      *(pu16SN + i) = (*(pu16SN + i))| (*(pu16SN1 + i));
              }
              //BitTarLStart 0xFFF = 1111 1111 1111 sequence >>  0123 4567 89AB
              /// Copy sub-part of src font (start from u8BitSrcLStart with u8BitWidth) to tar font area.
              /// This function should be modified if use 16x16!
              ///u8BitSrcLStart is the 1st pixel position of Src font that will be merged to Tar.
C51 COMPILER V9.01   LOADPROPFONT1218                                                      03/09/2023 15:39:10 PAGE 9   

              ///u8BitWidth is the pixel width following 1st pixel position that will be merged to.
              static void CopySubFontBuf(WORD* pu16Tar,WORD*pu16Src,BYTE u8BitSrcLStart, BYTE u8BitWidth)
              {   BYTE  i;
                  WORD  u16Temp;
              #if 0
                  for(i=0; i < FONT_HEIGHT; i++)
                  {
                      u16Temp = (*(pu16Src + i));
                      u16Temp = u16Temp<<u8BitSrcLStart;
                      u16Temp &= 0xFFF;
                      u16Temp = u16Temp>>(FONT_WIDTH-u8BitWidth);
                      *(pu16Tar + i) = *(pu16Tar + i) | u16Temp;
                  }
              #else //Jison, Speed up
                  u8BitWidth=(FONT_WIDTH-u8BitWidth);
                  for(i=0; i < FONT_HEIGHT; i++)
                  {
                      u16Temp = ((((*(pu16Src + i))<<u8BitSrcLStart)&0xFFF)>>(u8BitWidth));
                      *(pu16Tar + i) |= u16Temp;
                  }
              #endif
              }
              
              static BYTE GetRemainderPixelOfString(BYTE *pu8String)
              {
                  WORD u16PixelLen=0;
                  BYTE u8SpaceWidth;
              
                  while(*pu8String)
                  {
                      u8SpaceWidth = pstPropFontSet1218[*pu8String].u8SpaceWidth;
              //        u16PixelLen+=(SP_BETWEEN_FONT+FONT_WIDTH-( (pstFontData->u8SpaceWidth & 0x0F) + ((pstFontData->u
             -8SpaceWidth & 0xF0)>>4) ));
                      if ((u8SpaceWidth & 0xF0)==0xF0)
                          u16PixelLen+= (FONT_WIDTH-(u8SpaceWidth & 0x0F));
                      else
                          u16PixelLen+=(( (u8SpaceWidth & 0x0F) + ((u8SpaceWidth & 0xF0)>>4) )-SP_BETWEEN_FONT);
                      pu8String++;
                  }
                  u16PixelLen%=FONT_WIDTH;
              #if 0
                  u16PixelLen=FONT_WIDTH-u16PixelLen;
                  return (BYTE)(u16PixelLen ? FONT_WIDTH-u16PixelLen : 0);
              #else //Jison 080109
                  return ((BYTE)u16PixelLen);
              #endif
              }
              /// pu8Strings and pu8Strings1 are the null-terminal strings set of font indexes to PropFontNonCompressTyp
             -e array.
              /// u16FontCount and u16FontCount1 are array size of pu8Strings and pu8Strings1 respectively.
              /// u8UDShift and u8UDShift1 are the shift pixels pu8Strings and pu8Strings1, Bit 7==1 means shift up.
              /// >>>Shift up/down and load single line string to font RAM if pu8Strings1==0 and u16FontCount1==0.
              /// >>>Merge two font string lines to a single 18 pixels height charactor line and load to font RAM.
              BYTE LoadPropFonts1218(BYTE u8Addr, BYTE *pu8Strings, WORD u16FontCount,
                  BYTE *pu8Strings1, WORD u16FontCount1, BYTE u8UDShift ,BYTE u8UDShift1)
              {
                  PropFontNonCompressType *pstFontData;
                  PropFontNonCompressType *pstFontData1;
                  WORD  xdata u16StrIndex=0, u16StrIndex1=0;  ///The str index in pu8Strings
                  BYTE  xdata u8Flags=0;
                  BYTE  xdata u8BufW=0,u8BufW1=0;
                  BYTE  xdata u8NextFontW=0,u8NextFontW1=0;
C51 COMPILER V9.01   LOADPROPFONT1218                                                      03/09/2023 15:39:10 PAGE 10  

                  BYTE  xdata u8NextBit=0,u8NextBit1=0;
                  WORD  xdata tSN[FONT_HEIGHT]; //May cause problem if use idata. Why???
                  WORD  xdata tSN1[FONT_HEIGHT];
                  BYTE  xdata u8StrCount=0;
                  BYTE  xdata u8FontCnt=0;
              
              #define LOAD_SINGLE_LINE_BIT            BIT7
              #define LOAD_SINGLE_LINE_FLAG           (u8Flags&LOAD_SINGLE_LINE_BIT)
              #define SET_LOAD_SINGLE()               (u8Flags|=LOAD_SINGLE_LINE_BIT)
              
              #define STR_1ST_CHAR_BIT                BIT0
              #define STR_1ST_CHAR_FLAG               (u8Flags&STR_1ST_CHAR_BIT)
              #define SET_STR_1ST_CHAR_FLAG()         (u8Flags|=STR_1ST_CHAR_BIT)
              #define CLR_STR_1ST_CHAR_FLAG()         (u8Flags&=~STR_1ST_CHAR_BIT)
              
              #define STR1_1ST_CHAR_BIT               BIT1
              #define STR1_1ST_CHAR_FLAG              (u8Flags&STR1_1ST_CHAR_BIT)
              #define SET_STR1_1ST_CHAR_FLAG()        (u8Flags|=STR1_1ST_CHAR_BIT)
              #define CLR_STR1_1ST_CHAR_FLAG()        (u8Flags&=~STR1_1ST_CHAR_BIT)
              
              #define LOAD_SINGLE_FONT_BIT            BIT2
              #define LOAD_SINGLE_FONT_FLAG           (u8Flags&LOAD_SINGLE_FONT_BIT)
              #define SET_LOAD_SINGLE_FONT_FLAG()     (u8Flags|=LOAD_SINGLE_FONT_BIT)
              #define CLR_LOAD_SINGLE_FONT_FLAG()     (u8Flags&=~LOAD_SINGLE_FONT_BIT)
              
              #define LOAD_SINGLE_FONT1_BIT           BIT3
              #define LOAD_SINGLE_FONT1_FLAG          (u8Flags&LOAD_SINGLE_FONT1_BIT)
              #define SET_LOAD_SINGLE_FONT1_FLAG()    (u8Flags|=LOAD_SINGLE_FONT1_BIT)
              #define CLR_LOAD_SINGLE_FONT1_FLAG()    (u8Flags&=~LOAD_SINGLE_FONT1_BIT)
              
              
                  if(pu8Strings1==NULL || u16FontCount1==0)
                      SET_LOAD_SINGLE();
                  #if CHIP_ID>=CHIP_TSUMV
                  {   extern BYTE xdata g_u8FontAddrHiBits;
                      u16StrIndex=((msRead2Byte(OSD1_08)+((((WORD)g_u8FontAddrHiBits)<<8)+(u8Addr))*(((msReadByte(OSD1_0
             -B)>>4)&0x03)+1))<<2); //get real address in cafram, ((font base entry)+unit*(unit size))*4 addr/entry
                      //u16StrIndex=GET_FONT_RAM_ADDR(u8Addr); //get real address in cafram, ((font base entry)+unit*(un
             -it size))*4 addr/entry
                  }
                  msWrite2Byte(PORT_FONT_ADDR, u16StrIndex);
                  u16StrIndex=0;
                  #else
                  MEM_MSWRITE_BYTE(OSD2_A3, u8Addr);
                  #endif
                  SET_STR_1ST_CHAR_FLAG();
                  SET_STR1_1ST_CHAR_FLAG();
                  while((u16StrIndex < u16FontCount) || (u16StrIndex1 < u16FontCount1))
                  {
                      if((!LOAD_SINGLE_FONT_FLAG) && (u16StrIndex < u16FontCount))   /// Handle 1st strings
                      {
                          if(STR_1ST_CHAR_FLAG)
                          {
                              ClearFontBuf(tSN);
                              CLR_STR_1ST_CHAR_FLAG();
              
                              #if PropFontUseCommonArea
                              {
                                  if (*(pu8Strings+u16StrIndex)>=SecondTblAddr)
                                  { 
                                      if ( LanguageIndex == 1 )
                                      {
C51 COMPILER V9.01   LOADPROPFONT1218                                                      03/09/2023 15:39:10 PAGE 11  

                                          pstPropFontSet1218=tPropFontSet1;
                                          pstFontData = pstPropFontSet1218+*(pu8Strings+u16StrIndex)-SecondTblAddr;
                                      }
                                      else if ( LanguageIndex == 2 )
                                      {
                                          pstPropFontSet1218=tPropFontSet2;
                                          pstFontData = pstPropFontSet1218+*(pu8Strings+u16StrIndex)-SecondTblAddr;
                                      }
                                  }
                                  else
                                  {
                                      pstPropFontSet1218=tPropFontSet;
                                      pstFontData = pstPropFontSet1218+*(pu8Strings+u16StrIndex);
                                  }
                              }
                              #else
                              pstFontData = pstPropFontSet1218+*(pu8Strings+u16StrIndex);
                              #endif
                              u8NextFontW = (FONT_WIDTH -( (pstFontData->u8SpaceWidth & 0x0F) + ((pstFontData->u8SpaceWi
             -dth & 0xF0)>>4) ));
                              if (IS_LEFT_ALIGN)
                                  u8BufW=FONT_WIDTH-SP_BETWEEN_FONT;  //Leading with SP_BETWEEN_FONT pixels
                              else if (IS_RIGHT_ALIGN)
                                  u8BufW=FONT_WIDTH-/*SP_BETWEEN_FONT-*/GetRemainderPixelOfString(pu8Strings+u16StrIndex
             -);
                              else    //IS_CENTER_ALIGN
                                  u8BufW=FONT_WIDTH-/*SP_BETWEEN_FONT-*/(GetRemainderPixelOfString(pu8Strings+u16StrInde
             -x)>>1);
                              //u8BufW : the remainder pixel width
                                          /// Retrieve the first font of string and copy to a blank buffer.
                              CopySubFontBuf(tSN, pstFontData->tLineData, (pstFontData->u8SpaceWidth & 0xF0)>>4, u8BufW)
             -;
                          }
                          else
                          {
                              if ((pstFontData->u8SpaceWidth & 0xF0)==0xF0)
                              {
                                  CopySubFontBuf(tSN, pstFontData->tLineData, u8NextBit, u8BufW);
                              }
                              else
                                  CopySubFontBuf(tSN, pstFontData->tLineData, u8NextBit+((pstFontData->u8SpaceWidth & 0x
             -F0)>>4), u8BufW);
                          }
                          ///Reset position variable
                          if(u8BufW>=u8NextFontW)
                          {
                              u8BufW -= u8NextFontW;
                              u8NextFontW=0;
                              u8NextBit=0;
                          }
                          else
                          {
                              u8NextFontW-=u8BufW;
                              u8NextBit+=u8BufW;
                              u8BufW=0;
                          }
              
                          if(u8BufW==0)   ///Buffur full
                          {
                              u8BufW=FONT_WIDTH;
                              SET_LOAD_SINGLE_FONT_FLAG();
                          }
C51 COMPILER V9.01   LOADPROPFONT1218                                                      03/09/2023 15:39:10 PAGE 12  

              
                          if(u8NextFontW==0) ///finished a font
                          {
                              #if PropFontUseCommonArea
                              {
                                  if (*(pu8Strings+u16StrIndex)>=SecondTblAddr)
                                  { 
                                      if ( LanguageIndex == 1 )
                                      {
                                          pstPropFontSet1218=tPropFontSet1;
                                      }
                                      else if ( LanguageIndex == 2 )
                                      {
                                          pstPropFontSet1218=tPropFontSet2;
                                      }
                                      
                                      if (((pstPropFontSet1218+*(pu8Strings+u16StrIndex+1)-SecondTblAddr)->u8SpaceWidth 
             -& 0xF0)!=0xF0)
                                      {
                                          if(u8BufW>SP_BETWEEN_FONT)
                                              u8BufW-=SP_BETWEEN_FONT;
                                          else if(u8BufW==SP_BETWEEN_FONT)
                                          {
                                              u8BufW=FONT_WIDTH;
                                              SET_LOAD_SINGLE_FONT_FLAG();
                                          }
                                          else// if(u8BufW!=0)  u8BufW<SP_BETWEEN_FONT
                                          {
                                              //u8BufW=FONT_WIDTH-u8BufW;
                                              u8BufW=FONT_WIDTH-(SP_BETWEEN_FONT-u8BufW);
                                              SET_LOAD_SINGLE_FONT_FLAG();
                                          }
                                      }
                                      
                                  }
                                  else
                                  {
                                      pstPropFontSet1218=tPropFontSet;
                                      if (((pstPropFontSet1218+*(pu8Strings+u16StrIndex+1))->u8SpaceWidth & 0xF0)!=0xF0)
                                      {
                                          if(u8BufW>SP_BETWEEN_FONT)
                                              u8BufW-=SP_BETWEEN_FONT;
                                          else if(u8BufW==SP_BETWEEN_FONT)
                                          {
                                              u8BufW=FONT_WIDTH;
                                              SET_LOAD_SINGLE_FONT_FLAG();
                                          }
                                          else// if(u8BufW!=0)  u8BufW<SP_BETWEEN_FONT
                                          {
                                              //u8BufW=FONT_WIDTH-u8BufW;
                                              u8BufW=FONT_WIDTH-(SP_BETWEEN_FONT-u8BufW);
                                              SET_LOAD_SINGLE_FONT_FLAG();
                                          }
                                      }
              
                                  }
                              }
                              #else
                              if (((pstPropFontSet1218+*(pu8Strings+u16StrIndex+1))->u8SpaceWidth & 0xF0)!=0xF0)
                              {
                                  if(u8BufW>SP_BETWEEN_FONT)
                                      u8BufW-=SP_BETWEEN_FONT;
C51 COMPILER V9.01   LOADPROPFONT1218                                                      03/09/2023 15:39:10 PAGE 13  

                                  else if(u8BufW==SP_BETWEEN_FONT)
                                  {
                                      u8BufW=FONT_WIDTH;
                                      SET_LOAD_SINGLE_FONT_FLAG();
                                  }
                                  else// if(u8BufW!=0)  u8BufW<SP_BETWEEN_FONT
                                  {
                                      //u8BufW=FONT_WIDTH-u8BufW;
                                      u8BufW=FONT_WIDTH-(SP_BETWEEN_FONT-u8BufW);
                                      SET_LOAD_SINGLE_FONT_FLAG();
                                  }
                              }
                              #endif
                              u16StrIndex++;
                              #if PropFontUseCommonArea
                              {
                                  if (*(pu8Strings+u16StrIndex)>=SecondTblAddr)
                                  { 
                                      if ( LanguageIndex == 1 )
                                      {
                                          pstPropFontSet1218=tPropFontSet1;
                                          pstFontData = pstPropFontSet1218+*(pu8Strings+u16StrIndex)-SecondTblAddr;
                                      }
                                      else if ( LanguageIndex == 2 )
                                      {
                                          pstPropFontSet1218=tPropFontSet2;
                                          pstFontData = pstPropFontSet1218+*(pu8Strings+u16StrIndex)-SecondTblAddr;
                                      }
                                  }
                                  else
                                  {
                                      pstPropFontSet1218=tPropFontSet;
                                      pstFontData = pstPropFontSet1218+*(pu8Strings+u16StrIndex);
                                  }
                              }
                              #else
                              pstFontData = pstPropFontSet1218+*(pu8Strings+u16StrIndex);///get next font data
                              #endif
                              if ((pstFontData->u8SpaceWidth & 0xF0)==0xF0)
                                  u8NextFontW = (pstFontData->u8SpaceWidth & 0x0F);
                              else
                                  u8NextFontW = (FONT_WIDTH -( (pstFontData->u8SpaceWidth & 0x0F) + ((pstFontData->u8Spa
             -ceWidth & 0xF0)>>4) ));
              
                              u8NextBit=0;
                              if(*(pu8Strings+u16StrIndex) == 0x00)
                              {
                                  if(u8BufW<(FONT_WIDTH-SP_BETWEEN_FONT))///???
                                  {
                                      SET_LOAD_SINGLE_FONT_FLAG();
                                  }
                                  SET_STR_1ST_CHAR_FLAG();
                                  u16StrIndex++;
                                  if ((++u8StrCount)==g_u8AlignResetIndex)
                                      g_u8PropFontFlags&=~0x0C;
                              }
                          }
                      }
                      else if(u16StrIndex >= u16FontCount)
                      {
                          if(u8BufW)
                              u8BufW = 0;
C51 COMPILER V9.01   LOADPROPFONT1218                                                      03/09/2023 15:39:10 PAGE 14  

                          SET_LOAD_SINGLE_FONT_FLAG();
                      }
              
              
                      //===================================================================================
                      if((!LOAD_SINGLE_FONT1_FLAG) && (u16StrIndex1 < u16FontCount1))   /// Handle 2nd strings
                      {
                          if(STR1_1ST_CHAR_FLAG)
                          {
                              ClearFontBuf(tSN1);
                              CLR_STR1_1ST_CHAR_FLAG();
              
                              #if PropFontUseCommonArea
                              {
                                  if (*(pu8Strings1+u16StrIndex1)>=SecondTblAddr)
                                  { 
                                      if ( LanguageIndex == 1 )
                                      {
                                          pstPropFontSet1218=tPropFontSet1;
                                          pstFontData1 = pstPropFontSet1218+*(pu8Strings1+u16StrIndex1)-SecondTblAddr;
                                      }
                                      else if ( LanguageIndex == 2 )
                                      {
                                          pstPropFontSet1218=tPropFontSet2;
                                          pstFontData1 = pstPropFontSet1218+*(pu8Strings1+u16StrIndex1)-SecondTblAddr;
                                      }
                                  }
                                  else
                                  {
                                      pstPropFontSet1218=tPropFontSet;
                                      pstFontData1 = pstPropFontSet1218+*(pu8Strings1+u16StrIndex1);
                                  }
                              }
                              #else
                              pstFontData1 = pstPropFontSet1218+*(pu8Strings1+u16StrIndex1);
                              #endif
                              u8NextFontW1 = (FONT_WIDTH -( (pstFontData1->u8SpaceWidth & 0x0F) + ((pstFontData1->u8Spac
             -eWidth & 0xF0)>>4) ));
                              if (IS_LEFT_ALIGN)
                                  u8BufW1=FONT_WIDTH-SP_BETWEEN_FONT;
                              else if (IS_RIGHT_ALIGN)
                                  u8BufW=FONT_WIDTH-/*SP_BETWEEN_FONT-*/GetRemainderPixelOfString(pu8Strings1+u16StrInde
             -x1);
                              else    //IS_CENTER_ALIGN
                                  u8BufW=FONT_WIDTH-/*SP_BETWEEN_FONT-*/(GetRemainderPixelOfString(pu8Strings1+u16StrInd
             -ex1)>>1);
              
                              CopySubFontBuf(tSN1, pstFontData1->tLineData, (pstFontData1->u8SpaceWidth & 0xF0)>>4, u8Bu
             -fW1);
                          }
                          else
                          {
                              if ((pstFontData1->u8SpaceWidth & 0xF0)==0xF0)
                              {
                                  CopySubFontBuf(tSN1, pstFontData1->tLineData, u8NextBit1, u8BufW1);
                              }
                              else
                                  CopySubFontBuf(tSN1, pstFontData1->tLineData, u8NextBit1+((pstFontData1->u8SpaceWidth 
             -& 0xF0)>>4), u8BufW1);
                          }
              
                          if(u8BufW1>=u8NextFontW1)
C51 COMPILER V9.01   LOADPROPFONT1218                                                      03/09/2023 15:39:10 PAGE 15  

                          {
                              u8BufW1 -= u8NextFontW1;
                              u8NextFontW1=0;
                              u8NextBit1=0;
                          }
                          else
                          {
                              u8NextFontW1-=u8BufW1;
                              u8NextBit1+=u8BufW1;
                              u8BufW1=0;
                          }
              
                          if(u8BufW1==0)
                          {
                              u8BufW1=FONT_WIDTH;
                              SET_LOAD_SINGLE_FONT1_FLAG();
                          }
                          if(u8NextFontW1==0)
                          {
                              #if PropFontUseCommonArea
                              {
                                  if (*(pu8Strings1+u16StrIndex1)>=SecondTblAddr)
                                  { 
                                      if ( LanguageIndex == 1 )
                                      {
                                          pstPropFontSet1218=tPropFontSet1;
                                      }
                                      else if ( LanguageIndex == 2 )
                                      {
                                          pstPropFontSet1218=tPropFontSet2;
                                      }
                                      
                                      if (((pstPropFontSet1218+*(pu8Strings1+u16StrIndex1)-SecondTblAddr)->u8SpaceWidth 
             -& 0xF0)!=0xF0)
                                      {
                                          if(u8BufW>SP_BETWEEN_FONT)
                                              u8BufW-=SP_BETWEEN_FONT;
                                          else if(u8BufW==SP_BETWEEN_FONT)
                                          {
                                              u8BufW=FONT_WIDTH;
                                              SET_LOAD_SINGLE_FONT_FLAG();
                                          }
                                          else// if(u8BufW!=0)  u8BufW<SP_BETWEEN_FONT
                                          {
                                              //u8BufW=FONT_WIDTH-u8BufW;
                                              u8BufW=FONT_WIDTH-(SP_BETWEEN_FONT-u8BufW);
                                              SET_LOAD_SINGLE_FONT_FLAG();
                                          }
                                      }
                                      
                                  }
                                  else
                                  {
                                      pstPropFontSet1218=tPropFontSet;
                                      if (((pstPropFontSet1218+*(pu8Strings1+u16StrIndex1))->u8SpaceWidth & 0xF0)!=0xF0)
                                      {
                                          if(u8BufW>SP_BETWEEN_FONT)
                                              u8BufW-=SP_BETWEEN_FONT;
                                          else if(u8BufW==SP_BETWEEN_FONT)
                                          {
                                              u8BufW=FONT_WIDTH;
                                              SET_LOAD_SINGLE_FONT_FLAG();
C51 COMPILER V9.01   LOADPROPFONT1218                                                      03/09/2023 15:39:10 PAGE 16  

                                          }
                                          else// if(u8BufW!=0)  u8BufW<SP_BETWEEN_FONT
                                          {
                                              //u8BufW=FONT_WIDTH-u8BufW;
                                              u8BufW=FONT_WIDTH-(SP_BETWEEN_FONT-u8BufW);
                                              SET_LOAD_SINGLE_FONT_FLAG();
                                          }
                                      }
              
                                  }
                              }
                              #else
                              if (((pstPropFontSet1218+*(pu8Strings1+u16StrIndex1))->u8SpaceWidth & 0xF0)!=0xF0)
                              {
              
                                  if(u8BufW1>SP_BETWEEN_FONT)
                                      u8BufW1-=SP_BETWEEN_FONT;
                                  else if(u8BufW1==SP_BETWEEN_FONT)
                                  {
                                      u8BufW1=FONT_WIDTH;
                                      SET_LOAD_SINGLE_FONT1_FLAG();
                                  }
                                  else
                                  {
                                      //u8BufW1=FONT_WIDTH-u8BufW1;
                                      u8BufW1=FONT_WIDTH-(SP_BETWEEN_FONT-u8BufW1);
                                      SET_LOAD_SINGLE_FONT1_FLAG();
                                  }
                              }
                              #endif
                              
                              u16StrIndex1++;
                              
                              #if PropFontUseCommonArea
                              {
                                  if (*(pu8Strings1+u16StrIndex1)>=SecondTblAddr)
                                  { 
                                      if ( LanguageIndex == 1 )
                                      {
                                          pstPropFontSet1218=tPropFontSet1;
                                          pstFontData1 = pstPropFontSet1218+*(pu8Strings1+u16StrIndex1)-SecondTblAddr;
                                      }
                                      else if ( LanguageIndex == 2 )
                                      {
                                          pstPropFontSet1218=tPropFontSet2;
                                          pstFontData1 = pstPropFontSet1218+*(pu8Strings1+u16StrIndex1)-SecondTblAddr;
                                      }
                                  }
                                  else
                                  {
                                      pstPropFontSet1218=tPropFontSet;
                                      pstFontData1 = pstPropFontSet1218+*(pu8Strings1+u16StrIndex1);
                                  }
                              }
                              #else
                              pstFontData1 = pstPropFontSet1218+*(pu8Strings1+u16StrIndex1);
                              #endif
                              if ((pstFontData1->u8SpaceWidth & 0xF0)==0xF0)
                                  u8NextFontW1 = (pstFontData1->u8SpaceWidth & 0x0F);
                              else
                                  u8NextFontW1 = (FONT_WIDTH -( (pstFontData1->u8SpaceWidth & 0x0F) + ((pstFontData1->u8
             -SpaceWidth & 0xF0)>>4) ));
C51 COMPILER V9.01   LOADPROPFONT1218                                                      03/09/2023 15:39:10 PAGE 17  

                              u8NextBit1=0;
                              if(*(pu8Strings1+u16StrIndex1) == 0x00)
                              {
                                  if(u8BufW1<(FONT_WIDTH-SP_BETWEEN_FONT))
                                  {
                                      SET_LOAD_SINGLE_FONT1_FLAG();
                                  }
                                  SET_STR1_1ST_CHAR_FLAG();
                                  u16StrIndex1++;
                              }
                          }
                      }
                      else if(u16StrIndex1 >= u16FontCount1)
                      {
                          if(u8BufW1)
                              u8BufW1 = 0;
                          SET_LOAD_SINGLE_FONT1_FLAG();
                      }
              
                      if(LOAD_SINGLE_FONT_FLAG&&LOAD_SINGLE_FONT1_FLAG)
                      {
              #if 0
                          if(LOAD_SINGLE_LINE_FLAG)
                          {
                              ShiftFontUpDown(tSN, u8UDShift);
                          }
                          else//if(!IsLoadsingleLine)
                          {
                              ShiftFontUpDown(tSN, u8UDShift);
                              ShiftFontUpDown(tSN1,u8UDShift1);
                              MergeFontBuf(tSN, tSN1);
                          }
                          OSDLoadOneFont(tSN);
                          u8FontCnt++;
                          ClearFontBuf(tSN);
                          ClearFontBuf(tSN1);
              #else   //Jison, Speed up
                          if(LOAD_SINGLE_LINE_FLAG)
                          {
                              if (u8UDShift&0x7F)
                                  ShiftFontUpDown(tSN, u8UDShift);
                              if (g_u8ByPassLength)
                                  g_u8ByPassLength--;
                              else
                              {
                                  OSDLoadOneFont(tSN);
                                  u8FontCnt++;
                              }
                              ClearFontBuf(tSN);
                          }
                          else
                          {
                              if (u8UDShift&0x7F)
                                  ShiftFontUpDown(tSN, u8UDShift);
                              if (u8UDShift1&0x7F)
                                  ShiftFontUpDown(tSN1,u8UDShift1);
                              MergeFontBuf(tSN, tSN1);
                              OSDLoadOneFont(tSN);
                              u8FontCnt++;
                              ClearFontBuf(tSN);
                              ClearFontBuf(tSN1);
                          }
C51 COMPILER V9.01   LOADPROPFONT1218                                                      03/09/2023 15:39:10 PAGE 18  

              #endif
                          CLR_LOAD_SINGLE_FONT_FLAG();
                          CLR_LOAD_SINGLE_FONT1_FLAG();
                      }
              
                  }
                  //msWriteByte(OSDIOA, OWEND_B|OSBM_B|ORBW_B);
                  return u8FontCnt;
              }
              
              #if 0//ENABLE_PERSONALIZE_MENU
              //u8UDShift, Bit 7==1 means shift up
              //u16Size is the total bytes of u8FontTbl
              //for 12x18 only
              //The font table must not be compressed format.
              BYTE LoadShiftBmpFont(BYTE u8Addr, BYTE *u8FontTbl, WORD u16Size, BYTE u8UDShift)
              {
                  WORD i;
                  BYTE j,u8FontCnt=0;
                  WORD  idata tSN[FONT_HEIGHT];
              
                  msWriteByte(OSD2_A3, u8Addr);
                  i=0;
                  while(u8FontCnt<u16Size/27)
                  {
                      for (j=0;j<18;j+=2,i+=3) //Load on font to buffer
                      {
                          tSN[j]=u8FontTbl[i]&0x0f;
                          tSN[j]<<=8;
                          tSN[j]+=u8FontTbl[i+1];
                          tSN[j+1]=u8FontTbl[i]&0xf0;
                          tSN[j+1]<<=4;
                          tSN[j+1]+=u8FontTbl[i+2];
                      }
                      if (u8UDShift&0x7F)
                          ShiftFontUpDown(tSN, u8UDShift);
                      OSDLoadOneFont(tSN);
                      u8FontCnt++;
                  }
                  return u8FontCnt;
              }
              #endif
              
              #endif
1064          
1065          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2286    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     11      69
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      18
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

C51 COMPILER V9.01   I2C                                                                   03/09/2023 15:39:21 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE I2C
OBJECT MODULE PLACED IN .\obj\i2c.obj
COMPILER INVOKED BY: D:\Keil4\C51\BIN\C51.EXE ..\..\KERNEL\SYSTEM\i2c.c OPTIMIZE(SIZE) BROWSE INCDIR(..\..\DRIVER\INC;..
                    -\..\KERNEL\SCALER\INC;..\..\KERNEL\SYSTEM\INC;..\..\LIB\INC;..\..\PANEL\INC;..\..\BOARD;..\..\DRIVER\INC;..\..\KERNEL\SY
                    -STEM\INC\AOC2011;..\..\DRIVER\extDEVICE\INC;..\..\MODEL;..\..\CONFIG;..\..\PANEL;..\..\UI\F_LOGO\INC;..\..\UI\HkcOsd\INC
                    -) DEFINE(ModelName=JRY_TESTBOARD_C_BOARD) DEBUG OBJECTEXTEND PRINT(.\list\i2c.lst) OBJECT(.\obj\i2c.obj)

line level    source

   1          #include "types.h"
   2          #include "i2cdef.h"
   3          #include "board.h"
   4          #include "debug.h"
   5          #include "misc.h"
   6          #include "global.h"
   7          #include <math.h>
   8          #include <intrins.h>
   9          #include "GPIO_DEF.h"
  10          #include "ms_reg.h"
  11          #include "ms_rwreg.h"
  12          
  13          #define i2cSlaveAddr(deviceID, addr)    deviceID|((addr>>8)<<1)
  14          #define i2cWordAddr(addr)                       addr&0xFF
  15          
  16          #define NVRAM_RETRY     2
  17          
  18          #if     UseI2cByTableFunc
              
              #include "GPIO_DEF.h"
              #include "ms_reg.h"
              #include "ms_rwreg.h"
              
              #message "Çë×¢ÒâÅäÖÃ I2C IO¿Ú"
              
              #if CHIP_ID>=CHIP_TSUMV
              #define FREE_I2C_PIN_IOO                _REG_GPIO2_OUT  
              #define FREE_I2C_PIN_IOI                        _REG_GPIO2_IN
              #define FREE_I2C_PIN_OEZ                _REG_GPIO2_OEZ
              #define FREE_I2C_PIN_ADD                _BIT0   
              #else
              #define FREE_I2C_PIN_IOO                _REG_GPIO2_OUT  
              #define FREE_I2C_PIN_IOI                        _REG_GPIO2_IN
              #define FREE_I2C_PIN_OEZ                _REG_GPIO2_OEZ
              #define FREE_I2C_PIN_ADD                _BIT0
              #endif
              
              
              #if CHIP_ID>=CHIP_TSUMV
              
              
              //1  A  41 40 D0 35 34 D1 33 32
              WORD code  IOO_REGADD[]=
              {
              #if I2C_GPIO40_41
              (_REG_GPIO4_OUT),
              #endif
              #if I2C_GPIO34_35
              (_REG_GPIO3_OUT),
              #endif
              #if I2C_GPIO32_33
              (_REG_GPIO3_OUT),
C51 COMPILER V9.01   I2C                                                                   03/09/2023 15:39:21 PAGE 2   

              #endif
              (FREE_I2C_PIN_IOO),
              };
              WORD code  IOI_REGADD[]=
              {
              #if I2C_GPIO40_41
              (_REG_GPIO4_IN),
              #endif
              #if I2C_GPIO34_35
              (_REG_GPIO3_IN),
              #endif
              #if I2C_GPIO32_33
              (_REG_GPIO3_IN),
              #endif
              (FREE_I2C_PIN_IOI),
              };
              
              BYTE code IO_bit_SDA[]=
              {
              #if I2C_GPIO40_41
              (_BIT1),
              #endif
              #if I2C_GPIO34_35
              (_BIT5),
              #endif
              #if I2C_GPIO32_33
              (_BIT3),
              #endif
              (FREE_I2C_PIN_ADD),
              };
              BYTE code IO_bit_SCL[]=
              {
              #if I2C_GPIO40_41
              (_BIT0),
              #endif
              #if I2C_GPIO34_35
              (_BIT4),
              #endif
              #if I2C_GPIO32_33
              (_BIT2),
              #endif
              (FREE_I2C_PIN_ADD),
              };
              WORD code  IOEZ_REGADD[]=
              {
              #if I2C_GPIO40_41
              (_REG_GPIO4_OEZ),
              #endif
              #if I2C_GPIO34_35
              (_REG_GPIO3_OEZ),
              #endif
              #if I2C_GPIO32_33
              (_REG_GPIO3_OEZ),
              #endif
              (FREE_I2C_PIN_OEZ),
              };
              
              
              #else
              
              
              //1   A 22 21  D0        13 12          D1  17 16   D2  11 10
C51 COMPILER V9.01   I2C                                                                   03/09/2023 15:39:21 PAGE 3   

              WORD code  IOO_REGADD[]=
              {
              #if I2C_GPIO21_22
              (_REG_PMGPIO2_OUT),//A0
              #endif
              #if I2C_GPIO12_13
              (_REG_PMGPIO1_OUT),//D0
              #endif
              #if I2C_GPIO16_17
              (_REG_PMGPIO1_OUT),//D1
              #endif
              #if I2C_GPIO10_11
              (_REG_PMGPIO1_OUT),//D2
              #endif
              (FREE_I2C_PIN_IOO),     //N/A
              };
              WORD code  IOI_REGADD[]=
              {
              #if I2C_GPIO21_22
              (_REG_PMGPIO2_IN),
              #endif
              #if I2C_GPIO12_13
              (_REG_PMGPIO1_IN),      
              #endif
              #if I2C_GPIO16_17
              (_REG_PMGPIO1_IN),
              #endif
              #if I2C_GPIO10_11
              (_REG_PMGPIO1_IN),
              #endif
              (FREE_I2C_PIN_IOI),
              };
              
              BYTE code IO_bit_SDA[]=
              {
              #if I2C_GPIO21_22
              (_BIT2),
              #endif
              #if I2C_GPIO12_13
              (_BIT3),        
              #endif
              #if I2C_GPIO16_17
              (_BIT7),
              #endif
              #if I2C_GPIO10_11
              (_BIT1),
              #endif
              (FREE_I2C_PIN_ADD),
              };
              BYTE code IO_bit_SCL[]=
              {
              #if I2C_GPIO21_22
              (_BIT1),
              #endif
              #if I2C_GPIO12_13
              (_BIT2),
              #endif
              #if I2C_GPIO16_17
              (_BIT6),
              #endif
              #if I2C_GPIO10_11
              (_BIT0),
C51 COMPILER V9.01   I2C                                                                   03/09/2023 15:39:21 PAGE 4   

              #endif
              (FREE_I2C_PIN_ADD),
              };
              WORD code  IOEZ_REGADD[]=
              {
              #if I2C_GPIO21_22
              (_REG_PMGPIO2_OEZ),
              #endif
              #if I2C_GPIO12_13
              (_REG_PMGPIO1_OEZ),     
              #endif
              #if I2C_GPIO16_17
              (_REG_PMGPIO1_OEZ),
              #endif
              #if I2C_GPIO10_11
              (_REG_PMGPIO1_OEZ),
              #endif
              (FREE_I2C_PIN_OEZ),
              };
              
              
              #endif
              
              #define Set_NVRAM_i2c_SDA()                             (MEM_MSWRITE_BIT(IOEZ_REGADD[EnableReadDDCType], TRUE, IO_bit_SDA[Enabl
             -eReadDDCType]))               
              #define Clr_NVRAM_i2c_SDA()                             (MEM_MSWRITE_BIT(IOO_REGADD[EnableReadDDCType], FALSE, IO_bit_SDA[Enabl
             -eReadDDCType]),\
                                                                                                MEM_MSWRITE_BIT(IOEZ_REGADD[EnableReadDDCType], FALSE, IO_bit_SDA[EnableReadDDCType]))        
             -    
              #define NVRAM_i2c_SDA_IS_HI()                   (MEM_MSREAD_BYTE(IOI_REGADD[EnableReadDDCType])&IO_bit_SDA[EnableReadD
             -DCType])
              #define NVRAM_i2c_SDA_IS_LO()                   (!NVRAM_i2c_SDA_IS_HI())  
              
              
              #define Set_NVRAM_i2c_SCL()                             (MEM_MSWRITE_BIT(IOEZ_REGADD[EnableReadDDCType], TRUE, IO_bit_SCL[Enabl
             -eReadDDCType]))               
              #define Clr_NVRAM_i2c_SCL()                             (MEM_MSWRITE_BIT(IOO_REGADD[EnableReadDDCType], FALSE, IO_bit_SCL[Enabl
             -eReadDDCType]),\
                                                                                                MEM_MSWRITE_BIT(IOEZ_REGADD[EnableReadDDCType], FALSE, IO_bit_SCL[EnableReadDDCType]))                
              #define NVRAM_i2c_SCL_IS_HI()                   (MEM_MSREAD_BYTE(IOI_REGADD[EnableReadDDCType])&IO_bit_SCL[EnableReadDD
             -CType])
              #define NVRAM_i2c_SCL_IS_LO()                   (!NVRAM_i2c_SCL_IS_HI())
              
              
              //3  ¡ä?¡¤?¡¤¡§2?¨ª¡§
              /*
              #define Set_NVRAM_i2c_SDA()                             (MEM_MSWRITE_BIT(IOO_REGADD[EnableReadDDCType], TRUE, IO_bit_SDA[Enable
             -ReadDDCType]))                
              #define Clr_NVRAM_i2c_SDA()                             (MEM_MSWRITE_BIT(IOO_REGADD[EnableReadDDCType], FALSE, IO_bit_SDA[Enabl
             -eReadDDCType]))            
              #define NVRAM_i2c_SDA_IS_HI()                   (MEM_MSREAD_BYTE(IOI_REGADD[EnableReadDDCType])&IO_bit_SDA[EnableReadD
             -DCType])
              #define NVRAM_i2c_SDA_IS_LO()                   (!NVRAM_i2c_SDA_IS_HI())        
              
              #define Set_NVRAM_i2c_SCL()                             (MEM_MSWRITE_BIT(IOO_REGADD[EnableReadDDCType], TRUE, IO_bit_SCL[Enable
             -ReadDDCType]))                
              #define Clr_NVRAM_i2c_SCL()                             (MEM_MSWRITE_BIT(IOO_REGADD[EnableReadDDCType], FALSE, IO_bit_SCL[Enabl
             -eReadDDCType]))               
              #define NVRAM_i2c_SCL_IS_HI()                   (MEM_MSREAD_BYTE(IOI_REGADD[EnableReadDDCType])&IO_bit_SCL[EnableReadDD
             -CType])
              #define NVRAM_i2c_SCL_IS_LO()                   (!NVRAM_i2c_SCL_IS_HI())
              */
C51 COMPILER V9.01   I2C                                                                   03/09/2023 15:39:21 PAGE 5   

              
              #endif
 228          
 229          
 230          
 231          
 232          
 233          
 234          #if 0//!USEFLASH  || (defined(UseVGACableReadWriteAllPortsEDID)&&!defined(ReduceDDC)) && !((CHIP_ID == CHI
             -P_TSUM9 || CHIP_ID == CHIP_TSUMF) && ENABLE_CABLE_5V_EDID)
              #define I2C_CHECK       1
              
              #if I2C_CHECK
              #define I2C_CHECK_PIN_DUMMY     500//150//100  
              
              void i2cSCL_Chk(void)
              {
                      BYTE ucDummy = I2C_CHECK_PIN_DUMMY; // initialize dummy         
                      while (i2c_SCLLo() && (ucDummy--))      
                                      ; // check SCL pull high
              }
              #else
              #define i2cSCL_Chk()
              #endif
              
              Bool CheckIICAck(void)
              {
                  BYTE i;
                  for(i=0; i<100; i++)
                  {
                      if(i2c_SDALo())
                          return TRUE;
                      _nop_();
                      _nop_();
                      _nop_();
                      _nop_();
                  }
              
                  if(i2c_SDALo())
                      return TRUE;
                  else
                      return FALSE;
                  
              }
              
              //====================================
              // Setup i2c Start condition
              Bool i2c_Start(void)
              { Set_i2c_SDA();
                Delay4us();
                Set_i2c_SCL();
                Delay4us();
                i2cSCL_Chk();
                if (i2c_SDALo() || i2c_SCLLo())
                  return FALSE;
                Clr_i2c_SDA();
                Delay4us();
                Clr_i2c_SCL();
                return TRUE;
              }
              //=============================================
              // Setup i2c Stop condition
C51 COMPILER V9.01   I2C                                                                   03/09/2023 15:39:21 PAGE 6   

              void i2c_Stop(void)
              { // SCL=L, SDA=L, Stop condition.
                Clr_i2c_SCL();
                Delay4us();
                Clr_i2c_SDA();  
                Delay4us();
                Set_i2c_SCL();
                Delay4us();
                i2cSCL_Chk();
                Set_i2c_SDA();
              
              }
              
              //============================================
              Bool i2c_SendByte(BYTE value)
              { BYTE i;
                Bool result;
                
                for (i=0; i<8; i++) // Send data via i2c pin
                  { if (value&BIT7)
                      Set_i2c_SDA();
                    else
                      Clr_i2c_SDA();      
                    Delay4us();
                    Set_i2c_SCL();      
                    i2cSCL_Chk();
                    value<<=1;
                    Clr_i2c_SCL(); 
                    
                  }
                Set_i2c_SDA();
                Delay4us();
                result = CheckIICAck();
                Set_i2c_SCL();
                i2cSCL_Chk();
                Clr_i2c_SCL();
                Delay4us();
                Clr_i2c_SDA();
                  
                return result;
              }
              
              //============================================
              BYTE i2c_ReceiveByte(const Bool ack)
              { BYTE i;
                BYTE value = 0;
              
                for (i=0; i<8; i++)
                  { value<<=1;
                    Set_i2c_SDA();
              #if Enable_Cache// 090417
                    Delay4us();
              #endif
                    Set_i2c_SCL();
                    Delay4us();
                    i2cSCL_Chk();
                    if (i2c_SDAHi())
                      value|=BIT0;
                    Clr_i2c_SCL();
                  }
                if (ack)
                  Clr_i2c_SDA();
C51 COMPILER V9.01   I2C                                                                   03/09/2023 15:39:21 PAGE 7   

                else
                  Set_i2c_SDA();
                Delay4us();
                Set_i2c_SCL();
                Delay4us();
                i2cSCL_Chk();
                Clr_i2c_SCL();
                
                return value;         
              }
              #if (defined(UseVGACableReadWriteAllPortsEDID)&&!defined(ReduceDDC)) //!USEFLASH 
              Bool i2c_BurstWrite(BYTE count, BYTE *buffer)
              { while (count--)
                  { if (i2c_SendByte(*(buffer++))==FALSE)
                      return FALSE;
                  }
               return TRUE;
              }
              Bool i2c_BurstRead(BYTE count, BYTE * buffer)
              { BYTE i;
              
                for (i=0; i<count-1; i++)
                  *(buffer+i)=i2c_ReceiveByte(1);
                *(buffer+i)=i2c_ReceiveByte(0);
                i2c_Stop();
                return TRUE;
              }
              #endif
              // 090413 modified for iic
              Bool i2c_MasterStart(I2C_Direction direct, BYTE addr)
              {
                  BYTE retry=NVRAM_RETRY;
              
                if (direct==I2C_READ) // Set I2C direction bit.
                  addr|=BIT0;
                else
                  addr&=~BIT0;
                
                while (retry--)
                  { if (i2c_Start()==FALSE)
                      continue;
                    
                    if (i2c_SendByte(addr)==TRUE) // send address success
                      return TRUE;
                    i2c_Stop();
                    ForceDelay1ms(2);
                  }
                return FALSE;
              }
              
              #if (defined(UseVGACableReadWriteAllPortsEDID)&&(!defined(ReduceDDC)))
              #define PageWriteLength         ((LoadEDIDSelectPort<EEPROM)?8:16)
              #define PageWriteDelayTime              ((LoadEDIDSelectPort<EEPROM)?3:12) //edit by lizzie,100429.for the problem: us
             -e HDMI/VGA Cable write all port EDID ,the time to write 32byte is too long
              //ATMEL 24C02 Page Write Buffer is 8 Bytes.
              //MicroChip 24C02 Page Write Buffer is 16 Bytes.
              //ST 24C02 Page Write Buffer is 16 Bytes.
              #else
              #define PageWriteLength         16
              #define PageWriteDelayTime      12 //edit by lizzie,100429.for the problem: use HDMI/VGA Cable write all port E
             -DID ,the time to write 32byte is too long
              #endif
C51 COMPILER V9.01   I2C                                                                   03/09/2023 15:39:21 PAGE 8   

              #if (defined(UseVGACableReadWriteAllPortsEDID)&&!defined(ReduceDDC)) 
              #if 0//def WH_REQUEST
                      #if ENABLE_HDMI
                      void i2c_WriteTBL(BYTE deviceID, WORD addr, BYTE *buffer, WORD count)
                      #else
                      void i2c_WriteTBL(BYTE deviceID, WORD addr, BYTE *buffer, BYTE count)
                      #endif
              #else
              void i2c_WriteTBL(BYTE deviceID, WORD addr, BYTE *buffer, BYTE count)
              #endif
              { BYTE slaveAddr;
                BYTE wordAddr;
                BYTE offset=0;
                BYTE tempSize;
                Bool succ=TRUE;
                
                while (count)
                  { slaveAddr=i2cSlaveAddr(deviceID, addr+offset);
                    wordAddr=i2cWordAddr(addr+offset);
                    if (i2c_MasterStart(I2C_WRITE, slaveAddr)==FALSE)
                      break;
                    if (i2c_BurstWrite(1, &wordAddr)==FALSE)
                      break;
                    tempSize=PageWriteLength-(wordAddr&(PageWriteLength-1));//0x10-(wordAddr&0xF);
                    if (count>tempSize)
                      { if (i2c_BurstWrite(tempSize, (BYTE*)(buffer+offset))==FALSE)
                          break;
                        i2c_Stop();
                        count-=tempSize;
                        offset+=tempSize;
                      }
                    else if (count>PageWriteLength)//0x10)
                      { if (i2c_BurstWrite(0x10, (BYTE*)(buffer+offset))==FALSE)
                          break;
                        i2c_Stop();
                        count-=PageWriteLength;//0x10;
                        offset+=PageWriteLength;//0x10;
                      }
                    else
                      { if (i2c_BurstWrite(count, (BYTE*)(buffer+offset))==FALSE)
                          break;
                        i2c_Stop();
                        count=0;
                      }
                    ForceDelay1ms(PageWriteDelayTime);//edit by lizzie,100429.for the problem: use HDMI/VGA Cable write 
             -all port EDID ,the time to write 32byte is too long
                  }
                i2c_Stop();
              }
              
              void i2c_ReadTBL(BYTE deviceID, WORD addr, BYTE *buffer, BYTE count)
              {  
                 WORD retry=NVRAM_RETRY;
                BYTE slaveAddr;
                BYTE wordAddr;
              
                slaveAddr=i2cSlaveAddr(deviceID, addr);
                wordAddr=i2cWordAddr(addr);
                while (retry--)
                  { if (i2c_MasterStart(I2C_WRITE, slaveAddr)==FALSE)
                      continue;
                    if (i2c_BurstWrite(1, &wordAddr)==FALSE)
C51 COMPILER V9.01   I2C                                                                   03/09/2023 15:39:21 PAGE 9   

                      continue;
                    if (i2c_MasterStart(I2C_READ, slaveAddr)==FALSE)
                      continue;
                    if (i2c_BurstRead(count, buffer)==FALSE)
                      continue;      
                    return;
                  }  
              }
              #endif
              //2004/02/20 num4--Start
              
              
              
              #endif
 484          
 485          
 486          
 487          
 488          
 489          #if 0//!USEFLASH
              void NVRAM_i2c_Delay(void)
              {
                  BYTE i;
                  for(i=0; i<100; i++) // 100: 59K
                      _nop_();
              }
              void NVRAM_i2C_Intial(void)
              {
                BYTE i;
               
                Set_NVRAM_i2c_SDA();
                NVRAM_i2c_Delay();
                Set_NVRAM_i2c_SCL();
                NVRAM_i2c_Delay();
               for(i=0;i<10;i++)
                 {
                   Set_NVRAM_i2c_SCL();
                   NVRAM_i2c_Delay();
                   Clr_NVRAM_i2c_SDA();
                   NVRAM_i2c_Delay();
                   Clr_NVRAM_i2c_SCL();
                   NVRAM_i2c_Delay();
                   Set_NVRAM_i2c_SCL();
                   NVRAM_i2c_Delay();
                   Set_NVRAM_i2c_SDA();
                   NVRAM_i2c_Delay();
                 }
                while(i++ <100)
                 {
                    if(NVRAM_i2c_SDA_IS_HI())
                     break;
               
                     Set_NVRAM_i2c_SCL();
                     NVRAM_i2c_Delay();
                     Clr_NVRAM_i2c_SDA();
                     NVRAM_i2c_Delay();
                     Clr_NVRAM_i2c_SCL();
                     NVRAM_i2c_Delay();
                     Set_NVRAM_i2c_SCL();
                     NVRAM_i2c_Delay();
                     Set_NVRAM_i2c_SDA();
                     NVRAM_i2c_Delay();
C51 COMPILER V9.01   I2C                                                                   03/09/2023 15:39:21 PAGE 10  

                 }
              }
              
              
              #define NVRAM_I2C_CHECK 0
              
              #if NVRAM_I2C_CHECK
              #define NVRAM_I2C_CHECK_PIN_DUMMY       500//150//100  
              
              void NVRAM_i2cSCL_Chk(void)
              {
                      BYTE ucDummy = NVRAM_I2C_CHECK_PIN_DUMMY; // initialize dummy           
                      while (NVRAM_i2c_SCL_IS_LO() && (ucDummy--))    
                                      ; // check SCL pull high
              }
              #else
              #define NVRAM_i2cSCL_Chk()
              #endif
              
              
              Bool NVRAM_CheckIICAck(void)
              {
                  BYTE i;
                  for(i=0; i<100; i++)
                  {
                      if(NVRAM_i2c_SDA_IS_LO())
                          return TRUE;
                      _nop_();
                      _nop_();
                      _nop_();
                      _nop_();
                  }
              
                  if(NVRAM_i2c_SDA_IS_LO())
                      return TRUE;
                  else
                      return FALSE;
                  
              }
              
              //====================================
              // Setup i2c Start condition
              Bool NVRAM_i2c_Start(void)
              {
                Set_NVRAM_i2c_SDA();
                NVRAM_i2c_Delay();
                Set_NVRAM_i2c_SCL();
                NVRAM_i2c_Delay();
                NVRAM_i2cSCL_Chk();
                if (NVRAM_i2c_SDA_IS_LO() || NVRAM_i2c_SCL_IS_LO())
                  return FALSE;
                Clr_NVRAM_i2c_SDA();
                NVRAM_i2c_Delay();
                Clr_NVRAM_i2c_SCL();
                return TRUE;
              }
              //=============================================
              // Setup i2c Stop condition
              void NVRAM_i2c_Stop(void)
              { // SCL=L, SDA=L, Stop condition.
                Clr_NVRAM_i2c_SCL();
                NVRAM_i2c_Delay();
C51 COMPILER V9.01   I2C                                                                   03/09/2023 15:39:21 PAGE 11  

                Clr_NVRAM_i2c_SDA();  
                NVRAM_i2c_Delay();
                Set_NVRAM_i2c_SCL();
                NVRAM_i2c_Delay();
                NVRAM_i2cSCL_Chk();
                Set_NVRAM_i2c_SDA();
              
              }
              
              //============================================
              Bool NVRAM_i2c_SendByte(BYTE value)
              { BYTE i;
                Bool result;
              
                for (i=0; i<8; i++) // Send data via i2c pin
                  { if (value&BIT7)
                      Set_NVRAM_i2c_SDA();
                    else
                      Clr_NVRAM_i2c_SDA();      
                     NVRAM_i2c_Delay();
                    Set_NVRAM_i2c_SCL();    
                    NVRAM_i2c_Delay();
                    NVRAM_i2cSCL_Chk();
                    value<<=1;
                    Clr_NVRAM_i2c_SCL(); 
                    
                  }
                Set_NVRAM_i2c_SDA();
                NVRAM_i2c_Delay();
                result = NVRAM_CheckIICAck();
                Set_NVRAM_i2c_SCL();
                NVRAM_i2c_Delay();
                NVRAM_i2cSCL_Chk();
                Clr_NVRAM_i2c_SCL();
                NVRAM_i2c_Delay();
                Clr_NVRAM_i2c_SDA();
              
                return result;
              }
              
              //============================================
              BYTE NVRAM_i2c_ReceiveByte(const Bool ack)
              { BYTE i;
                BYTE value = 0;
              
                for (i=0; i<8; i++)
                  { value<<=1;
                    Set_NVRAM_i2c_SDA();
              #if Enable_Cache// 090417
                    NVRAM_i2c_Delay();
              #endif
                    Set_NVRAM_i2c_SCL();
                    NVRAM_i2c_Delay();
                    NVRAM_i2cSCL_Chk();
                    if (NVRAM_i2c_SDA_IS_HI())
                      value|=BIT0;
                    Clr_NVRAM_i2c_SCL();
                  }
                if (ack)
                  Clr_NVRAM_i2c_SDA();
                else
                  Set_NVRAM_i2c_SDA();
C51 COMPILER V9.01   I2C                                                                   03/09/2023 15:39:21 PAGE 12  

                NVRAM_i2c_Delay();
                Set_NVRAM_i2c_SCL();
                NVRAM_i2c_Delay();
                NVRAM_i2cSCL_Chk();
                Clr_NVRAM_i2c_SCL();
                
                return value;         
              }
              
              Bool NVRAM_i2c_MasterStart(I2C_Direction direct, BYTE addr)
              {
                  BYTE retry=NVRAM_RETRY;
              
                if (direct==I2C_READ) // Set I2C direction bit.
                  addr|=BIT0;
                else
                  addr&=~BIT0;
                
                while (retry--)
                  { if (NVRAM_i2c_Start()==FALSE)
                      continue;
                    
                    if (NVRAM_i2c_SendByte(addr)==TRUE) // send address success
                      {
                      //printMsg("SendByte TRUE");
                      return TRUE;
                      }
                    NVRAM_i2c_Stop();
                    
                    //printMsg("SendByte Fail");
                    ForceDelay1ms(2);
                  }
                return FALSE;
              }
              
              #if EEPROM_TYPE >= EEPROM_24C32
              #define NVRAMPageWriteLength            32
              #else
              #define NVRAMPageWriteLength            16
              #endif
              #define NVRAMPageWriteDelayTime 12 //edit by lizzie,100429.for the problem: use HDMI/VGA Cable write all p
             -ort EDID ,the time to write 32byte is too long
              
              #if EEPROM_TYPE >= EEPROM_24C32
              void rmSWPageWrite(WORD wIndex, BYTE *pBuf, BYTE ucBufLen)
              {
                      BYTE ucDummy; // loop dummy
                      //CHECK_PROTECT;
                      ucDummy = NVRAM_RETRY;
                      while(ucDummy--)
                      {
                              if (NVRAM_i2c_MasterStart(I2C_WRITE, 0xA0) == FALSE)
                                      continue;
              
                              if (NVRAM_i2c_SendByte(HIBYTE(wIndex)) == FALSE) // check non-acknowledge
                                      continue;
              
                              if (NVRAM_i2c_SendByte(LOBYTE(wIndex)) == FALSE) // check non-acknowledge
                                      continue;
              
                              while(ucBufLen--) // loop of writting data
                              {
C51 COMPILER V9.01   I2C                                                                   03/09/2023 15:39:21 PAGE 13  

                                      NVRAM_i2c_SendByte(*pBuf); // send byte
              
                                      pBuf++; // next byte pointer
                              } // while
              
                              break;
                      } // while
              
                      NVRAM_i2c_Stop();
              }
              
              void rmSWBurstReadBytes(WORD wIndex, BYTE *pBuf, BYTE ucBufLen)
              {
                  BYTE ucDummy; // loop dummy
              
                  ucDummy = NVRAM_RETRY;
                  while(ucDummy--)
                  {
                      if (NVRAM_i2c_MasterStart(I2C_WRITE, 0xA0) == FALSE)
                          continue;
              
                      if (NVRAM_i2c_SendByte(HIBYTE(wIndex)) == FALSE) // check non-acknowledge
                          continue;
              
                      if (NVRAM_i2c_SendByte(LOBYTE(wIndex)) == FALSE) // check non-acknowledge
                          continue;
              
                      if (NVRAM_i2c_MasterStart(I2C_READ, 0xA0) == FALSE)
                          continue;
              
                      while(ucBufLen) // loop to burst read
                      {
                          ucBufLen--;
                          *pBuf = NVRAM_i2c_ReceiveByte(ucBufLen); // receive byte
                          pBuf++; // next byte pointer
                      } // while
              
                      break;
                  } // while
              
                  NVRAM_i2c_Stop();
              
                  while(ucBufLen--) // if read error, fill 0xff
                  {
                      *pBuf = 0xff; // clear
                      pBuf++; // next byte pointer
                  } // while
              }
              
              void rmBurstWriteBytes(WORD wIndex, BYTE *pBuf, WORD ucBufLen)
              {
                  BYTE ucWriteCount; // write counter
                  BYTE ucRemainLen; // i2c word address
                      //CHECK_PROTECT;
                  while(1)
                  {
                      // check page write roll over
                      if (ucBufLen > NVRAMPageWriteLength)
                          ucWriteCount = NVRAMPageWriteLength;
                      else
                          ucWriteCount = ucBufLen;
              
C51 COMPILER V9.01   I2C                                                                   03/09/2023 15:39:21 PAGE 14  

                      // check word address higher than page write bits
                      ucRemainLen = LOBYTE(wIndex) % NVRAMPageWriteLength;
                      if (ucRemainLen) // check ramain
                      {
                          ucRemainLen = NVRAMPageWriteLength - ucRemainLen;
                          if (ucWriteCount > ucRemainLen) // check not roll over
                              ucWriteCount = ucRemainLen;
                      }
              
                      // EEPROM page write
                      rmSWPageWrite(wIndex, pBuf, ucWriteCount);
                              
                      // check end of buffer
                      ucBufLen -= ucWriteCount;
                      if (ucBufLen == 0)
                          break;
              
                      wIndex += ucWriteCount; // next word address
                      pBuf += ucWriteCount; // next buffer pointer
                      
                      ForceDelay1ms(NVRAMPageWriteDelayTime);//edit by lizzie,100429.for the problem: use HDMI/VGA Cable
             - write all port EDID ,the time to write 32byte is too long
              
                  } // while
              
              }
              #else
              Bool NVRAM_i2c_BurstWrite(BYTE count, BYTE *buffer)
              { while (count--)
                  { if (NVRAM_i2c_SendByte(*(buffer++))==FALSE)
                      return FALSE;
                  }
               return TRUE;
              }
              
              Bool NVRAM_i2c_BurstRead(BYTE count, BYTE * buffer)
              { BYTE i;
              
                for (i=0; i<count-1; i++)
                  *(buffer+i)=NVRAM_i2c_ReceiveByte(1);
                *(buffer+i)=NVRAM_i2c_ReceiveByte(0);
                NVRAM_i2c_Stop();
                return TRUE;
              }
              
               void NVRAM_i2c_WriteTBL(BYTE deviceID, WORD addr, BYTE *buffer, BYTE count)
              { BYTE slaveAddr;
                BYTE wordAddr;
                BYTE offset=0;
                BYTE tempSize;
                Bool succ=TRUE;
                
                while (count)
                  { slaveAddr=i2cSlaveAddr(deviceID, addr+offset);
                    wordAddr=i2cWordAddr(addr+offset);
                    if (NVRAM_i2c_MasterStart(I2C_WRITE, slaveAddr)==FALSE)
                      break;
                    if (NVRAM_i2c_BurstWrite(1, &wordAddr)==FALSE)
                      break;
                    tempSize=NVRAMPageWriteLength-(wordAddr&(NVRAMPageWriteLength-1));//0x10-(wordAddr&0xF);
                    if (count>tempSize)
                      { if (NVRAM_i2c_BurstWrite(tempSize, (BYTE*)(buffer+offset))==FALSE)
C51 COMPILER V9.01   I2C                                                                   03/09/2023 15:39:21 PAGE 15  

                          break;
                        NVRAM_i2c_Stop();
                        count-=tempSize;
                        offset+=tempSize;
                      }
                    else if (count>NVRAMPageWriteLength)//0x10)
                      { if (NVRAM_i2c_BurstWrite(0x10, (BYTE*)(buffer+offset))==FALSE)
                          break;
                        NVRAM_i2c_Stop();
                        count-=NVRAMPageWriteLength;//0x10;
                        offset+=NVRAMPageWriteLength;//0x10;
                      }
                    else
                      { if (NVRAM_i2c_BurstWrite(count, (BYTE*)(buffer+offset))==FALSE)
                          break;
                          NVRAM_i2c_Stop();
                        count=0;
                      }
                    ForceDelay1ms(NVRAMPageWriteDelayTime);//edit by lizzie,100429.for the problem: use HDMI/VGA Cable w
             -rite all port EDID ,the time to write 32byte is too long
                  }
                NVRAM_i2c_Stop();
              }
              
              void NVRAM_i2c_ReadTBL(BYTE deviceID, WORD addr, BYTE *buffer, BYTE count)
              {  
                 WORD retry=NVRAM_RETRY;
                BYTE slaveAddr;
                BYTE wordAddr;
              
                slaveAddr=i2cSlaveAddr(deviceID, addr);
                wordAddr=i2cWordAddr(addr);
                while (retry--)
                  { if (NVRAM_i2c_MasterStart(I2C_WRITE, slaveAddr)==FALSE)
                      continue;
                    if (NVRAM_i2c_BurstWrite(1, &wordAddr)==FALSE)
                      continue;
                    if (NVRAM_i2c_MasterStart(I2C_READ, slaveAddr)==FALSE)
                      continue;
                    if (NVRAM_i2c_BurstRead(count, buffer)==FALSE)
                      continue;      
                    return;
                  }  
              }
              
              #endif
              #else
 886          
 887          #if (VGA_Write_EEPROM||DVI_Write_EEPROM||HDMI_Write_EEPROM)//LoadDefault_DVI_EDIDTo24C02//def Internal_EDI
             -D_Write_To_24C02
 888          
 889          #if USEFLASH
 890          #define NVRAMPageWriteLength            16
 891          
 892          #define NVRAMPageWriteDelayTime 5
 893          
 894          Bool NVRAM_CheckIICAck(void)
 895          {
 896   1          BYTE i;
 897   1          for(i=0; i<100; i++)
 898   1          {
 899   2              if(NVRAM_i2c_SDA_IS_LO())
C51 COMPILER V9.01   I2C                                                                   03/09/2023 15:39:21 PAGE 16  

 900   2                  return TRUE;
 901   2              _nop_();
 902   2              _nop_();
 903   2              _nop_();
 904   2              _nop_();
 905   2          }
 906   1      
 907   1          if(NVRAM_i2c_SDA_IS_LO())
 908   1              return TRUE;
 909   1          else
 910   1              return FALSE;
 911   1          
 912   1      }
 913          /////////////////////////////////////////
 914          void NVRAM_i2c_Delay(void)
 915          {
 916   1          BYTE i;
 917   1          for(i=0; i<100; i++) // 100: 59K
 918   1              _nop_();
 919   1      }
 920          //====================================
 921          // Setup i2c Start condition
 922          Bool NVRAM_i2c_Start(void)
 923          {
 924   1        Set_NVRAM_i2c_SDA();
 925   1        NVRAM_i2c_Delay();
 926   1        Set_NVRAM_i2c_SCL();
 927   1        NVRAM_i2c_Delay();
 928   1        //NVRAM_i2cSCL_Chk();
 929   1        if (NVRAM_i2c_SDA_IS_LO() || NVRAM_i2c_SCL_IS_LO())
 930   1          return FALSE;
 931   1        Clr_NVRAM_i2c_SDA();
 932   1        NVRAM_i2c_Delay();
 933   1        Clr_NVRAM_i2c_SCL();
 934   1        return TRUE;
 935   1      }
 936          //============================================
 937          Bool NVRAM_i2c_SendByte(BYTE value)
 938          { BYTE i;
 939   1        Bool result;
 940   1      
 941   1        for (i=0; i<8; i++) // Send data via i2c pin
 942   1          { if (value&BIT7)
 943   2              Set_NVRAM_i2c_SDA();
 944   2            else
 945   2              Clr_NVRAM_i2c_SDA();      
 946   2             NVRAM_i2c_Delay();
 947   2            Set_NVRAM_i2c_SCL();    
 948   2            NVRAM_i2c_Delay();
 949   2            //NVRAM_i2cSCL_Chk();
 950   2            value<<=1;
 951   2            Clr_NVRAM_i2c_SCL(); 
 952   2            
 953   2          }
 954   1        Set_NVRAM_i2c_SDA();
 955   1        NVRAM_i2c_Delay();
 956   1        result = NVRAM_CheckIICAck();
 957   1        Set_NVRAM_i2c_SCL();
 958   1        NVRAM_i2c_Delay();
 959   1        //NVRAM_i2cSCL_Chk();
 960   1        Clr_NVRAM_i2c_SCL();
 961   1        NVRAM_i2c_Delay();
C51 COMPILER V9.01   I2C                                                                   03/09/2023 15:39:21 PAGE 17  

 962   1        Clr_NVRAM_i2c_SDA();
 963   1      
 964   1        return result;
 965   1      }
 966          
 967          //============================================
 968          BYTE NVRAM_i2c_ReceiveByte(const Bool ack)
 969          { BYTE i;
 970   1        BYTE value = 0;
 971   1      
 972   1        for (i=0; i<8; i++)
 973   1          { value<<=1;
 974   2            Set_NVRAM_i2c_SDA();
 975   2      #if Enable_Cache// 090417
 976   2            NVRAM_i2c_Delay();
 977   2      #endif
 978   2            Set_NVRAM_i2c_SCL();
 979   2            NVRAM_i2c_Delay();
 980   2            //NVRAM_i2cSCL_Chk();
 981   2            if (NVRAM_i2c_SDA_IS_HI())
 982   2              value|=BIT0;
 983   2            Clr_NVRAM_i2c_SCL();
 984   2          }
 985   1        if (ack)
 986   1          Clr_NVRAM_i2c_SDA();
 987   1        else
 988   1          Set_NVRAM_i2c_SDA();
 989   1        NVRAM_i2c_Delay();
 990   1        Set_NVRAM_i2c_SCL();
 991   1        NVRAM_i2c_Delay();
 992   1        //NVRAM_i2cSCL_Chk();
 993   1        Clr_NVRAM_i2c_SCL();
 994   1        
 995   1        return value;         
 996   1      }
 997          // Setup i2c Stop condition
 998          void NVRAM_i2c_Stop(void)
 999          { // SCL=L, SDA=L, Stop condition.
1000   1        Clr_NVRAM_i2c_SCL();
1001   1        NVRAM_i2c_Delay();
1002   1        Clr_NVRAM_i2c_SDA();  
1003   1        NVRAM_i2c_Delay();
1004   1        Set_NVRAM_i2c_SCL();
1005   1        NVRAM_i2c_Delay();
1006   1        //NVRAM_i2cSCL_Chk();
1007   1        Set_NVRAM_i2c_SDA();
1008   1      
1009   1      }
1010          Bool NVRAM_i2c_BurstRead(BYTE count, BYTE * buffer)
1011          { BYTE i;
1012   1      
1013   1        for (i=0; i<count-1; i++)
1014   1          *(buffer+i)=NVRAM_i2c_ReceiveByte(1);
1015   1        *(buffer+i)=NVRAM_i2c_ReceiveByte(0);
1016   1        NVRAM_i2c_Stop();
1017   1        return TRUE;
1018   1      }
1019          //=============================================
1020          
1021          
1022          Bool NVRAM_i2c_BurstWrite(BYTE count, BYTE *buffer)
1023          { while (count--)
C51 COMPILER V9.01   I2C                                                                   03/09/2023 15:39:21 PAGE 18  

1024   1          { if (NVRAM_i2c_SendByte(*(buffer++))==FALSE)
1025   2              return FALSE;
1026   2          }
1027   1       return TRUE;
1028   1      }
1029          Bool NVRAM_i2c_MasterStart(I2C_Direction direct, BYTE addr)
1030          {
1031   1          BYTE retry=NVRAM_RETRY;
1032   1      
1033   1        if (direct==I2C_READ) // Set I2C direction bit.
1034   1          addr|=BIT0;
1035   1        else
1036   1          addr&=~BIT0;
1037   1        
1038   1        while (retry--)
1039   1          { if (NVRAM_i2c_Start()==FALSE)
1040   2              continue;
1041   2            
1042   2            if (NVRAM_i2c_SendByte(addr)==TRUE) // send address success
1043   2              {
1044   3              //printMsg("SendByte TRUE");
1045   3              return TRUE;
1046   3              }
1047   2            NVRAM_i2c_Stop();
1048   2            
1049   2            //printMsg("SendByte Fail");
1050   2            ForceDelay1ms(2);
1051   2          }
1052   1        return FALSE;
1053   1      }
1054           void NVRAM_i2c_WriteTBL(BYTE deviceID, WORD addr, BYTE *buffer, BYTE count)
1055          { BYTE slaveAddr;
1056   1        BYTE wordAddr;
1057   1        BYTE offset=0;
1058   1        BYTE tempSize;
1059   1        Bool succ=TRUE;
1060   1        
1061   1        while (count)
1062   1          { slaveAddr=i2cSlaveAddr(deviceID, addr+offset);
1063   2            wordAddr=i2cWordAddr(addr+offset);
1064   2            if (NVRAM_i2c_MasterStart(I2C_WRITE, slaveAddr)==FALSE)
1065   2              break;
1066   2            if (NVRAM_i2c_BurstWrite(1, &wordAddr)==FALSE)
1067   2              break;
1068   2            tempSize=NVRAMPageWriteLength-(wordAddr&(NVRAMPageWriteLength-1));//0x10-(wordAddr&0xF);
1069   2            if (count>tempSize)
1070   2              { if (NVRAM_i2c_BurstWrite(tempSize, (BYTE*)(buffer+offset))==FALSE)
1071   3                  break;
1072   3                NVRAM_i2c_Stop();
1073   3                count-=tempSize;
1074   3                offset+=tempSize;
1075   3              }
1076   2            else if (count>NVRAMPageWriteLength)//0x10)
1077   2              { if (NVRAM_i2c_BurstWrite(0x10, (BYTE*)(buffer+offset))==FALSE)
1078   3                  break;
1079   3                NVRAM_i2c_Stop();
1080   3                count-=NVRAMPageWriteLength;//0x10;
1081   3                offset+=NVRAMPageWriteLength;//0x10;
1082   3              }
1083   2            else
1084   2              { if (NVRAM_i2c_BurstWrite(count, (BYTE*)(buffer+offset))==FALSE)
1085   3                  break;
C51 COMPILER V9.01   I2C                                                                   03/09/2023 15:39:21 PAGE 19  

1086   3                  NVRAM_i2c_Stop();
1087   3                count=0;
1088   3              }
1089   2            ForceDelay1ms(NVRAMPageWriteDelayTime);//edit by lizzie,100429.for the problem: use HDMI/VGA Cable w
             -rite all port EDID ,the time to write 32byte is too long
1090   2          }
1091   1        NVRAM_i2c_Stop();
1092   1      }
1093          void NVRAM_i2c_ReadTBL(BYTE deviceID, WORD addr, BYTE *buffer, BYTE count)
1094          {  
1095   1         WORD retry=NVRAM_RETRY;
1096   1        BYTE slaveAddr;
1097   1        BYTE wordAddr;
1098   1      
1099   1        slaveAddr=i2cSlaveAddr(deviceID, addr);
1100   1        wordAddr=i2cWordAddr(addr);
1101   1        while (retry--)
1102   1          { if (NVRAM_i2c_MasterStart(I2C_WRITE, slaveAddr)==FALSE)
1103   2              continue;
1104   2            if (NVRAM_i2c_BurstWrite(1, &wordAddr)==FALSE)
1105   2              continue;
1106   2            if (NVRAM_i2c_MasterStart(I2C_READ, slaveAddr)==FALSE)
1107   2              continue;
1108   2            if (NVRAM_i2c_BurstRead(count, buffer)==FALSE)
1109   2              continue;      
1110   2            return;
1111   2          }  
1112   1      }
1113          #endif
1114          #endif
1115          
1116          #endif
1117          
1118          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1782    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      31
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

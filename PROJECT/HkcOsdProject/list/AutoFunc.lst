C51 COMPILER V9.01   AUTOFUNC                                                              03/09/2023 15:39:19 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE AUTOFUNC
OBJECT MODULE PLACED IN .\obj\AutoFunc.obj
COMPILER INVOKED BY: D:\Keil4\C51\BIN\C51.EXE ..\..\KERNEL\SCALER\AutoFunc.c OPTIMIZE(SIZE) BROWSE INCDIR(..\..\DRIVER\I
                    -NC;..\..\KERNEL\SCALER\INC;..\..\KERNEL\SYSTEM\INC;..\..\LIB\INC;..\..\PANEL\INC;..\..\BOARD;..\..\DRIVER\INC;..\..\KERN
                    -EL\SYSTEM\INC\AOC2011;..\..\DRIVER\extDEVICE\INC;..\..\MODEL;..\..\CONFIG;..\..\PANEL;..\..\UI\F_LOGO\INC;..\..\UI\HkcOs
                    -d\INC) DEFINE(ModelName=JRY_TESTBOARD_C_BOARD) DEBUG OBJECTEXTEND PRINT(.\list\AutoFunc.lst) OBJECT(.\obj\AutoFunc.obj)

line level    source

   1          #include <math.h>
   2          #include "types.h"
   3          #include "board.h"
   4          #include "global.h"
   5          #include "ms_reg.h"
   6          #include "adjust.h"
   7          #include "ms_rwreg.h"
   8          #include "misc.h"
   9          #include "debug.h"
  10          #include "power.h"
  11          #include "panel.h"
  12          #include "drvadc.h"
  13          #include "mstar.h"
  14          #ifdef TSUMXXT//#if (ChipID == TSUMXXT)         //110311 Modify
              #include "MsADC.h"
              #endif
  17          
  18          /////////////////////////////////////
  19          #include "drvmStar.h"
  20          ////////////////////////////////////
  21          
  22          #define UseWorstPhase   0
  23          #define EvenClock   0
  24          #define QuickAuto   0
  25          #define OverFlow    BIT7
  26          #define NoneOverFlow    BIT6
  27          #define UnderFlow   BIT7
  28          #define NoneUnderFlow   BIT6
  29          //===============================================================
  30          // local declaration
  31          Bool mStar_AutoAdcColor(BYTE vsyncTime);
  32          void CheckDosTextHtotal(BYTE vsyncTime);
  33          //===============================================================
  34          // Code
  35          Bool CheckSyncLoss(void)
  36          {
  37   1          #if UseINT
  38   1              if (InputTimingChangeFlag)
  39   1              {
  40   2                  Power_TurnOffPanel();
  41   2                  return TRUE;
  42   2              }
  43   1              else
  44   1              {
  45   2                  return FALSE;
  46   2              }
  47   1      #else
                  Bool result = FALSE;
                  if( abs( SrcHPeriod - SC0_READ_HPEROID()) > 10 )//( abs( SrcHPeriod - msRead2Byte(SC0_E4) ) > 10 )
                  {
                      result = TRUE;
                  }
C51 COMPILER V9.01   AUTOFUNC                                                              03/09/2023 15:39:19 PAGE 2   

                  else if( abs( SrcVTotal - SC0_READ_VTOTAL()) > 10 )//( abs( SrcVTotal - msRead2Byte(SC0_E2) ) > 10 )
                  {
                      result = TRUE;
                  }
                  if( result )
                  {
                      Power_TurnOffPanel();
                      Set_InputTimingChangeFlag();
                  }
                  return result;
              #endif
  64   1      }
  65          void WaitAutoStatusReady(WORD regAddr, BYTE regFlag)
  66          {
  67   1              WORD waits = 0xFFFF;
  68   1              while( waits-- && !( msReadByte( regAddr ) &regFlag ) && !SyncLossState());
  69   1      }
  70          
  71          WORD GetAutoValue(WORD regAddr)
  72          {
  73   1          AUTO_POSITION_RESULT_READY();//WaitAutoStatusReady(SC0_7B, BIT1);
  74   1          return msRead2Byte(regAddr);
  75   1      }
  76          BYTE GetTranstionPosition(BYTE vsyncTime, WORD regAddr)
  77          {
  78   1          BYTE retry = 6;
  79   1          BYTE adjPhase;
  80   1          WORD pos;
  81   1          BYTE minPhase, maxPhase;
  82   1          maxPhase = MAX_PHASE_VALUE;
  83   1          minPhase = 0x00;
  84   1          drvADC_SetPhaseCode( 0 );
  85   1          Delay1ms(vsyncTime<<1); //Jison 090514,u8VSyncTime*2 for TSUMP sometime can't get correct AOHEND_H.
  86   1          pos = GetAutoValue(regAddr);
  87   1          adjPhase = (maxPhase + minPhase) / 2;
  88   1          while (retry--)
  89   1          {
  90   2              drvADC_SetPhaseCode( adjPhase );
  91   2              Delay1ms(vsyncTime);
  92   2              if (GetAutoValue(regAddr) != pos)
  93   2              {
  94   3                  maxPhase = adjPhase;
  95   3              }
  96   2              else
  97   2              {
  98   3                  minPhase = adjPhase;
  99   3              }
 100   2              adjPhase = (maxPhase + minPhase) / 2;
 101   2              if (CheckSyncLoss())
 102   2              {
 103   3                  return FALSE;
 104   3              }
 105   2          }
 106   1          //  printData("trans phase %d", adjPhase);
 107   1          return (adjPhase);
 108   1      }
 109          #if !QuickAuto
 110              BYTE AutoSetDataThreshold(BYTE vsyncTime)
 111              {
 112   1          BYTE thr;
 113   1          BYTE adjPhase;
 114   1          WORD regWord1, regWord2;
C51 COMPILER V9.01   AUTOFUNC                                                              03/09/2023 15:39:19 PAGE 3   

 115   1          for( thr = 3; thr < 0x10; thr++ )
 116   1          {
 117   2              AUTO_POSITION_SET_VALID_VALUE(thr);//msWriteByte(SC0_7C, thr << 4 );
 118   2              drvADC_SetPhaseCode( 0 );
 119   2              Delay1ms( vsyncTime );
 120   2              AUTO_POSITION_RESULT_READY();//WaitAutoStatusReady(SC0_7B, BIT1);
 121   2              regWord1 = SC0_READ_AUTO_START_H();//msRead2Byte(SC0_80);
 122   2              #if (MAX_PHASE_VALUE==0x7F)
 123   2              for( adjPhase = 7; adjPhase < (MAX_PHASE_VALUE+1); adjPhase += 7 )
 124   2              #else
                      for( adjPhase = 4; adjPhase < (MAX_PHASE_VALUE+1); adjPhase += 4 )
                      #endif            
 127   2              {
 128   3                  drvADC_SetPhaseCode( adjPhase );
 129   3                  Delay1ms( vsyncTime );
 130   3                  AUTO_POSITION_RESULT_READY();//WaitAutoStatusReady(SC0_7B, BIT1);
 131   3                  regWord2 = SC0_READ_AUTO_START_H();//msRead2Byte(SC0_80);
 132   3                  if( abs( regWord1 - regWord2 ) > 3 )
 133   3                      break;            
 134   3                  if( CheckSyncLoss() )
 135   3                      return FALSE;
 136   3              }
 137   2              if (adjPhase>=(MAX_PHASE_VALUE+1))
 138   2                  break;
 139   2          }
 140   1          
 141   1          return thr;
 142   1      }
 143          #endif 
 144          WORD SearchMaxWidth(BYTE vsyncTime)
 145          {
 146   1          BYTE startPhase;
 147   1          WORD hStart, hEnd;
 148   1          BYTE ucReg;
 149   1      
 150   1          ucReg = AUTO_POSITION_READ_VALID_VALUE();//msReadByte(SC0_7C);
 151   1          AUTO_POSITION_SET_VALID_VALUE(AOVDV_VALUE);//msWriteByte(SC0_7C, 0x40);
 152   1          drvADC_SetPhaseCode( 0 );
 153   1          Delay1ms( vsyncTime );
 154   1          Delay1ms( vsyncTime );
 155   1          hStart = AUTO_POSITION_READ_HSTART();//GetAutoValue(SC0_80);
 156   1          startPhase = AUTO_POSITION_READ_TRANSTION_POSITION(vsyncTime);//GetTranstionPosition( vsyncTime, SC0_8
             -0 );
 157   1          hEnd = AUTO_POSITION_READ_HEND();//GetAutoValue(SC0_84);
 158   1          hStart = hEnd - hStart + 1;
 159   1          AUTO_POSITION_SET_VALID_VALUE(ucReg);//msWriteByte(SC0_7C, ucReg);
 160   1          Delay1ms(vsyncTime<<1); //Jison 090423, u8VSyncTime*2 wait the status ready because of AOVDV change(Au
             -to Htotal issue).
 161   1          
 162   1          return hStart;
 163   1      }
 164          Bool mStar_AutoHTotal(BYTE vsyncTime)
 165          {
 166   1          WORD tempHTotal;
 167   1          WORD autoWidth;
 168   1          BYTE result;
 169   1          
 170   1          // 1st to coast tune HTotal
 171   1          drvADC_SetPhaseCode( 0 );
 172   1          Delay1ms( vsyncTime );
 173   1          autoWidth = AUTO_POSITION_READ_HEND() - AUTO_POSITION_READ_HSTART();//GetAutoValue(SC0_84) - GetAutoVa
             -lue(SC0_80);
C51 COMPILER V9.01   AUTOFUNC                                                              03/09/2023 15:39:19 PAGE 4   

 174   1          tempHTotal = StandardModeWidth / 3;
 175   1          if( abs( autoWidth - StandardModeWidth ) > tempHTotal )
 176   1          {
 177   2              drvADC_SetPhaseCode( UserPrefPhase );
 178   2              return FALSE;
 179   2          }
 180   1          tempHTotal = UserPrefHTotal;
 181   1          if( abs( autoWidth - StandardModeWidth ) > 1 )
 182   1          {
 183   2              tempHTotal = ( DWORD )UserPrefHTotal * StandardModeWidth / autoWidth;
 184   2              if( abs( tempHTotal - StandardModeHTotal ) > ClockAdjRange )
 185   2              {
 186   3                  goto AutoHTotalFailed;
 187   3              }
 188   2              drvADC_AdjustHTotal( tempHTotal );
 189   2              Delay1ms(vsyncTime);
 190   2          }
 191   1          autoWidth = SearchMaxWidth( vsyncTime );
 192   1      
 193   1          // 2nd fine tune
 194   1          if( autoWidth != StandardModeWidth )
 195   1          {
 196   2              tempHTotal = tempHTotal + ( StandardModeWidth - autoWidth );
 197   2              if( abs( tempHTotal - StandardModeHTotal ) > ClockAdjRange )
 198   2              {
 199   3                  goto AutoHTotalFailed;
 200   3              }
 201   2              drvADC_AdjustHTotal( tempHTotal );
 202   2              Delay1ms(vsyncTime);
 203   2              autoWidth = SearchMaxWidth( vsyncTime );
 204   2              tempHTotal = tempHTotal + ( StandardModeWidth - autoWidth );
 205   2          }
 206   1          else if( tempHTotal & 1 )
 207   1          {
 208   2              WORD autoWidth2;
 209   2              //tempHTotal=tempHTotal-1;
 210   2              drvADC_AdjustHTotal( tempHTotal - 1 );
 211   2              autoWidth = SearchMaxWidth( vsyncTime );
 212   2              drvADC_AdjustHTotal( tempHTotal + 1 );
 213   2              autoWidth2 = SearchMaxWidth( vsyncTime );
 214   2              if( autoWidth2 == StandardModeWidth )
 215   2              {
 216   3                  tempHTotal = tempHTotal + 1;
 217   3              }
 218   2              else if( autoWidth == StandardModeWidth )
 219   2              {
 220   3                  tempHTotal = tempHTotal - 1;
 221   3              }
 222   2          }
 223   1      #if EvenClock
                  if( tempHTotal % 4 )
                  {
                      tempHTotal = (( tempHTotal + 1 ) / 4 ) * 4;
                  }
              #endif
 229   1      AutoHTotalFailed:
 230   1          result = FALSE;
 231   1          if( abs( tempHTotal - StandardModeHTotal ) < ClockAdjRange )
 232   1          {
 233   2              UserPrefHTotal = tempHTotal;
 234   2              result = TRUE;
 235   2          }
C51 COMPILER V9.01   AUTOFUNC                                                              03/09/2023 15:39:19 PAGE 5   

 236   1          drvADC_AdjustHTotal( UserPrefHTotal );
 237   1          drvADC_SetPhaseCode( UserPrefPhase );
 238   1          return result;
 239   1      #undef result
 240   1      }
 241          Bool mStar_AutoPhase(BYTE vsyncTime)
 242          {
 243   1          BYTE adjPhase, i;
 244   1      #if UseWorstPhase
                  BYTE worsePhase, worsePhase2;
                  DWORD mincksum, cksum;
                  mincksum = 0xFFFFFFFFul;
                  for( adjPhase = 0; adjPhase < 0x80; adjPhase += 7 )
                  {
                      drvADC_SetPhaseCode( adjPhase );
                      Delay1ms( vsyncTime );
                      AUTO_PHASE_RESULT_READY();//drvADC_WaitAutoStatusReady(SC0_8B, BIT1);
                      //cksum = msRead2Byte(SC0_8E);
                      //cksum = ( cksum << 16 ) | msRead2Byte(SC0_8C);
                      cksum = AUTO_PHASE_READ_VALUE();
                      if( cksum < mincksum )
                      {
                          mincksum = cksum;
                          worsePhase = adjPhase;
                      }
                      
                      if( CheckSyncLoss() )
                          return FALSE;
                  }
              
                  // 2nd Search
                  if (worsePhase<7)
                      worsePhase=(worsePhase+127)%0x80; // 128-7
                  else
                      worsePhase-=7;
                  
                  mincksum = 0xFFFFFFFFul;
                  for (adjPhase=worsePhase; adjPhase<worsePhase+10; adjPhase++)
                  {
                      i=adjPhase%0x80;
                      drvADC_SetPhaseCode( i );
                      Delay1ms( 2 * vsyncTime );
                      AUTO_PHASE_RESULT_READY();//drvADC_WaitAutoStatusReady(SC0_8B, BIT1);
                      //cksum = msRead2Byte(SC0_8E);
                      //cksum = ( cksum << 16 ) | msRead2Byte(SC0_8C);
                      cksum = AUTO_PHASE_READ_VALUE();
                      if( cksum < mincksum )
                      {
                          mincksum = cksum;
                          worsePhase2 = i;
                      }
                      
                      if( CheckSyncLoss() )
                          return FALSE;
                  }
                  UserPrefPhase = ( worsePhase2 + 63 ) % 0x80;
              #else
 293   1          BYTE bestPhase, bestPhase2;
 294   1          DWORD maxcksum, cksum;
 295   1          maxcksum = 0;
 296   1          for( adjPhase = 0; adjPhase < 0x80; adjPhase += 7 )
 297   1          {
C51 COMPILER V9.01   AUTOFUNC                                                              03/09/2023 15:39:19 PAGE 6   

 298   2              drvADC_SetPhaseCode( adjPhase );
 299   2              Delay1ms( 2 * vsyncTime );
 300   2              AUTO_PHASE_RESULT_READY();//drvADC_WaitAutoStatusReady(SC0_8B, BIT1);
 301   2              //cksum = msRead2Byte(SC0_8E);
 302   2              //cksum = ( cksum << 16 ) | msRead2Byte(SC0_8C);
 303   2              cksum = AUTO_PHASE_READ_VALUE();
 304   2              if( cksum > maxcksum )
 305   2              {
 306   3                  maxcksum = cksum;
 307   3                  bestPhase = adjPhase;
 308   3              }
 309   2              
 310   2              if( CheckSyncLoss() )
 311   2                  return FALSE;
 312   2          }
 313   1      
 314   1          // 2nd Search
 315   1          if ( bestPhase < 7 )
 316   1              bestPhase = (bestPhase+121)%0x80; // 128-7
 317   1          else
 318   1              bestPhase -= 7;
 319   1          maxcksum = 0;
 320   1          for( adjPhase = bestPhase; adjPhase < bestPhase + 10; adjPhase++)
 321   1          {
 322   2              i=adjPhase%0x80;
 323   2              drvADC_SetPhaseCode( i );
 324   2              Delay1ms( vsyncTime );
 325   2              AUTO_PHASE_RESULT_READY();//drvADC_WaitAutoStatusReady(SC0_8B, BIT1);
 326   2              //cksum = msRead2Byte(SC0_8E);
 327   2              //cksum = ( cksum << 16 ) | msRead2Byte(SC0_8C);
 328   2              cksum = AUTO_PHASE_READ_VALUE();
 329   2              if( cksum > maxcksum )
 330   2              {
 331   3                  maxcksum = cksum;
 332   3                  bestPhase2 = i;
 333   3              }
 334   2              
 335   2              if( CheckSyncLoss() )
 336   2                  return FALSE;
 337   2          }
 338   1      
 339   1          UserPrefPhase = bestPhase2;
 340   1      #endif
 341   1          drvADC_SetPhaseCode( UserPrefPhase );
 342   1          return TRUE;
 343   1      }
 344          Bool mStar_AutoPosition(void)
 345          {
 346   1          WORD height, width;
 347   1          WORD actHeight;
 348   1          WORD hStart, vStart;
 349   1          hStart = AUTO_POSITION_READ_HSTART();//GetAutoValue(SC0_80);
 350   1          vStart = AUTO_POSITION_READ_VSTART();//GetAutoValue(SC0_7E);
 351   1      
 352   1          if( hStart > StandardModeWidth || vStart > StandardModeHeight )
 353   1          {
 354   2              return FALSE;
 355   2          }
 356   1      
 357   1          if( StandardModeGroup == Res_640x350 && abs( StandardModeVFreq - 700 ) < 10 )
 358   1          {
 359   2              if( vStart > ( 2 * StandardModeVStart ) )
C51 COMPILER V9.01   AUTOFUNC                                                              03/09/2023 15:39:19 PAGE 7   

 360   2              {
 361   3                  UserPrefVStart = StandardModeVStart;
 362   3                  if( AUTO_POSITION_READ_VEND() < ( StandardModeVStart + StandardModeHeight - 10 ) ) //if( GetAu
             -toValue(SC0_82) < ( StandardModeVStart + StandardModeHeight - 10 ) )
 363   3                      UserPrefHStart = StandardModeHStart;
 364   3                  else
 365   3                      UserPrefHStart = hStart;
 366   3              }
 367   2              else
 368   2              {
 369   3                  UserPrefHStart = hStart;
 370   3                  UserPrefVStart = vStart;
 371   3              }
 372   2          }
 373   1          else
 374   1          {
 375   2              width = AUTO_POSITION_READ_HEND() - hStart + 1;//GetAutoValue(SC0_84) - hStart + 1;
 376   2              height = AUTO_POSITION_READ_VEND() - vStart + 1;//GetAutoValue(SC0_82) - vStart + 1;
 377   2      #if DECREASE_V_SCALING
 378   2              actHeight = SC0_READ_IMAGE_HEIGHT()-DecVScaleValue;//(msRead2Byte(SC0_09)&SC_MASK_V)-DecVScaleValu
             -e;
 379   2      #else
                      actHeight = SC0_READ_IMAGE_HEIGHT();//(msRead2Byte(SC0_09)&SC_MASK_V);
              #endif
 382   2              if( UserModeFlag )
 383   2              {
 384   3                  if( height < ( StandardModeHeight * 2 / 3 ) || width < ( StandardModeWidth * 2 / 3 ) )
 385   3                  {
 386   4                      UserPrefHTotal = StandardModeHTotal;
 387   4                      drvADC_AdjustHTotal( UserPrefHTotal );
 388   4                      UserPrefHStart = StandardModeHStart;
 389   4                      UserPrefVStart = StandardModeVStart;
 390   4                      UserPrefAutoHStart = StandardModeHStart;                    
 391   4                      UserPrefAutoVStart = StandardModeVStart;
 392   4                      return FALSE;
 393   4                      //goto AutoPositionFail;
 394   4                  }
 395   3              }
 396   2              else if( height < ( StandardModeHeight - 80 ) || width < ( StandardModeWidth - 120 ) )
 397   2              {
 398   3                  UserPrefHTotal = StandardModeHTotal;
 399   3                  drvADC_AdjustHTotal( UserPrefHTotal );
 400   3                  UserPrefHStart = StandardModeHStart;
 401   3                  UserPrefVStart = StandardModeVStart;
 402   3                  UserPrefAutoHStart = StandardModeHStart;
 403   3                  UserPrefAutoVStart = StandardModeVStart;
 404   3                  return FALSE;
 405   3                  //goto AutoPositionFail;
 406   3              }
 407   2                      if(DecVScaleFlag)
 408   2                      {
 409   3                              actHeight = actHeight - DecVScaleValue;
 410   3                      }       
 411   2              if( actHeight > height || UserModeFlag )
 412   2              {
 413   3                  height = ( actHeight - height ) / 2;
 414   3                  if( vStart > height )
 415   3                  {
 416   4                          UserPrefVStart = ( vStart - height );
 417   4                  }
 418   3                  else
 419   3                  {
C51 COMPILER V9.01   AUTOFUNC                                                              03/09/2023 15:39:19 PAGE 8   

 420   4                      UserPrefHTotal = StandardModeHTotal;
 421   4                      drvADC_AdjustHTotal( UserPrefHTotal );
 422   4                      UserPrefHStart = StandardModeHStart;
 423   4                      UserPrefVStart = StandardModeVStart;
 424   4                      UserPrefAutoHStart = StandardModeHStart;
 425   4                      UserPrefAutoVStart = StandardModeVStart;
 426   4                      return FALSE;
 427   4                      //goto AutoPositionFail;
 428   4                  }
 429   3              }
 430   2                      else
 431   2                      {
 432   3                              UserPrefVStart = vStart;
 433   3                      }
 434   2      
 435   2                      #if PANEL_WIDTH==1366&&PANEL_HEIGHT==768        //120115 Modify
                      // input 1360x768 display on 1366 panel 
                      // input 1360 get 1366, so -3 is in center position.
                      if(PanelWidth == 1366)
                      {
                          if(StandardModeGroup == Res_1360x768)
                              UserPrefHStart = hStart-3;
                          else
                              UserPrefHStart = hStart;
                      }
                      else
              #endif
 447   2                  UserPrefHStart = hStart;
 448   2      
 449   2          } //2006-02-23 Andy
 450   1          //AutoPositionFail: 
 451   1      if (SrcInputType == Input_Digital || SrcInputType == Input_Digital2)
 452   1              UserPrefHStart -= 0x10;
 453   1          //printData("H After auto %d",UserPrefHStart);
 454   1          //printData("V After auto %d",UserPrefVStart);
 455   1          mStar_AdjustHPosition(UserPrefHStart); //msWrite2Byte( SC0_07, UserPrefHStart );
 456   1          mStar_AdjustVPosition(UserPrefVStart);
 457   1           return TRUE;
 458   1      }
 459          // Auto Color Setting
 460          //==================================================================
 461              //2006-03-30 Andy
 462              Bool mStar_AutoGeomtry(void)
 463              {
 464   1          Bool result = TRUE;
 465   1          BYTE vsyncTime;
 466   1      
 467   1              // 100512 coding addition
 468   1              if(InputTimingChangeFlag)
 469   1                  return FALSE;
 470   1          vsyncTime = GetVSyncTime();
 471   1      
 472   1          if(CURRENT_INPUT_IS_VGA())
 473   1          {
 474   2              mStar_ScalerDoubleBuffer(FALSE);
 475   2              // wait for coding and check
 476   2              //msADC_AdjustAdcGain( 0xA0, 0xA0, 0xA0 );
 477   2              //msADC_AdjustAdcOffset( 0xA0, 0xA0, 0xA0 );
 478   2              
 479   2              // auto adjust threshold
 480   2              #if QuickAuto
                      AUTO_POSITION_SET_VALID_VALUE(AOVDV_VALUE);//msWriteByte( BK0_7C, 0x40 );
C51 COMPILER V9.01   AUTOFUNC                                                              03/09/2023 15:39:19 PAGE 9   

                      #else
 483   2              AutoSetDataThreshold( vsyncTime * 2 );
 484   2              #endif
 485   2              if( InputTimingChangeFlag )
 486   2              {
 487   3                  result = FALSE;
 488   3                  goto AutoGeomtryFailed;
 489   3              }
 490   2              // auto adjust htotal
 491   2              result = mStar_AutoHTotal( vsyncTime * 2 );
 492   2      
 493   2              if( !result )
 494   2                  goto AutoGeomtryFailed;
 495   2      
 496   2              if( InputTimingChangeFlag )
 497   2              {
 498   3                  result = FALSE;
 499   3                  goto AutoGeomtryFailed;
 500   3              }
 501   2              // auto adjust phase
 502   2              if( result )
 503   2              {
 504   3                  //msADC_AdjustAdcGain(UserPrefAdcRedGain, UserPrefAdcGreenGain, UserPrefAdcBlueGain);
 505   3                  //msADC_AdjustAdcOffset(UserPrefAdcRedOffset, UserPrefAdcGreenOffset, UserPrefAdcBlueOffset);
 506   3      
 507   3                  #if 0//PANEL_WIDTH==1366&&PANEL_HEIGHT==768
                          if( StandardModeGroup == Res_1366x768 && abs( StandardModeVFreq - 600 ) < 10 ) // Check 1366 x
             -768 60 Hz HTotal
                              CheckHtotal();
                          #endif
 511   3                  mStar_AutoPhase( vsyncTime * 2 ); //2006-02-12 +3);
 512   3              }
 513   2              if( InputTimingChangeFlag )
 514   2              {
 515   3                  result = FALSE;
 516   3                  goto AutoGeomtryFailed;
 517   3              }
 518   2              Delay1ms( vsyncTime * 3 );
 519   2      
 520   2              if( mStar_AutoPosition() )            //Clock fail, but auto positon success still return true
 521   2              {
 522   3      
 523   3              }
 524   2          }
 525   1      AutoGeomtryFailed:
 526   1          //msWriteByte( BK0_7C, 0x40 );
 527   1          //msWriteByte( BK0_01, 0x05 );
 528   1          AUTO_POSITION_SET_VALID_VALUE(AOVDV_VALUE);//msWriteByte(SC0_7C, AOVDV_VALUE);
 529   1          mStar_ScalerDoubleBuffer(TRUE);
 530   1      
 531   1          //drvADC_SetRGBGainCode(UserPrefAdcRedGain, UserPrefAdcGreenGain, UserPrefAdcBlueGain);
 532   1          //drvADC_SetRGBOffsetCode(UserPrefAdcRedOffset, UserPrefAdcGreenOffset, UserPrefAdcBlueOffset);
 533   1      
 534   1          return result;
 535   1      }
 536          Bool mStar_AutoColor(void)
 537          {
 538   1          Bool result;
 539   1          BYTE vsyncTime;
 540   1          vsyncTime = GetVSyncTime();
 541   1          result = drvADC_AutoAdcColor(vsyncTime*2);
 542   1          if (InputTimingChangeFlag)
C51 COMPILER V9.01   AUTOFUNC                                                              03/09/2023 15:39:19 PAGE 10  

 543   1          {
 544   2              return FALSE;
 545   2          }
 546   1          return result;
 547   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2023    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      59
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

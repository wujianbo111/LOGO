C51 COMPILER V9.01   MSDLC                                                                 03/09/2023 15:39:09 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE MSDLC
OBJECT MODULE PLACED IN .\obj\MsDLC.obj
COMPILER INVOKED BY: D:\Keil4\C51\BIN\C51.EXE ..\..\KERNEL\SCALER\MsDLC.c OPTIMIZE(SIZE) BROWSE INCDIR(..\..\DRIVER\INC;
                    -..\..\KERNEL\SCALER\INC;..\..\KERNEL\SYSTEM\INC;..\..\LIB\INC;..\..\PANEL\INC;..\..\BOARD;..\..\DRIVER\INC;..\..\KERNEL\
                    -SYSTEM\INC\AOC2011;..\..\DRIVER\extDEVICE\INC;..\..\MODEL;..\..\CONFIG;..\..\PANEL;..\..\UI\F_LOGO\INC;..\..\UI\HkcOsd\I
                    -NC) DEFINE(ModelName=JRY_TESTBOARD_C_BOARD) DEBUG OBJECTEXTEND PRINT(.\list\MsDLC.lst) OBJECT(.\obj\MsDLC.obj)

line level    source

   1          /******************************************************************************
   2          Copyright (c) 2003 MStar Semiconductor, Inc.
   3          All rights reserved.
   4          [Module Name]: MsDLC.c
   5          [Date]:        26-Dec-2003
   6          [Comment]:
   7          MST DLC subroutines.
   8          [Reversion History]:
   9           *******************************************************************************/
  10          #include "board.h"
  11          #include "types.h"
  12          #include "msDLC.h"
  13          #include "ms_reg.h"
  14          #include "msRegTV.h"
  15          #include "debug.h"
  16          #include "global.h"
  17          #include "adjust.h"
  18          #include "Panel.h"
  19          #include "ms_rwreg.h"
  20          #include <global.h>
  21          #include <math.h>
  22          //#include "msACE.h"
  23          //#define LOCAL_TYPE 
  24          #define msDoubleBufferStart()
  25          #define msDoubleBufferEnd()
  26          extern code short tSRGB[3][3];
  27          extern code short tNormalColorCorrectionMatrix[3][3];
  28          XDATA BYTE g_ucLumaCurve[16];
  29          XDATA WORD g_ucTable[16];
  30          XDATA BYTE g_bLockDlc; // When this bit is true, DLC don't work!!
  31          XDATA DWORD g_dwFactory;
  32          XDATA DWORD g_dwFactory_7;
  33          XDATA DWORD g_dwFactory_9;
  34          XDATA DWORD g_dwLstep;
  35          XDATA DWORD g_dwHstep;
  36          XDATA BYTE g_LowStrength = 120;
  37          XDATA BYTE g_HighStrength = 100;
  38          XDATA BYTE g_bDLCOnOff = 0;
  39          XDATA BYTE g_bNeedRequest = 0;
  40          XDATA BYTE ucDLCCCount = 0;
  41          XDATA BYTE BrightData = 0xff;
  42          XDATA BYTE DarkData = 0x00;
  43          XDATA BYTE PreBrightData = 0xff;
  44          XDATA BYTE ReadFrameDataCnt = 1;
  45          XDATA BYTE SetDarkestFlag = 0;
  46          XDATA BYTE DarkSegmentData;
  47          #define TopLimit_Upper  (0)
  48          #define DownLimit_Upper (((PanelHeight/2)/8)-1)
  49          #define TopLimit_Lower  ((PanelHeight/2)/8)
  50          #define DownLimit_Lower ((PanelHeight/8)-1)
  51          #define DarkestValue    0
  52          #if  EANBLE_NEW_DCR_Functing
C51 COMPILER V9.01   MSDLC                                                                 03/09/2023 15:39:09 PAGE 2   

  53          #define DarkestRange    ((CURRENT_INPUT_IS_VGA())?(20):(30))
  54          #define BlackWhiteDifference    21    //16      //20081201
  55          #else
              #define DarkestRange    ((CURRENT_INPUT_IS_VGA())?(16):(20))
              #define BlackWhiteDifference    21    //16      //20081201
              #endif
  59          #if 0
              //#define TOP_LIMIT       ((WORD)wHeight/64)
              //#define DOWN_LIMIT      ((WORD)wHeight*7/64)
              #define TOP_LIMIT       (1)// 2004/11/10
              #define DOWN_LIMIT      (255)//((WORD)wHeight/8)// 2005/01/21
              #define TOTAL_PIXEL     ((DWORD)wHeight*0.04375*wWidth)
              #else
  66          #define TOP_LIMIT           ((WORD)PanelHeight/64)
  67          #define DOWN_LIMIT          ((WORD)PanelHeight*7/64)
  68          #define TOTAL_PIXEL    ((DWORD)(DOWN_LIMIT-TOP_LIMIT)*0.04375*PanelWidth/4)
  69          #endif
  70          #define FACTORY_7       g_dwFactory_7    // low threshold
  71          #define FACTORY_9       g_dwFactory_9    // high threshold
  72          #define Lstep           g_dwLstep
  73          #define Hstep           g_dwHstep
  74          //#define TOP_LIMIT   (g_wHeight/64)
  75          //#define DOWN_LIMIT  (g_wHeight*7/64)
  76          //#define TOTAL_PIXEL ((DWORD)g_wHeight*0.04375*g_wWidth)
  77          //#define FACTORY     (TOTAL_PIXEL / 8)
  78          //#define FACTORY_7   (FACTORY * 7 / 8)      // low threshold
  79          //#define FACTORY_9   (FACTORY + (FACTORY/8))  // high threshold
  80          //#define Lstep       (FACTORY *1/16)*g_ucLstrength
  81          //#define Hstep       (FACTORY *3/8)*g_ucHstrength
  82          //#define FACTORY_M1  (FACTORY_7 - ((FACTORY *8/16)*g_ucLstrength))
  83          //#define FACTORY_0   (FACTORY_7 - ((FACTORY *7/16)*g_ucLstrength))
  84          //#define FACTORY_1   (FACTORY_7 - ((FACTORY *6/16)*g_ucLstrength))
  85          //#define FACTORY_2   (FACTORY_7 - ((FACTORY *5/16)*g_ucLstrength))
  86          //#define FACTORY_3   (FACTORY_7 - ((FACTORY *4/16)*g_ucLstrength))
  87          //#define FACTORY_4   (FACTORY_7 - ((FACTORY *3/16)*g_ucLstrength))
  88          //#define FACTORY_5   (FACTORY_7 - ((FACTORY *2/16)*g_ucLstrength))
  89          //#define FACTORY_6   (FACTORY_7 - ((FACTORY *1/16)*g_ucLstrength))
  90          //#define FACTORY_11  (FACTORY_9 + ((FACTORY*2/8)*g_ucHstrength))
  91          //#define FACTORY_13  (FACTORY_9 + ((FACTORY*4/8)*g_ucHstrength)
  92          //#define FACTORY_16  (FACTORY_9 + ((FACTORY*7/8)*g_ucHstrength)
  93          //#define FACTORY_19  (FACTORY_9 + (((FACTORY)+(FACTORY*2/8))*g_ucHstrength))
  94          //#define FACTORY_21  (FACTORY_9 + (((FACTORY)+(FACTORY*4/8))*g_ucHstrength))
  95          //#define FACTORY_23  (FACTORY_9 + (((FACTORY)+(FACTORY*6/8))*g_ucHstrength))
  96          //#define FACTORY_27  (FACTORY_9 + (((FACTORY*2)+(FACTORY*2/8))*g_ucHstrength))
  97          //#define FACTORY_30  (FACTORY_9 + (((FACTORY*2)+(FACTORY*5/8))*g_ucHstrength))
  98          //#define FACTORY_32  (FACTORY_9 + (((FACTORY*2)+(FACTORY*7/8))*g_ucHstrength))
  99          void InitDLCVar()
 100          {
 101   1          // DLC table initial table
 102   1          g_ucLumaCurve[0] = 0x07;
 103   1          g_ucLumaCurve[1] = 0x17;
 104   1          g_ucLumaCurve[2] = 0x27;
 105   1          g_ucLumaCurve[3] = 0x37;
 106   1          g_ucLumaCurve[4] = 0x47;
 107   1          g_ucLumaCurve[5] = 0x57;
 108   1          g_ucLumaCurve[6] = 0x67;
 109   1          g_ucLumaCurve[7] = 0x77;
 110   1          g_ucLumaCurve[8] = 0x87;
 111   1          g_ucLumaCurve[9] = 0x97;
 112   1          g_ucLumaCurve[10] = 0xA7;
 113   1          g_ucLumaCurve[11] = 0xB7;
 114   1          g_ucLumaCurve[12] = 0xC7;
C51 COMPILER V9.01   MSDLC                                                                 03/09/2023 15:39:09 PAGE 3   

 115   1          g_ucLumaCurve[13] = 0xD7;
 116   1          g_ucLumaCurve[14] = 0xE7;
 117   1          g_ucLumaCurve[15] = 0xF7;
 118   1      }
 119          //////////////////////////////////////////////////////////////////////////////
 120          // <Name>: msSetDlcStrength
 121          //
 122          // <Description>: This function set DLC strength.
 123          //
 124          // <Parameter>:    -  <Flow>  -  <Description>
 125          // ---------------------------------------------------------------------------
 126          //  ucLowStrength  -    In    -  Strength of low level, from 1 to 255
 127          //  ucHighStrenght -    In    -  Strength of high level from 1 to 255
 128          // The unit is 0.01; the value is small and the effect is strong
 129          // Lstrength :  0.50(strong)   <------------>   1.70 (weak) ; default = 1.20
 130          // Hstrength:   0.50(strong)   <------------>   2.00 (weak) ; default = 1.00
 131          //////////////////////////////////////////////////////////////////////////////
 132          #if 0
              void msSetDlcStrength(BYTE pucLowStrength, BYTE pucHighStrenght)
              {
                  BYTE LOCAL_TYPE ucLowStrength;
                  BYTE LOCAL_TYPE ucHighStrenght;
                  ucLowStrength = pucLowStrength;
                  ucHighStrenght = pucHighStrenght;
                  if (0 == ucLowStrength)
                      ucLowStrength = 1;
                  if (0 == ucHighStrenght)
                      ucHighStrenght = 1;
                  g_dwLstep = g_dwFactory * 1 / 16 * ucLowStrength / 100;
                  g_dwHstep = g_dwFactory * 3 / 8 * ucHighStrenght / 100;
              }
              
              void msDlcInit(WORD pwWidth, WORD pwHeight)
              {
                  //BYTE LOCAL_TYPE ucBank;
                  WORD LOCAL_TYPE wWidth;
                  WORD LOCAL_TYPE wHeight;
                  WORD LOCAL_TYPE vtotal = 0;
                  wWidth = pwWidth;
                  wHeight = pwHeight;
                  g_bLockDlc = 0;
                  g_dwFactory = TOTAL_PIXEL / 8;
                  g_dwFactory_7 = (g_dwFactory *7 / 8);
                  g_dwFactory_9 = (g_dwFactory + (g_dwFactory / 8));
                  g_dwLstep = g_dwFactory * 1 / 16 * 12 / 10;
                  g_dwHstep = g_dwFactory * 3 / 8;
                  //printf("TOP_LIMIT = 0x%x\r\n", TOP_LIMIT);
                  //printf("DOWN_LIMIT = 0x%x\r\n", DOWN_LIMIT);
                  /*
                  printf("TOTAL_PIXEL = 0x%x", dwTotalPixel>>16);
                  printf("%x\r\n", dwTotalPixel);
                  printf("FACTORY = 0x%x", dwFactory>>16);
                  printf("%x\r\n", dwFactory);
                  printf("FACTORY7 = 0x%x", g_dwFactory_7>>16);
                  printf("%x\r\n", g_dwFactory_7);
                  printf("FACTORY9 = 0x%x", g_dwFactory_9>>16);
                  printf("%x\r\n", g_dwFactory_9);
                  printf("Lstep = 0x%x", g_dwLstep>>16);
                  printf("%x\r\n", g_dwLstep);
                  printf("Hstep = 0x%x", g_dwHstep>>16);
                  printf("%x\r\n", g_dwHstep);
                   */
C51 COMPILER V9.01   MSDLC                                                                 03/09/2023 15:39:09 PAGE 4   

              #if 1 // wait for checking     
                      msWriteByte(SC3_B6, TOP_LIMIT);
                      msWriteByte(SC3_B7, DOWN_LIMIT);
                      msWriteByteMask(SC3_B5, BIT0, BIT0);
              #else
                  ucBank = msReadByte(BK0_00);
                  // get vtotal// 2005/1/24
                  msWriteByte(BK0_00, 0x00);
                  vtotal = msReadByte(BK0_95) + (msReadByte(BK0_96) &0x07) *256;
                  // 
                  msWriteByte(BK0_00, 0x03);
                  //msWriteByte(BK3_B6, TOP_LIMIT);
                  // msWriteByte(BK3_B7, vtotal/8-1);// 2005/1/24
                  msWriteByte(BK3_BC, 0x00); // xxxx 0909
                  //    msWriteByte(BK3_B5, BIT0);  // Enable range for Histogram
                  #if EnablePanelServiceMenu
                  if ((PanelWidth==1280&&PanelHeight==720)||(PanelWidth==1366&&PanelHeight==768))
                      {
                          msWriteByte(BK3_B6, 0x00);
                          msWriteByte(BK3_B7, PanelHeight/8); // 2005/1/24
                      }
                  else
                      {
                          msWriteByte(BK3_B6, 0x20);
                          msWriteByte(BK3_B7, 0x70); // 2005/1/24
                      }
                  #else
                  #if ((PanelWidth==1280&&PanelHeight==720)||(PanelWidth==1366&&PanelHeight==768))
                  msWriteByte(BK3_B6, 0x00);
                  msWriteByte(BK3_B7, PanelHeight/8); // 2005/1/24
                  #else
                  msWriteByte(BK3_B6, 0x20);
                  msWriteByte(BK3_B7, 0x70); // 2005/1/24
                  #endif
                 #endif
                  msWriteByte(BK3_B5, BIT0); // Enable range for Histogram
                  msWriteByte(BK3_B9, 0x10);
                  //msWriteByte(BK3_B8, _BIT6);
                  msWriteByte(BK0_00, ucBank);
              #endif
              }
              #endif
 219          extern Bool SupportMWE(void);
 220          
 221          
 222          
 223          #if 0
              void msDlcOnOff(BYTE pbSwitch)
              {
                  //BYTE LOCAL_TYPE ucBank;
                  BYTE LOCAL_TYPE bSwitch;
                  WORD LOCAL_TYPE time_out = 0;
                  bSwitch = pbSwitch;
              #if 1 // wait for coding    
                      // wait output v blank
                      time_out = 10000;
                      while( !( msReadByte( SC0_E0 ) & 0x01 ) && ( time_out-- ) )
                              ;
                      // waiting for V active area
                      time_out = 10000;
                      while(( msReadByte( SC0_E0 ) & 0x01 ) && ( time_out-- ) )
                              ;
C51 COMPILER V9.01   MSDLC                                                                 03/09/2023 15:39:09 PAGE 5   

                      // waiting for V blanking
              
                      if( bSwitch == _ENABLE )
                      {
                              msWriteByteMask( SC3_B8, (BIT6), (BIT6) );
                              g_bDLCOnOff = 1;
                              g_bNeedRequest = 1;
                              DLCStatus = DLC_WAIT;
                      }
                      else
                      {
                              msWriteByteMask( SC3_B8, 0x00, (BIT6) );
                              g_bDLCOnOff = 0;
                      }
                      
              #endif
              }
              
              #endif
 258          static XDATA BYTE s_Slope2, s_Slope5;
 259          #define DYNAMIC_DLC     1
 260          BYTE XDATA DLCStatus;
 261          WORD XDATA uwArray[8];
 262          BYTE XDATA ucTmp;
 263          #if 0
              #define DCRNew  1   // 081204
              #define DCRMotionTest   1 // 081205
              #if DCRNew
              BYTE xdata PreAveLumi, PreAveLumi2;
              #endif
              #if DCRMotionTest
              #define DCRStep     8 // DCR increasement/decreasement step
              #define DCRStepTransPeriod  2 // unit: 10ms
              BYTE xdata DCRStepTransValue; // 
              BYTE xdata BackLightTargetValue; // 
              BYTE xdata DCRStepTransCnt; // unit: DCRStepTransPeriod*10ms
              bit bDCRSmoothMotionFlag = 0;
              #endif
              #endif
 278          void msDlcHandler()
 279          {
 280   1          //BYTE LOCAL_TYPE ucBank; //, ucTmp;
 281   1          WORD retry = 500;
 282   1          BYTE tempvalue = 0;
 283   1          //BYTE Backlight_Final;
 284   1          #if 0
                      if (!SupportMWE())
                          return ;
                  #endif 
 288   1          if (!g_bDLCOnOff)
 289   1          {
 290   2              return ;
 291   2          }
 292   1          if(!retry)
 293   1              mStar_AdjustDcrBrightness();
 294   1      #if 0   
                  //bWindow=1;
                  ucBank = msReadByte(BK0_00);
                  msWriteByte(BK0_00, REG_BANK_PIP);
                  //if( MAIN_WINDOW == bWindow ) // Main window
                  //if( 0 ) // Main window
                  //{
C51 COMPILER V9.01   MSDLC                                                                 03/09/2023 15:39:09 PAGE 6   

                  //    msWriteByte(BK3_B8, msReadByte(BK3_B8) | _BIT2 | _BIT1);
                  //}
                  //else // Sub window
                  {
                      if (g_bNeedRequest)
                      {
                          msWriteByte(BK3_B8, msReadByte(BK3_B8) | BIT4 | BIT2 | BIT0);
                          g_bNeedRequest = 0;
                      }
                  }
                  
                  switch (DLCStatus)
                  {
                      case DLC_WAIT:
                          if(UserPrefDcrMode)
                          {
                              if(ReadFrameDataCnt%2 == 0) // set to lower of panel height
                              {
                                  msWriteByte(BK3_B6, TopLimit_Lower);
                                  msWriteByte(BK3_B7, DownLimit_Lower);
                              }
                              else // set to upper of panel height
                              {
                                  msWriteByte(BK3_B6, TopLimit_Upper);
                                  msWriteByte(BK3_B7, DownLimit_Upper);
                              }
                          }
                          #if DYNAMIC_DLC// 2004/11/10
                          if (!(msReadByte(BK3_B8) &BIT3))                // 2004/11/19
                          {
                              msWriteByte(BK0_00, ucBank);
                              return ;
                          }
                                  //while (!(msReadByte(BK3_B8) & _BIT3));  // Wait until ready// 2004/11/3
                          #endif 
                          DLCStatus = DLC_READ1;
                          msWriteByte(BK0_00, ucBank);
                          return ;
                      case DLC_READ1:
                          msWriteByte(BK3_B9, 0);
                          #if DYNAMIC_DLC// 2004/11/10
                          // 8 segment pixel count extraction
                          // Sequencial read
                          //=======Define the capture area===========
                          // msWriteByte(BK3_B5,0x01);
                          // msWriteByte(BK3_B6,0x030);// start
                          // msWriteByte(BK3_B6,0x070);// start
                          //===================================AutoBacklight function Start=====================
                          tempvalue = msReadByte(BK3_B8);
                          msWriteByte(BK3_B8, 0x16);
                          while (retry-- && !(msReadByte(BK3_B8) &BIT3))
                              ;
                          for (ucTmp = 0; ucTmp < 1; ucTmp++)                // 2004/11/3
                              uwArray[ucTmp] = ((WORD)msReadByte(BK3_BA)) *0x100 + (WORD)msReadByte(BK3_BA);
                          #endif 
                          {
                              #if DCRNew        
                              DWORD PixelCount,LumCount;
                              BYTE AveLumi ,AveLumi2;
                              #else //!DCRNew
                      
                              WORD reduceAry;
C51 COMPILER V9.01   MSDLC                                                                 03/09/2023 15:39:09 PAGE 7   

                              BYTE CurrentVal;
                              BYTE OffsetlVal, OffsetlBL;
                              BYTE noise_th = 8;   //8  //20081202
                              #if 1
                              BYTE BL_HIGH = 0xFF;
                              BYTE BL_LOW = 0;
                              #else 
                              BYTE BL_HIGH = UserprefAutolightHigh; // 0xFF;
                              BYTE BL_LOW = UserprefAutolightLow; //0x00;
                              #endif 
                              UserprefALha = 60;
                              reduceAry = uwArray[0];                
                              #endif // end of DCRNew                
              
                              // 081117
                              if(ReadFrameDataCnt%2 ==0) // get all display data
                              {
                                  BYTE tempVal;
                                  
                                  if((tempVal = msReadByte(0x3a)) > BrightData) // get max bright data
                                      BrightData = tempVal;
                                  if((tempVal = msReadByte(0x39)) < DarkData) // get min dark data
                                      DarkData = tempVal;
                                  if(abs(BrightData - DarkData) <= BlackWhiteDifference) 
                                  {
                                      if(abs(DarkData - DarkestValue) <= DarkestRange) // all display data are dark
                                      {
                                          SetDarkestFlag = 1;
                                      }
                                  }
              
                                  #if DCRNew // 081204        
                                  PixelCount=msRead2Byte(0x35);
                                  LumCount=msRead2Byte(0x37);
                                  AveLumi=(LumCount*256)/PixelCount;
                                  AveLumi = ((WORD)PreAveLumi + AveLumi)/2;
              
                                  
                                  PixelCount=msRead2Byte(0x35);
                                  LumCount=msRead2Byte(0x37);
                                  AveLumi2=(LumCount*256)/PixelCount;
                                  AveLumi2 = ((WORD)PreAveLumi2+AveLumi2)/2;
                                  
                                  if(abs(AveLumi2-AveLumi)>10)
                                  {
                                      msWriteByte(BK3_B8, msReadByte(BK3_B8) &0xF0);
                                      g_bNeedRequest = 1;
                                      DLCStatus = DLC_WAIT;
                                      msWriteByte(BK0_00, ucBank);
                                      ReadFrameDataCnt ++; // 090504 addition
                                      break;
                                  }
              
                                  #if DCRMotionTest
                                  BackLightTargetValue = AveLumi;
                                  
                                  if(abs(BackLightTargetValue-BacklightPrev) >= DCRStep)
                                  {
                                      bDCRSmoothMotionFlag = 1;
                                      DCRStepTransValue = abs(BackLightTargetValue-BacklightPrev)/DCRStep;
                                  }
                                  else
C51 COMPILER V9.01   MSDLC                                                                 03/09/2023 15:39:09 PAGE 8   

                                  {
                                      bDCRSmoothMotionFlag = 0;
                                  }
              
                                  if(bDCRSmoothMotionFlag) // DCR operating range is over DCRStep
                                  {
                                      if(BackLightTargetValue >= BacklightPrev) // increasement
                                      {
                                          BacklightNow = (BacklightNow+DCRStepTransValue >= BackLightTargetValue)?(BackL
             -ightTargetValue):(BacklightNow+DCRStepTransValue);
                                      }
                                      else // decreasement
                                      {
                                          BacklightNow = (BacklightNow-DCRStepTransValue <= BackLightTargetValue)?(BackL
             -ightTargetValue):(BacklightNow-DCRStepTransValue);
                                      }
                                  }
                                  else
                                  {
                                      BacklightNow = BackLightTargetValue;
                                  }
                                  
                                  #else // !DCRMotionTest
                                  BacklightNow = AveLumi;
                                  #endif
                                      
                                  if(0)//(abs(BacklightNow - BacklightPrev) < 3)
                                  {
                                      msWriteByte(BK3_B8, msReadByte(BK3_B8) &0xF0);
                                      g_bNeedRequest = 1;
                                      DLCStatus = DLC_WAIT;
                                      msWriteByte(BK0_00, ucBank);
                                      break;
                                  }
                                  
                                  #else // !DCRNew
              
                                  CurrentVal = (reduceAry >> 8) &0xFF;
                                  CurrentVal = ((WORD)(CurrentVal) + DarkSegmentData)/2;
                                  HistogramNow = CurrentVal;
                                  HistogramNow = (WORD)(UserprefALha *HistogramNow + (100-UserprefALha) *HistogramPrev) 
             -/ 100;
                                  OffsetlVal = abs(HistogramNow - HistogramPrev) / 2;
                                  if (HistogramNow > HistogramPrev)
                                      HistogramNow = HistogramPrev + OffsetlVal;
                                  else if (HistogramNow < HistogramPrev)
                                      HistogramNow = HistogramPrev - OffsetlVal;
                                  //printData("UserprefALha = %d\r\n", UserprefALha);
                                  //printData("HistogramNow = %d\r\n",HistogramNow);
                                  if (UserprefHistogram1 > HistogramNow)
                                      BacklightNow = BL_HIGH;                //  LIGHT
                                  else if (UserprefHistogram2 < HistogramNow)
                                      BacklightNow = BL_LOW;                // DARK 
                                  else
                                  BacklightNow = (WORD)((UserprefHistogram2 - HistogramNow)*(BL_HIGH - BL_LOW) / abs(Use
             -rprefHistogram2 - UserprefHistogram1)) + BL_LOW;
                                  OffsetlBL = abs(BacklightNow - BacklightPrev) / 2;   //2         //20081201  
                                  if (BacklightNow > BacklightPrev)
                                      BacklightNow = BacklightPrev + OffsetlBL;
                                  else if (BacklightNow < BacklightPrev)
                                      BacklightNow = BacklightPrev - OffsetlBL;
                                  if ((BacklightNow > BacklightPrev) && ((BacklightNow - BacklightPrev) >= noise_th))
C51 COMPILER V9.01   MSDLC                                                                 03/09/2023 15:39:09 PAGE 9   

                                      BacklightNow = BacklightNow - noise_th;
                                  else if ((BacklightPrev > BacklightNow) && ((BacklightPrev - BacklightNow) >= noise_th
             -))
                                      BacklightNow = BacklightNow + noise_th;
                                  else
                                      BacklightNow = BacklightPrev;
                                  #endif // end of DCRNew               
                      
                                  //=====Get the Histogram value=============   
                                  #if DCRMotionTest
                                  if(!DCRStepTransCnt)
                                      BacklightPrev = BacklightNow;
                                  #endif
                                  if((BacklightNow != BacklightPrev) || (BrightData != PreBrightData))
                                  {
                                      PreBrightData = BrightData;
                                      mStar_AdjustDcrBrightness();
                                      #if DCRMotionTest
                                      DCRStepTransCnt = DCRStepTransPeriod;
                                      #endif
                                  }
                                  msWriteByte(0x00, 0x03);
                                  HistogramPrev = HistogramNow;
                                  //BacklightPrev = BacklightNow;
                                  //=============================================================
                              }
                              else // get upper dark / bright data
                              {
                                  #if !DCRNew
                                  DarkSegmentData = (reduceAry >> 8) &0xFF;
                                  #endif
                                      
                                  DarkData = msReadByte(0x39);
                                  BrightData = msReadByte(0x3a);
              
                                  PixelCount=msRead2Byte(0x35);
                                  LumCount=msRead2Byte(0x37);
                                  PreAveLumi=(LumCount*256)/PixelCount;
                                  PixelCount=msRead2Byte(0x35);
                                  LumCount=msRead2Byte(0x37);
                                  PreAveLumi2=(LumCount*256)/PixelCount;
                              }
                              
                              ReadFrameDataCnt ++;
                          }
                          // 081109 modified for it's unnecessary to execute others case below when DCR on.
                          //DLCStatus = DLC_READ2;
                          if(UserPrefDcrMode)
                          {
                              msWriteByte(BK3_B8, msReadByte(BK3_B8) &0xF0);
                              g_bNeedRequest = 1;
                              DLCStatus = DLC_WAIT;
                          }
                          else
                              DLCStatus = DLC_READ2;
                          
                          msWriteByte(BK0_00, ucBank);
                          //  printData("C7 %d",msReadByte(0xC7));
                          return ;
                          break;
                      case DLC_READ2:
                          msWriteByte(BK3_B9, 2);
C51 COMPILER V9.01   MSDLC                                                                 03/09/2023 15:39:09 PAGE 10  

                          #if DYNAMIC_DLC// 2004/11/10
                              // 8 segment pixel count extraction
                              // Sequencial read
                              for (ucTmp = 1; ucTmp < 2; ucTmp++)
                              // 2004/11/3
                                  uwArray[ucTmp] = ((WORD)msReadByte(BK3_BA)) *0x100 + (WORD)msReadByte(BK3_BA);
                              // 2004/11/3
                              //for(ucTmp=0; ucTmp<8; ucTmp++)
                              //     printData("count = 0x%x\r\n", uwArray[ucTmp]);
                          #endif 
                          DLCStatus = DLC_READ3;
                          msWriteByte(BK0_00, ucBank);
                          return ;
                          break;
                      case DLC_READ3:
                          msWriteByte(BK3_B9, 4);
                          #if DYNAMIC_DLC// 2004/11/10
                              // 8 segment pixel count extraction
                              // Sequencial read
                              for (ucTmp = 2; ucTmp < 3; ucTmp++)
                              // 2004/11/3
                                  uwArray[ucTmp] = ((WORD)msReadByte(BK3_BA)) *0x100 + (WORD)msReadByte(BK3_BA);
                              // 2004/11/3
                              //for(ucTmp=0; ucTmp<8; ucTmp++)
                              //    printf("count = 0x%x\r\n", uwArray[ucTmp]);
                          #endif 
                          DLCStatus = DLC_READ4;
                          msWriteByte(BK0_00, ucBank);
                          return ;
                          break;
                      case DLC_READ4:
                          msWriteByte(BK3_B9, 6);
                          #if DYNAMIC_DLC// 2004/11/10
                              // 8 segment pixel count extraction
                              // Sequencial read
                              for (ucTmp = 3; ucTmp < 4; ucTmp++)
                              // 2004/11/3
                                  uwArray[ucTmp] = ((WORD)msReadByte(BK3_BA)) *0x100 + (WORD)msReadByte(BK3_BA);
                              // 2004/11/3
                              //for(ucTmp=0; ucTmp<8; ucTmp++)
                              //    printf("count = 0x%x\r\n", uwArray[ucTmp]);
                          #endif 
                          DLCStatus = DLC_READ5;
                          msWriteByte(BK0_00, ucBank);
                          return ;
                          break;
                      case DLC_READ5:
                          msWriteByte(BK3_B9, 8);
                          #if DYNAMIC_DLC// 2004/11/10
                              // 8 segment pixel count extraction
                              // Sequencial read
                              for (ucTmp = 4; ucTmp < 5; ucTmp++)
                              // 2004/11/3
                                  uwArray[ucTmp] = ((WORD)msReadByte(BK3_BA)) *0x100 + (WORD)msReadByte(BK3_BA);
                              // 2004/11/3
                              //for(ucTmp=0; ucTmp<8; ucTmp++)
                              //    printf("count = 0x%x\r\n", uwArray[ucTmp]);
                          #endif 
                          DLCStatus = DLC_READ6;
                          msWriteByte(BK0_00, ucBank);
                          return ;
                          break;
C51 COMPILER V9.01   MSDLC                                                                 03/09/2023 15:39:09 PAGE 11  

                      case DLC_READ6:
                          msWriteByte(BK3_B9, 10);
                          #if DYNAMIC_DLC// 2004/11/10
                              // 8 segment pixel count extraction
                              // Sequencial read
                              for (ucTmp = 5; ucTmp < 6; ucTmp++)
                              // 2004/11/3
                                  uwArray[ucTmp] = ((WORD)msReadByte(BK3_BA)) *0x100 + (WORD)msReadByte(BK3_BA);
                              // 2004/11/3
                              //for(ucTmp=0; ucTmp<8; ucTmp++)
                              //    printf("count = 0x%x\r\n", uwArray[ucTmp]);
                          #endif 
                          DLCStatus = DLC_READ7;
                          msWriteByte(BK0_00, ucBank);
                          return ;
                          break;
                      case DLC_READ7:
                          msWriteByte(BK3_B9, 12);
                          #if DYNAMIC_DLC// 2004/11/10
                              // 8 segment pixel count extraction
                              // Sequencial read
                              for (ucTmp = 6; ucTmp < 7; ucTmp++)
                              // 2004/11/3
                                  uwArray[ucTmp] = ((WORD)msReadByte(BK3_BA)) *0x100 + (WORD)msReadByte(BK3_BA);
                              // 2004/11/3
                              //for(ucTmp=0; ucTmp<8; ucTmp++)
                              //    printf("count = 0x%x\r\n", uwArray[ucTmp]);
                          #endif 
                          DLCStatus = DLC_READ8;
                          msWriteByte(BK0_00, ucBank);
                          return ;
                          break;
                      case DLC_READ8:
                          msWriteByte(BK3_B9, 14);
                          #if DYNAMIC_DLC// 2004/11/10
                              // 8 segment pixel count extraction
                              // Sequencial read
                              for (ucTmp = 7; ucTmp < 8; ucTmp++)
                              // 2004/11/3
                                  uwArray[ucTmp] = ((WORD)msReadByte(BK3_BA)) *0x100 + (WORD)msReadByte(BK3_BA);
                              // 2004/11/3
                              //for(ucTmp=0; ucTmp<8; ucTmp++)
                              //    printf("count = 0x%x\r\n", uwArray[ucTmp]);
                          #endif 
                          DLCStatus = DLC_CAL1;
                          msWriteByte(BK0_00, ucBank);
                          return ;
                          break;
                      case DLC_CAL1:
                          uwArray[3] = ((uwArray[0] / 2) + (uwArray[1] / 4) + (uwArray[2] / 4));
                          uwArray[4] = ((uwArray[5] / 4) + (uwArray[6] / 4) + (uwArray[7] / 2));
                          //if ((uwArray[3]>tpArray[8]) && ((uwArray[3]-uwArray[8])> FACTORY_19))
                          //    g_fcount=2;
                          //printf("uwArray[3] = 0x%x\r\n", uwArray[3]);
                          //printf("uwArray[8] = 0x%x\r\n", uwArray[8]);
                          // g_ucTable[5] value LUT
                          //if (g_ucTable[5] == 0)        // this line should be removed!
                          //    g_ucTable[5] = 0x57;
                          if (uwArray[3] < FACTORY_7)
                          {
                              ucTmp = ((FACTORY_7 - uwArray[3]) / Lstep) + 1;
                              if (ucTmp > 10)
C51 COMPILER V9.01   MSDLC                                                                 03/09/2023 15:39:09 PAGE 12  

                                  ucTmp = 10;
                              g_ucTable[5] = 0x57 - ucTmp;
                          }
                          else if (uwArray[3] > FACTORY_9)
                          {
                              ucTmp = ((uwArray[3] - FACTORY_9) / Hstep) + 1;
                              if (ucTmp > 10)
                                  ucTmp = 10;
                              g_ucTable[5] = 0x57 + ucTmp;
                          }
                          else
                              g_ucTable[5] = 0x57;
                          //flicker avoid    
                          if (s_Slope5 == 0)
                              s_Slope5 = 0x57;
                          DLCStatus = DLC_CAL2;
                          msWriteByte(BK0_00, ucBank);
                          return ;
                          break;
                      case DLC_CAL2:
                          if ((g_ucTable[5] > s_Slope5) && ((g_ucTable[5] - s_Slope5) >= 2))
                              g_ucTable[5] = g_ucTable[5] - 1;
                          else if ((s_Slope5 > g_ucTable[5]) && ((s_Slope5 - g_ucTable[5]) >= 2))
                              g_ucTable[5] = g_ucTable[5] + 1;
                          else
                              g_ucTable[5] = s_Slope5;
                          //uwArray[8] =  uwArray[3];
                          //printf("uwArray[3] = 0x%x\r\n",uwArray[3]);
                          //printf("g_ucTable[5] = 0x%x\r\n",g_ucTable[5]);
                          // g_ucTable[2] value LUT
                          uwArray[3] = uwArray[0];
                          //if (g_ucTable[2] == 0)  // Can this line be removed
                          //    g_ucTable[2] = 0x27;// Can this line be removed
                          g_ucTable[2] = ((g_ucTable[5] - 0x07) *2 / 5) + 0x07;
                          if (uwArray[3] < FACTORY_7)
                          {
                              ucTmp = ((FACTORY_7 - uwArray[3]) / Lstep) + 1;
                              if (ucTmp > 10)
                                  ucTmp = 10;
                              g_ucTable[2] = g_ucTable[2] - ucTmp;
                          }
                          else if (uwArray[3] > FACTORY_9)
                          {
                              ucTmp = ((uwArray[3] - FACTORY_9) / Hstep) + 1;
                              if (ucTmp > 10)
                                  ucTmp = 10;
                              g_ucTable[2] = g_ucTable[2] + ucTmp;
                          }
                          //else
                          //    g_ucTable[2] = g_ucTable[2];
                          //flicker avoid
                          if (s_Slope2 == 0)
                              s_Slope2 = 0x27;
                          DLCStatus = DLC_CAL3;
                          msWriteByte(BK0_00, ucBank);
                          return ;
                          break;
                      case DLC_CAL3:
                          if ((g_ucTable[2] > s_Slope2) && ((g_ucTable[2] - s_Slope2) >= 2))
                              g_ucTable[2] = g_ucTable[2] - 1;
                          else if ((s_Slope2 > g_ucTable[2]) && ((s_Slope2 - g_ucTable[2]) >= 2))
                              g_ucTable[2] = g_ucTable[2] + 1;
C51 COMPILER V9.01   MSDLC                                                                 03/09/2023 15:39:09 PAGE 13  

                          else
                              g_ucTable[2] = s_Slope2;
                          //printf("uwArray[3] = 0x%x\r\n",uwArray[3]);
                          //printf("g_ucTable[2] = 0x%x\r\n",g_ucTable[2]);
                          //printf("g_ucTable[6] = 0x%x\r\n", g_ucTable[6]);
                          //printf("uwArray[3] = 0x%x\r\n", uwArray[3]);
                          //printf("g_ucTable[6] = 0x%x\r\n", g_ucTable[4]);
                          //printf("ucSlope[2] = 0x%x\r\n", ucSlope[2]);
                          //printf("g_ucTable[6] = 0x%x\r\n", g_ucTable[2]);
                          //printf("ucSlope[1] = 0x%x\r\n", ucSlope[1]);
                          // g_ucTable[10] value LUT
                          //if (g_ucTable[10] == 0)       // this line should be removed
                          //    g_ucTable[10] = 0xA7;
                          if (uwArray[4] < FACTORY_7)
                          {
                              ucTmp = ((FACTORY_7 - uwArray[4]) / Lstep) + 1;
                              if (ucTmp > 8)
                                  ucTmp = 8;
                              g_ucTable[10] = 0xA7 + ucTmp;
                          }
                          else if (uwArray[4] > FACTORY_9)
                          {
                              ucTmp = ((uwArray[4] - FACTORY_9) / Hstep) + 1;
                              if (ucTmp > 8)
                                  ucTmp = 8;
                              g_ucTable[10] = 0xA7 - ucTmp;
                          }
                          else
                              g_ucTable[10] = 0xA7;
                          //printf("uwArray[4] = 0x%x\r\n",uwArray[4]);
                          //printf("g_ucTable[10] = 0x%x\r\n",g_ucTable[10]);
                          // g_ucTable[13] value LUT
                          uwArray[4] = uwArray[7];
                          //if (g_ucTable[13] == 0)       // this line should be removed
                          //    g_ucTable[13] = 0xd7;
                          DLCStatus = DLC_CAL4;
                          msWriteByte(BK0_00, ucBank);
                          return ;
                          break;
                      case DLC_CAL4:
                          g_ucTable[13] = 0xf7 - ((0xf7 - g_ucTable[10]) *2 / 5);
                          if (uwArray[4] < FACTORY_7)
                          {
                              ucTmp = ((FACTORY_7 - uwArray[4]) / Lstep) + 1;
                              if (ucTmp > 8)
                                  ucTmp = 8;
                              g_ucTable[13] = g_ucTable[13] + ucTmp;
                          }
                          else if (uwArray[4] > FACTORY_9)
                          {
                              ucTmp = ((uwArray[4] - FACTORY_9) / Hstep) + 1;
                              if (ucTmp > 8)
                                  ucTmp = 8;
                              g_ucTable[13] = g_ucTable[13] - ucTmp;
                          }
                          //else
                          //    g_ucTable[13] =g_ucTable[13];
                          s_Slope5 = g_ucTable[5];
                          s_Slope2 = g_ucTable[2];
                          DLCStatus = DLC_CAL5;
                          msWriteByte(BK0_00, ucBank);
                          return ;
C51 COMPILER V9.01   MSDLC                                                                 03/09/2023 15:39:09 PAGE 14  

                          break;
                      case DLC_CAL5:
                          #if 0
                              if (g_bLockDlc == 1)
                              // For test
                              {
                                  g_ucTable[2] = 0x27;
                                  g_ucTable[5] = 0x57;
                                  g_ucTable[10] = 0xA7;
                                  g_ucTable[13] = 0xd7;
                              }
                          #endif 
                          g_ucTable[1] = (0x07 + g_ucTable[2]) / 2;
                          g_ucTable[3] = g_ucTable[5] - ((g_ucTable[5] - g_ucTable[2]) *2 / 3);
                          g_ucTable[4] = g_ucTable[2] + ((g_ucTable[5] - g_ucTable[2]) *2 / 3);
                          g_ucTable[7] = g_ucTable[5] + ((g_ucTable[10] - g_ucTable[5]) *2 / 5);
                          g_ucTable[6] = (g_ucTable[5] / 2) + (g_ucTable[7] / 2);
                          g_ucTable[8] = g_ucTable[10] - ((g_ucTable[10] - g_ucTable[5]) *2 / 5);
                          g_ucTable[9] = (g_ucTable[8] / 2) + (g_ucTable[10] / 2);
                          g_ucTable[11] = g_ucTable[13] - ((g_ucTable[13] - g_ucTable[10]) *2 / 3);
                          g_ucTable[14] = (g_ucTable[13] / 2) + (0xf7 / 2);
                          g_ucTable[12] = g_ucTable[10] + ((g_ucTable[13] - g_ucTable[10]) *2 / 3);
                          DLCStatus = DLC_CAL6;
                          msWriteByte(BK0_00, ucBank);
                          return ;
                          break;
                      case DLC_CAL6:
                          g_ucTable[0] = (0x07 + (g_ucTable[1] / 3)) / 2; // fine tune lowest level
                          //if(DLCMode==MODE2_DLC)  // xxxx 0909
                          //   g_ucTable[0] = 0x05;
                          g_ucTable[15] = 0xff - ((0xff - g_ucTable[14]) / 3);
                          g_ucTable[15] = ((g_ucTable[15]) / 2) + (0xff / 2); // fine tune highest level
                          g_ucTable[0] = g_ucTable[0] + g_ucLumaCurve[0] - 0x07;
                          g_ucTable[1] = g_ucTable[1] + g_ucLumaCurve[1] - 0x17;
                          g_ucTable[2] = g_ucTable[2] + g_ucLumaCurve[2] - 0x27;
                          g_ucTable[3] = g_ucTable[3] + g_ucLumaCurve[3] - 0x37;
                          g_ucTable[4] = g_ucTable[4] + g_ucLumaCurve[4] - 0x47;
                          g_ucTable[5] = g_ucTable[5] + g_ucLumaCurve[5] - 0x57;
                          g_ucTable[6] = g_ucTable[6] + g_ucLumaCurve[6] - 0x67;
                          g_ucTable[7] = g_ucTable[7] + g_ucLumaCurve[7] - 0x77;
                          g_ucTable[8] = g_ucTable[8] + g_ucLumaCurve[8] - 0x87;
                          g_ucTable[9] = g_ucTable[9] + g_ucLumaCurve[9] - 0x97;
                          g_ucTable[10] = g_ucTable[10] + g_ucLumaCurve[10] - 0xa7;
                          g_ucTable[11] = g_ucTable[11] + g_ucLumaCurve[11] - 0xb7;
                          g_ucTable[12] = g_ucTable[12] + g_ucLumaCurve[12] - 0xc7;
                          g_ucTable[13] = g_ucTable[13] + g_ucLumaCurve[13] - 0xd7;
                          g_ucTable[14] = g_ucTable[14] + g_ucLumaCurve[14] - 0xe7;
                          g_ucTable[15] = g_ucTable[15] + g_ucLumaCurve[15] - 0xf7;
                          //printf("ucSlope[6] = 0x%x\r\n",ucSlope[6]);
                          //printf("ucSlope[4] = 0x%x\r\n",ucSlope[4]);
                          //printf("ucSlope[2] = 0x%x\r\n",ucSlope[2]);
                          //printf("ucSlope[8] = 0x%x\r\n",ucSlope[8]);
                          //printf("ucSlope[5] = 0x%x\r\n",ucSlope[5]);
                          //printf("ucSlope[3] = 0x%x\r\n",ucSlope[3]);
                          /*if(DLCMode==MODE3_DLC)  // xxxx 0909
                          {
                          g_ucTable[0] = 0x05;
                          g_ucTable[1] = 0x0f;
                          g_ucTable[2] = 0x19;
                          g_ucTable[3] = 0x28;
                          g_ucTable[4] = 0x36;
                          g_ucTable[5] = 0x4a;
C51 COMPILER V9.01   MSDLC                                                                 03/09/2023 15:39:09 PAGE 15  

                          g_ucTable[6] = 0x5f;
                          g_ucTable[7] = 0x72;
                          g_ucTable[8] = 0x8d;
                          g_ucTable[9] = 0xa0;
                          g_ucTable[10] = 0xb8;
                          g_ucTable[11] = 0xc9;
                          g_ucTable[12] = 0xd8;
                          g_ucTable[13] = 0xe4;
                          g_ucTable[14] = 0xef;
                          g_ucTable[15] = 0xf7;
                          }*/
                          for (ucTmp = 0; ucTmp < 16; ucTmp++)
                          {
                              if (g_ucTable[ucTmp] > 0x1FF)
                                  g_ucTable[ucTmp] = 0x00;
                              else if (g_ucTable[ucTmp] > 0xFF)
                                  g_ucTable[ucTmp] = 0xFF;
                          }
                          #if !DYNAMIC_DLC// 2004/11/10
                              g_ucTable[0] = g_ucLumaCurve[0];
                              g_ucTable[1] = g_ucLumaCurve[1];
                              g_ucTable[2] = g_ucLumaCurve[2];
                              g_ucTable[3] = g_ucLumaCurve[3];
                              g_ucTable[4] = g_ucLumaCurve[4];
                              g_ucTable[5] = g_ucLumaCurve[5];
                              g_ucTable[6] = g_ucLumaCurve[6];
                              g_ucTable[7] = g_ucLumaCurve[7];
                              g_ucTable[8] = g_ucLumaCurve[8];
                              g_ucTable[9] = g_ucLumaCurve[9];
                              g_ucTable[10] = g_ucLumaCurve[10];
                              g_ucTable[11] = g_ucLumaCurve[11];
                              g_ucTable[12] = g_ucLumaCurve[12];
                              g_ucTable[13] = g_ucLumaCurve[13];
                              g_ucTable[14] = g_ucLumaCurve[14];
                              g_ucTable[15] = g_ucLumaCurve[15];
                          #endif 
                          DLCStatus = DLC_WRITE1;
                          msWriteByte(BK0_00, ucBank);
                          return ;
                          break;
                      case DLC_WRITE1:
                          msWriteByte(BK0_00, REG_BANK_PIP); // bank 3
                          msWriteByte(BK3_B9, 0x10);
                          for (ucTmp = 0; ucTmp <= 1; ucTmp++)
                          {
                              msWriteByte(BK3_BA, g_ucTable[ucTmp]);
                          }
                          //msWriteByte(BK3_BA, g_ucLumaCurve[ucTmp][uc2]);
                          DLCStatus = DLC_WRITE2;
                          msWriteByte(BK0_00, ucBank);
                          return ;
                          break;
                      case DLC_WRITE2:
                          msWriteByte(BK0_00, REG_BANK_PIP); // bank 3
                          msWriteByte(BK3_B9, 0x12);
                          for (ucTmp = 2; ucTmp <= 3; ucTmp++)
                          {
                              msWriteByte(BK3_BA, g_ucTable[ucTmp]);
                          }
                          //msWriteByte(BK3_BA, g_ucLumaCurve[ucTmp][uc2]);
                          DLCStatus = DLC_WRITE3;
                          msWriteByte(BK0_00, ucBank);
C51 COMPILER V9.01   MSDLC                                                                 03/09/2023 15:39:09 PAGE 16  

                          return ;
                          break;
                      case DLC_WRITE3:
                          msWriteByte(BK0_00, REG_BANK_PIP); // bank 3
                          msWriteByte(BK3_B9, 0x14);
                          for (ucTmp = 4; ucTmp <= 5; ucTmp++)
                          {
                              msWriteByte(BK3_BA, g_ucTable[ucTmp]);
                          }
                          //msWriteByte(BK3_BA, g_ucLumaCurve[ucTmp][uc2]);
                          DLCStatus = DLC_WRITE4;
                          msWriteByte(BK0_00, ucBank);
                          return ;
                          break;
                      case DLC_WRITE4:
                          msWriteByte(BK0_00, REG_BANK_PIP); // bank 3
                          msWriteByte(BK3_B9, 0x16);
                          for (ucTmp = 6; ucTmp <= 7; ucTmp++)
                          {
                              msWriteByte(BK3_BA, g_ucTable[ucTmp]);
                          }
                          //msWriteByte(BK3_BA, g_ucLumaCurve[ucTmp][uc2]);
                          DLCStatus = DLC_WRITE5;
                          msWriteByte(BK0_00, ucBank);
                          return ;
                          break;
                      case DLC_WRITE5:
                          msWriteByte(BK0_00, REG_BANK_PIP); // bank 3
                          msWriteByte(BK3_B9, 0x18);
                          for (ucTmp = 8; ucTmp <= 9; ucTmp++)
                          {
                              msWriteByte(BK3_BA, g_ucTable[ucTmp]);
                          }
                          //msWriteByte(BK3_BA, g_ucLumaCurve[ucTmp][uc2]);
                          DLCStatus = DLC_WRITE6;
                          msWriteByte(BK0_00, ucBank);
                          return ;
                          break;
                      case DLC_WRITE6:
                          msWriteByte(BK0_00, REG_BANK_PIP); // bank 3
                          msWriteByte(BK3_B9, 0x1A);
                          for (ucTmp = 0x0a; ucTmp <= 0x0b; ucTmp++)
                          {
                              msWriteByte(BK3_BA, g_ucTable[ucTmp]);
                          }
                          //msWriteByte(BK3_BA, g_ucLumaCurve[ucTmp][uc2]);
                          DLCStatus = DLC_WRITE7;
                          msWriteByte(BK0_00, ucBank);
                          return ;
                          break;
                      case DLC_WRITE7:
                          msWriteByte(BK0_00, REG_BANK_PIP); // bank 3
                          msWriteByte(BK3_B9, 0x1C);
                          for (ucTmp = 0x0c; ucTmp <= 0x0d; ucTmp++)
                          {
                              msWriteByte(BK3_BA, g_ucTable[ucTmp]);
                          }
                          //msWriteByte(BK3_BA, g_ucLumaCurve[ucTmp][uc2]);
                          DLCStatus = DLC_WRITE8;
                          msWriteByte(BK0_00, ucBank);
                          return ;
                          break;
C51 COMPILER V9.01   MSDLC                                                                 03/09/2023 15:39:09 PAGE 17  

                      case DLC_WRITE8:
                          if (ucDLCCCount < 255)
                              ucDLCCCount++;
                          msWriteByte(BK0_00, REG_BANK_PIP); // bank 3
                          msWriteByte(BK3_B9, 0x1E);
                          for (ucTmp = 0x0e; ucTmp <= 0x0f; ucTmp++)
                          {
                              msWriteByte(BK3_BA, g_ucTable[ucTmp]);
                          }
                          //msWriteByte(BK3_BA, g_ucLumaCurve[ucTmp][uc2]);
                          msWriteByte(BK0_00, REG_BANK_PIP);
                          msWriteByte(BK3_B8, msReadByte(BK3_B8) &0xF0);
                          //printMsg("reset");
                          g_bNeedRequest = 1; // 2004/11/19
                          msWriteByte(BK0_00, ucBank);
                          DLCStatus = DLC_WAIT;
                          msWriteByte(BK0_00, ucBank);
                          return ;
                          break;
                      default:
                          g_bNeedRequest = 1;
                          DLCStatus = DLC_WAIT;
                          msWriteByte(BK0_00, ucBank);
                          return ;
                          break;
                  }
              #endif
1005   1      }
1006          #if 0
              void LoadDLCTable(BYTE *pDLCtable) // 2004/10/15
              {
                  BYTE LOCAL_TYPE index;
                  LOCAL_TYPE BYTE *DLCtable;
                  DLCtable = pDLCtable;
                  // dlc function
                  for (index = 0; index < 16; index++)
                  {
                      g_ucLumaCurve[index] = DLCtable[index];
                  }
                  g_LowStrength = DLCtable[16];
                  g_HighStrength = DLCtable[17];
                  msSetDlcStrength(g_LowStrength, g_HighStrength);
                  msDlcOnOff(_ENABLE);
              }
              #endif
1023          #define DCRNew  1   // 081204
1024          #define DCRMotionTest   1 // 081205
1025          #define DCR_SPEEDUP   1
1026          #if DCRNew
1027          WORD xdata PreAveLumi, PreAveLumi2;
1028          #endif
1029          #if DCRMotionTest
1030          #if  EANBLE_NEW_DCR_Functing
1031          #define DCRStep     2// DCR increasement/decreasement step
1032          #define DCRStepTransPeriod  1 // unit: 10ms
1033          #else
              #define DCRStep     8// DCR increasement/decreasement step
              #define DCRStepTransPeriod  2 // unit: 10ms
              #endif
1037          BYTE xdata DCRStepTransValue; //
1038          BYTE xdata BackLightTargetValue; //
1039          #if ! EANBLE_NEW_DCR_Functing
C51 COMPILER V9.01   MSDLC                                                                 03/09/2023 15:39:09 PAGE 18  

              BYTE xdata DCRStepTransCnt; // unit: DCRStepTransPeriod*10ms
              #endif
1042          bit bDCRSmoothMotionFlag = 0;
1043          #endif
1044          
1045          void msDCROnOff( BYTE ucSwitch, BYTE win)
1046          {
1047   1          if(ucSwitch)
1048   1          {
1049   2              BrightData = 0xff;
1050   2              PreBrightData = 0xff;
1051   2              DarkData = 0x00;
1052   2              ReadFrameDataCnt = 1;
1053   2              SetDarkestFlag = 0;
1054   2              //msWriteByte(SC3_B6, TOP_LIMIT);
1055   2              //msWriteByte(SC3_B7, DOWN_LIMIT);
1056   2              HISTOGRAM_WHOLE_VERTICAL_RANGE_EN(1);//msWriteByteMask(SC3_B5, 0, BIT0); // whole DE range
1057   2              HISTOGRAM_RGB_TO_Y_EN(IsColorspaceRGB());//msWriteByteMask(SC7_40, BIT2, BIT2); // enable R2Y     
             -  //A008 item
1058   2              if(win == 0) // 0: main win
1059   2              {
1060   3                  MWE_FUNCTION_EN(0);//msWriteByteMask(SC0_5C, 0, BIT3);
1061   3                  STATISTIC_REQUEST_MAIN_ENABLE();//msWriteByte(SC7_B8, (BIT2|BIT1));
1062   3              }
1063   2              else // 1: sub win
1064   2              {
1065   3                  MWE_FUNCTION_EN(1);//msWriteByteMask(SC0_5C, BIT3, BIT3);
1066   3                  STATISTIC_REQUEST_SUB_ENABLE();//msWriteByte(SC7_B8, (BIT2|BIT0));
1067   3              }
1068   2                      
1069   2              #if CHIP_ID == CHIP_TSUMC || CHIP_ID == CHIP_TSUMD ||CHIP_ID == CHIP_TSUM9||CHIP_ID == CHIP_TSUMF//201305
             -16 Modify
1070   2              if(IsColorspaceRGB())
1071   2              {
1072   3                      msWriteByteMask(SCB_A0, 0,BIT0);
1073   3              }
1074   2              else
1075   2              {
1076   3                      msWriteByteMask(SCB_A0, BIT0,BIT0);
1077   3              }
1078   2              #elif CHIP_ID == CHIP_TSUMB //20130927 xiandi
                      if(IsColorspaceRGB())
                      {
                              msWriteByteMask(SC0_5E, 0,BIT0);
                      }
                      else
                      {
                              msWriteByteMask(SC0_5E, BIT0,BIT0);
                      }
                      #endif
1088   2      
1089   2          }
1090   1          else
1091   1          {
1092   2              STATISTIC_REQUEST_EN(0);//msWriteByte(SC7_B8, 0);
1093   2              HISTOGRAM_RGB_TO_Y_EN(0);//msWriteByteMask(SC7_40, BIT2, BIT2); // Disable R2Y       //A008 item
1094   2              #if CHIP_ID == CHIP_TSUMC || CHIP_ID == CHIP_TSUMD      ||CHIP_ID == CHIP_TSUM9||CHIP_ID == CHIP_TSUMF//130705
             - xiandi
1095   2                      msWriteByteMask(SCB_28, BIT1, BIT1);
1096   2              #elif CHIP_ID == CHIP_TSUMB //20130927 xiandi
                              msWriteByteMask(SC0_5E, 0,BIT0);
                      #endif
C51 COMPILER V9.01   MSDLC                                                                 03/09/2023 15:39:09 PAGE 19  

1099   2          }
1100   1      }
1101          
1102          
1103          #define DefAveLumi        BRIGHTNESS_PWM_DEF_VALUE
1104          #define MaxAVeLumi       BRIGHTNESS_PWM_MAX_VALUE
1105          #define MinAveLumi        BRIGHTNESS_PWM_MIN_VALUE
1106          
1107          
1108          void msDCRHandler(void)
1109          {
1110   1      
1111   1      #if   EANBLE_NEW_DCR_Functing
1112   1      
1113   1          DWORD xdata TotalPixelCount;
1114   1      #if DCR_SPEEDUP
1115   1          WORD xdata AveLumi;// , AveLumi2;
1116   1          BYTE tempVal;
1117   1          BYTE xdata BlackDataTemp, WhiteDataTemp;
1118   1      #else
                  WORD xdata AveLumi , AveLumi2;
              #endif
1121   1          if ( !UserPrefDcrMode )
1122   1          {
1123   2              return;
1124   2          }
1125   1      
1126   1          if ( !STATISTIC_ACKNOWLEDGE() ) //(!(msReadByte(SC7_B8)&BIT3)) // histogram is not ready
1127   1          {
1128   2              return;
1129   2          }
1130   1      
1131   1          TotalPixelCount = TOTAL_PIXEL_COUNT();
1132   1          AveLumi = TOTAL_PIXEL_WEIGHT();//msRead2Byte(SC7_36);  //weight
1133   1          AveLumi = AVERAGE_LUMINANCE ( AveLumi, TotalPixelCount ); //((((DWORD)AveLumi)*16384 +(u16HistogramHR>
             ->1))/u16HistogramHR +(u16HistogramVR>>1))/ u16HistogramVR; //average
1134   1          BlackDataTemp = Y_CHANNEL_MAX_PIXEL();
1135   1          WhiteDataTemp = Y_CHANNEL_MIN_PIXEL();
1136   1            
1137   1            
1138   1          if ( abs ( PreAveLumi - AveLumi ) > 10 )
1139   1          {
1140   2              PreAveLumi = AveLumi;
1141   2              //STATISTIC_REQUEST_EN(0);//msWriteByteMask(SC7_B8, 0, BIT2);
1142   2              //STATISTIC_REQUEST_EN(1);//msWriteByteMask(SC7_B8, BIT2, BIT2);
1143   2              return;
1144   2          }
1145   1      
1146   1          if ( ( tempVal = Y_CHANNEL_MAX_PIXEL() ) != BrightData ) //(( tempVal = msReadByte( SC7_3A ) ) > Brigh
             -tData ) // get max bright data
1147   1          {
1148   2              BrightData = tempVal;
1149   2          }
1150   1      
1151   1          if ( ( tempVal = Y_CHANNEL_MIN_PIXEL() ) !=DarkData ) //(( tempVal = msReadByte( SC7_39 ) ) < DarkData
             - ) // get min dark data
1152   1          {
1153   2              DarkData = tempVal;
1154   2          }
1155   1          if ( abs ( BrightData - DarkData ) <= BlackWhiteDifference )
1156   1          {
1157   2              if ( abs ( DarkData - DarkestValue ) <= DarkestRange ) // all display data are dark
C51 COMPILER V9.01   MSDLC                                                                 03/09/2023 15:39:09 PAGE 20  

1158   2              {
1159   3                  SetDarkestFlag = 1;
1160   3              }
1161   2          }
1162   1      
1163   1      
1164   1              if(BrightData<=DarkestRange&&AveLumi<=16&&DarkData<=16)
1165   1                  {
1166   2      
1167   2                    if(!EanbleClearBalclightStartFlag)
1168   2                      {
1169   3                              DCR_Counter=5;                                          
1170   3                              Set_EanbleClearBalclightStartFlag();
1171   3                      }
1172   2                          
1173   2                  }
1174   1              else
1175   1                  {
1176   2                        DCR_Counter=0;                                                
1177   2                         Clr_EanbleClearBalclightStartFlag();
1178   2                        Clr_DoClearBalclightFlag(); 
1179   2                  } 
1180   1      
1181   1          AveLumi = ( AveLumi > 0xFF ) ? ( 0xff ) : ( ( BYTE ) AveLumi );
1182   1      
1183   1      /*//=========  ==============
1184   1      if (AveLumi>50&&AveLumi<200)
1185   1      {
1186   1              AveLumi=200;
1187   1      }
1188   1      //*/
1189   1      #if ENABLE_DEBUG
              printData("AveLumi             %d", AveLumi);
              #endif
1192   1      
1193   1      #if CHIP_ID==CHIP_TSUMU
                  AveLumi =(AveLumi*100/0xFF);                        //for HF Panel  240maOxFF
                  BackLightTargetValue=AveLumi;
              #else
1197   1          AveLumi =AveLumi*(MaxAVeLumi-MinAveLumi) /0xFF;                     //for HF Panel  240maOxFF
1198   1      
1199   1          if(AveLumi>DefAveLumi)
1200   1           {
1201   2              BackLightTargetValue=((WORD)(AveLumi-DefAveLumi)*(MaxBrightnessValue-DefBrightness))/(MaxAVeLumi-DefAveLu
             -mi)+DefBrightness;
1202   2           }
1203   1          else
1204   1          {
1205   2              BackLightTargetValue=((WORD)AveLumi*(DefBrightness-MinBrightnessValue))/(DefAveLumi-MinAveLumi)+MinBright
             -nessValue;
1206   2           }
1207   1      #endif
1208   1      
1209   1      
1210   1      #if ENABLE_DEBUG
              printData("BackLightTargetValue           %d", BackLightTargetValue);
              #endif
1213   1              
1214   1      
1215   1       if ( !DCRStepTransCnt )
1216   1      {
1217   2          if ( abs ( BackLightTargetValue - BacklightPrev ) >= DCRStep )
C51 COMPILER V9.01   MSDLC                                                                 03/09/2023 15:39:09 PAGE 21  

1218   2          {
1219   3              bDCRSmoothMotionFlag = 1;
1220   3              DCRStepTransValue = DCRStep/2;// / 2; //abs(BackLightTargetValue-BacklightPrev)/DCRStep;
1221   3          }
1222   2          else
1223   2          {
1224   3              bDCRSmoothMotionFlag = 0;
1225   3          }
1226   2      
1227   2          if ( bDCRSmoothMotionFlag ) // DCR operating range is over DCRStep
1228   2          {
1229   3              if ( BackLightTargetValue >= BacklightPrev ) // increasement
1230   3              {
1231   4                  BacklightNow = ( BacklightNow + DCRStepTransValue >= BackLightTargetValue ) ? ( BackLightTarge
             -tValue ) : ( BacklightNow + DCRStepTransValue );
1232   4              }
1233   3              else // decreasement
1234   3              {
1235   4                  BacklightNow = ( BacklightNow - DCRStepTransValue <= BackLightTargetValue ) ? ( BackLightTarge
             -tValue ) : ( BacklightNow - DCRStepTransValue );
1236   4              }
1237   3          }
1238   2          else
1239   2          {
1240   3              BacklightNow = BackLightTargetValue;
1241   3          }
1242   2      
1243   2      #if DCRMotionTest
1244   2                  DCRStepTransCnt = DCRStepTransPeriod;
1245   2      #endif
1246   2              
1247   2       }
1248   1      //printData("BackLightTargetValue       %d", BackLightTargetValue);
1249   1      //printData("BacklightPrev       %d", BacklightPrev);
1250   1      //printData("BacklightNow       %d", BacklightNow);
1251   1      
1252   1      
1253   1      #if ENABLE_DEBUG
              printData("BacklightNow       %d", BacklightNow);
              #endif
1256   1      
1257   1      
1258   1      #if DCRMotionTest
1259   1      
1260   1         // if ( !DCRStepTransCnt )
1261   1      #endif
1262   1              if ( ( BacklightNow != BacklightPrev ) || ( BrightData != PreBrightData ) )
1263   1              {
1264   2                  BacklightPrev = BacklightNow;
1265   2                  PreBrightData = BrightData;
1266   2                  mStar_AdjustBrightness(BacklightNow);
1267   2      
1268   2              }
1269   1      
1270   1          HistogramPrev = HistogramNow;
1271   1          
1272   1      #if defined(DCRClearBacklight)
1273   1      
1274   1                      if((DoClearBalclightFlag)&&(EanbleClearBalclightStartFlag)&&(MenuPageIndex==RootMenu))
1275   1                      {       
1276   2                      #if ENABLE_DEBUG
                                      printMsg("---hw_ClrBlacklit---");
C51 COMPILER V9.01   MSDLC                                                                 03/09/2023 15:39:09 PAGE 22  

                              #endif
1279   2                              if(BackLightActiveFlag)
1280   2                                      hw_ClrBlacklit();
1281   2                      }
1282   1                      if((!DoClearBalclightFlag)||MenuPageIndex>RootMenu)
1283   1                      {
1284   2                              if(!BackLightActiveFlag)
1285   2                                      hw_SetBlacklit();
1286   2                      }       
1287   1      
1288   1      #endif
1289   1      
1290   1      #else
                  //DWORD PixelCount, LumCount;
                  //WORD u16HistogramHR, u16HistogramVR;
                  DWORD xdata TotalPixelCount;
                  WORD xdata AveLumi , AveLumi2;       
                  
                  if(!UserPrefDcrMode)
                      return;
              
                  if(!STATISTIC_ACKNOWLEDGE())//(!(msReadByte(SC7_B8)&BIT3)) // histogram is not ready
                      return;
              
                  if( ReadFrameDataCnt % 2 == 0 ) // get all display data
                  {
                      BYTE tempVal;
              
                      if(( tempVal = Y_CHANNEL_MAX_PIXEL() ) > BrightData )//(( tempVal = msReadByte( SC7_3A ) ) > Brigh
             -tData ) // get max bright data
                          BrightData = tempVal;
                      if(( tempVal = Y_CHANNEL_MIN_PIXEL() ) < DarkData )//(( tempVal = msReadByte( SC7_39 ) ) < DarkDat
             -a ) // get min dark data
                          DarkData = tempVal;
                      if( abs( BrightData - DarkData ) <= BlackWhiteDifference )
                      {
                          if( abs( DarkData - DarkestValue ) <= DarkestRange ) // all display data are dark
                          {
                              SetDarkestFlag = 1;
                          }
                      }
              
                      //u16HistogramVR = msRead2Byte(SC0_1A)+1;
                      //u16HistogramHR = msRead2Byte(SC0_1C)-msRead2Byte(SC0_18)+1;
                      TotalPixelCount = TOTAL_PIXEL_COUNT();
                      AveLumi = TOTAL_PIXEL_WEIGHT();//msRead2Byte(SC7_36);  //weight
                      AveLumi = AVERAGE_LUMINANCE(AveLumi, TotalPixelCount);//((((DWORD)AveLumi)*16384 +(u16HistogramHR>
             ->1))/u16HistogramHR +(u16HistogramVR>>1))/ u16HistogramVR; //average
                      AveLumi = (( DWORD )PreAveLumi + AveLumi ) / 2;
              
                      AveLumi2 = TOTAL_PIXEL_WEIGHT();//msRead2Byte(SC7_36);  //weight
                      AveLumi2 = AVERAGE_LUMINANCE(AveLumi2, TotalPixelCount);//((((DWORD)AveLumi2)*16384 +(u16Histogram
             -HR>>1))/u16HistogramHR +(u16HistogramVR>>1))/ u16HistogramVR; //average
                      AveLumi2 = (( DWORD )PreAveLumi + AveLumi2 ) / 2;
              
              /*
                      PixelCount = msRead2Byte( BK3_35 );
                      LumCount = msRead2Byte( BK3_37 );
                      AveLumi = ( LumCount * 256 ) / PixelCount;
                      AveLumi = (( WORD )PreAveLumi + AveLumi ) / 2;
              
                      PixelCount = msRead2Byte( BK3_35 );
C51 COMPILER V9.01   MSDLC                                                                 03/09/2023 15:39:09 PAGE 23  

                      LumCount = msRead2Byte( BK3_37 );
                      AveLumi2 = ( LumCount * 256 ) / PixelCount;
                      AveLumi2 = (( WORD )PreAveLumi2 + AveLumi2 ) / 2;
              */
                      
                      if( abs( AveLumi2 - AveLumi ) > 10 ) // read twice to confirm? (not stable)
                      {
                      #if 1
                          #if 0//ENABLE_DEBUG
                          printData("ReadFrameDataCnt:%d" , ReadFrameDataCnt);
                          printData("AveLumi:%d" , AveLumi);
                          printData("AveLumi2:%d" , AveLumi2);
                          #endif
                          ReadFrameDataCnt ++;
                          STATISTIC_REQUEST_EN(0);//msWriteByteMask(SC7_B8, 0, BIT2);
                          STATISTIC_REQUEST_EN(1);//msWriteByteMask(SC7_B8, BIT2, BIT2);
                          return;
                      #else
                          mStar_WriteByteMask( BK3_B8, 0x00, (BIT3 | BIT2 | BIT1 | BIT0) );
                          g_bNeedRequest = 1;
                          DLCStatus = DLC_WAIT;
                          msWriteByte( BK0_00, ucBank );
                          ReadFrameDataCnt ++;
                          break;
                      #endif            
                      }
              
                      //BackLightTargetValue = AveLumi;
                      BackLightTargetValue = (AveLumi > 0x100)?(0xff):((BYTE)AveLumi);
              
                      if( abs( BackLightTargetValue - BacklightPrev ) >= DCRStep )
                      {
                          bDCRSmoothMotionFlag = 1;
                          DCRStepTransValue = DCRStep / 2; //abs(BackLightTargetValue-BacklightPrev)/DCRStep;
                      }
                      else
                      {
                          bDCRSmoothMotionFlag = 0;
                      }
              
                      if( bDCRSmoothMotionFlag ) // DCR operating range is over DCRStep
                      {
                          if( BackLightTargetValue >= BacklightPrev ) // increasement
                          {
                              BacklightNow = ( BacklightNow + DCRStepTransValue >= BackLightTargetValue ) ? ( BackLightT
             -argetValue ) : ( BacklightNow + DCRStepTransValue );
                          }
                          else // decreasement
                          {
                              BacklightNow = ( BacklightNow - DCRStepTransValue <= BackLightTargetValue ) ? ( BackLightT
             -argetValue ) : ( BacklightNow - DCRStepTransValue );
                          }
                      }
                      else
                      {
                          BacklightNow = BackLightTargetValue;
                      }
              
              #if DCRMotionTest
                      if( !DCRStepTransCnt )
              #endif
                          if(( BacklightNow != BacklightPrev ) || ( BrightData != PreBrightData ) )
C51 COMPILER V9.01   MSDLC                                                                 03/09/2023 15:39:09 PAGE 24  

                          {
                              BacklightPrev = BacklightNow;
                              PreBrightData = BrightData;
                              mStar_AdjustDcrBrightness();
              #if DCRMotionTest
                              DCRStepTransCnt = DCRStepTransPeriod;
              #endif
                      }                        
                      HistogramPrev = HistogramNow;
                  }
                  else // get upper dark / bright data
                  {
                      DarkData = Y_CHANNEL_MIN_PIXEL();//msReadByte( SC7_39 );
                      BrightData = Y_CHANNEL_MAX_PIXEL();//msReadByte( SC7_3A );
              
                      //u16HistogramVR = msRead2Byte(SC0_1A)+1;
                      //u16HistogramHR = msRead2Byte(SC0_1C)-msRead2Byte(SC0_18)+1;
                      TotalPixelCount = TOTAL_PIXEL_COUNT();
                      AveLumi = TOTAL_PIXEL_WEIGHT();//msRead2Byte(SC7_36);  //weight
                      PreAveLumi = AVERAGE_LUMINANCE(AveLumi, TotalPixelCount);//((((DWORD)AveLumi)*16384 +(u16Histogram
             -HR>>1))/u16HistogramHR +(u16HistogramVR>>1))/ u16HistogramVR; //average
                      AveLumi = TOTAL_PIXEL_WEIGHT();//msRead2Byte(SC7_36);  //weight
                      PreAveLumi2 = AVERAGE_LUMINANCE(AveLumi, TotalPixelCount);//((((DWORD)AveLumi)*16384 +(u16Histogra
             -mHR>>1))/u16HistogramHR +(u16HistogramVR>>1))/ u16HistogramVR; //average
              
                      /*
                      PixelCount = msRead2Byte( BK3_35 );
                      LumCount = msRead2Byte( BK3_37 );
                      PreAveLumi = ( LumCount * 256 ) / PixelCount;
                      PixelCount = msRead2Byte( BK3_35 );
                      LumCount = msRead2Byte( BK3_37 );
                      PreAveLumi2 = ( LumCount * 256 ) / PixelCount;
                      */
                  }
              
                  ReadFrameDataCnt ++;
              
                  STATISTIC_REQUEST_EN(0);//msWriteByteMask(SC7_B8, 0, BIT2);
                  STATISTIC_REQUEST_EN(1);//msWriteByteMask(SC7_B8, BIT2, BIT2);
                  #endif
1434   1      }
1435          
1436          
1437          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1084    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    106       8
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       2
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
